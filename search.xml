<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构与算法-排序算法总结]]></title>
    <url>%2F2020%2F08%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[排序算法总结： 术语说明： 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度： 一个算法执行所耗费的时间； 空间复杂度：运行完一个程序所需内存的大小。 Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序 1. 冒泡排序（Bubble Sort）冒泡排序：是一种简单的排序算法，它从左到右不断交换相邻逆序的元素，在一轮遍历后，可以让未排序部分中最大的元素浮到右侧。不多的从左到右调整，直至数组有序。12345678910111213141516 public int[] bubbleSort(int [] input)&#123; if(input.length == 0)&#123; return input; &#125; for(int i=input.length-1; i&gt;0; i--)&#123; for(int j=0; j&lt;i; j++)&#123; if(input[j] &gt; input[j+1])&#123; int temp = input[j]; input[j] = input[j+1]; input[j+1] = temp; &#125; &#125; &#125; return input;&#125; 算法分析 时间复杂度： O(n^2) 空间复杂度： O(1) 2. 选择排序（Selection Sort）选择排序：首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。选择排序是表现最稳定的排序算法之一 ，因为无论什么数据进去都是O(n2)的时间复杂度 ，所以用到它的时候，数据规模越小越好。123456789101112131415161718 public int[] selectSort(int [] input)&#123; if(input.length == 0)&#123; return input; &#125; for(int i=0; i&lt;input.length; i++)&#123; int minIndex = i; for(int j=i+1; j&lt;input.length; j++)&#123; if(input[j] &lt; input[minIndex])&#123; minIndex = j; &#125; &#125; int temp = input[i]; input[i] = input[minIndex]; input[minIndex] = temp; &#125; return input;&#125; 算法分析 时间复杂度： O(n^2) 空间复杂度： O(1) 3.插入排序（Insertion Sort）插入排序： 直接插入排序是将无序序列中的数据插入到有序的序列中，在遍历无序序列时，首先拿无序序列中的首元素去与有序序列中的每一个元素比较并插入到合适的位置，一直到无序序列中的所有元素插完为止。对于一个无序序列arr{4，6，8，5，9}来说，我们首先先确定首元素4是有序的，然后在无序序列中向右遍历，6大于4则它插入到4的后面，再继续遍历到8，8大于6则插入到6的后面，这样继续直到得到有序序列{4，5，6，8，9}。插入排序所需的时间取决于输入中元素的初始顺序。插入排序对于实际应用中常见的某些类型的非随机数组很有效。插入排序对于部分有序的数组十分高效，也很适合小规模数组。 12345678910111213141516 public int[] insertSort(int [] input)&#123; if(input.length == 0)&#123; return input; &#125; for(int i=1; i&lt;input.length; i++)&#123; int preIndex = i - 1; int current = input[i]; while(preIndex&gt;=0 &amp;&amp; input[preIndex]&gt;current)&#123; input[preIndex+1] = input[preIndex]; preIndex --; &#125; input[preIndex+1] = current; &#125; return input;&#125; 算法分析 时间复杂度: O(n^2) 空间复杂度: O(1) 4. 希尔排序（Shell Sort）希尔排序：对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。希尔排序又叫缩小增量排序。 1234567891011121314151617181920 public int[] shellSort(int [] input)&#123; if(input.length == 0)&#123; return input; &#125; int h = input.length / 2; while(h &gt; 0)&#123; for(int i=h; i&lt;input.length; i++)&#123; int preIndex = i - h; int temp = input[i]; while(preIndex&gt;=0 &amp;&amp; input[preIndex]&gt;temp)&#123; input[preIndex+h] = input[preIndex]; preIndex -= h; &#125; input[preIndex + h] = temp; &#125; h /= 2; &#125; return input;&#125; 算法分析希尔排序的运行时间达不到平方级别， 希尔排序比插入排序和选择排序要快得多，并且数组越大，优势越大。 5. 归并排序（Merge Sort）归并排序： 是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 算法描述 步骤1：把长度为n的输入序列分成两个长度为n/2的子序列； 步骤2：对这两个子序列分别采用归并排序； 步骤3：将两个排序好的子序列合并成一个最终的排序序列。 12345678910111213141516171819202122232425262728293031323334353637 public int[] mergeSort(int [] input)&#123; if(input.length == 0)&#123; return input; &#125; sort(input, 0, input.length-1) return input;&#125; public void sort(int[] input, int lo, int hi)&#123; if(hi &lt;= lo)&#123; return; &#125; int mid = lo + (hi - lo)/2; sort(input, lo, mid); sort(input, mid+1, hi); merge(input, lo, mid, hi);&#125; // 将子序列合并 public void merge(int[] input, int lo, int mid, int hi)&#123; int i = lo; // 左边数组的起始位置 int j = mid + 1; // 右边数组的起始位置 int[] ret = new int[input.length]; for(int k=0; k&lt;input.length; k++)&#123; ret[k] = input[k]; &#125; for(int k=lo; k&lt;hi; k++)&#123; if(i &gt; mid)&#123; input[k] = ret[j++]; // 左边数组用尽 &#125;else if(j &gt; hi)&#123; input[k] = ret[i++]; // 右边数组用尽 &#125;else if(ret[j] &lt; ret[i])&#123; input[k] = ret[j++]; // 右边的数小 &#125;else&#123; input[k] = ret[i++]; // 左边的数小 &#125; &#125;&#125; 算法分析归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn 的时间复杂度。代价是需要额外的内存空间。 时间复杂度：O(nlogn) 空间复杂度：O(n) 6. 快速排序（Quick Sort）快速排序：通过分割元素将待排序的序列分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 快速排序是最快的通用排序方法, 因为快速排序内循环指令少，他还能利用缓存（因为总是顺序访问数组），时间复杂度都是~cNlgN. 算法描述： 从数列中挑出一个元素，称为 “基准” (pivot)； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 12345678910111213141516171819 public int[] quicksort(int [] input)&#123; if(input.length == 0)&#123; return input; &#125; sort(input, 0, input.length-1) return input;&#125; public void sort(int[] input, int lo, int hi)&#123; if(lo &gt;= hi)&#123; return; &#125; int pivot = partition(input, lo, hi); // 基准值 sort(input, lo, pivot-1); sort(input, pivot+1, hi);&#125;public int partition(int[] input, int lo, int hi)&#123; ......;&#125; 将待排序的序列分为两个部分的方法有多种： 方法一： 定义两个指针，begin和end分别指向第一个元素和最后一个元素，基准值key=arr[end]; begin从前向后移动，当遇到大于key的时候停下来，end从后向前移动，当遇到小于key的时候停下，交换begin和end对应的元素； 重复上一步，直至begin与end相遇，begin对应的元素与key值进行交换。 123456789101112131415161718192021public int partition(int[] input, int lo, int hi)&#123; int v = input[lo]; while(lo &lt; hi)&#123; while(lo &lt; hi &amp;&amp; input[hi] &gt;= v)&#123; hi--; &#125; while(lo &lt; hi &amp;&amp; input[lo] &lt;= v)&#123; lo++; &#125; if(lo &lt; hi)&#123; swap(input, lo, hi); &#125; &#125; input[lo] = v; return lo;&#125; public void swap(int[] input, int i, int j)&#123; int temp = input[i]; input[i] = input[j]; input[j] = temp;&#125; 方法二：挖坑法 定义两个指针，begin和end分别指向第一个元素和最后一个元素，基准值key=arr[end]; begin从前向后移动，当遇到大于key的时候停下来，将begin位置的数据放置end处，begin变为坑； end从后开始向前移动，当遇到小于key的时候停下来，将end处的数据放置坑（begin）处，end变为坑，begin开始移动； 重复2、3两步，直至begin与end相遇，最后的一个坑放key。 123456789101112131415public int partition(int[] input, int lo, int hi)&#123; int v = input[lo]; while(lo &lt; hi)&#123; while(lo &lt; hi &amp;&amp; input[hi] &gt;= v)&#123; hi--; &#125; input[lo] = input[hi]; while(lo &lt; hi &amp;&amp; input[lo] &lt;= v)&#123; lo++; &#125; input[hi] = input[lo]; &#125; input[lo] = v; return lo;&#125; 算法分析 时间复杂度： 平均-O(nlogn)， 最坏-O(n^2) 空间复杂度： O(logn) https://blog.csdn.net/wei_cheng18/article/details/80302818 7. 堆排序堆排序：是指利用堆这种数据结构所设计的一种排序算法。堆这种数据结构是一种完全二叉树，堆分为最大堆和最小堆。 最大堆：二叉树中的任一顶点大于等于它的左右子节点 最小堆：二叉树中的任一顶点小于等于它的左右子节点堆可以用数组来存储表示 7.1 算法描述堆排序分为两个阶段，给定一个无序的数组，首先要做的事构造堆。a.将无序输入数组构建成一个堆，根据升序降序需求选择最大堆或最小堆;b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端，N–，将最大的元素固定,再次调整剩余的部分，不再去管它;c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。对于给定的无序构造堆的一个高效方法就是从右向左进行sink下沉操作，不需要管叶子结点（叶子结点已经算作一个有堆，无法进行下沉操作），所以只需要扫描一半的数组元素。 算法的示意动图可参考下文：https://blog.csdn.net/weixin_41190227/article/details/86600821 7.2 代码实现1234567891011121314151617181920212223242526272829303132333435363738 public class HeapSort&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; @Override public void sort(T[] a)&#123; int N=a.length-1; //构建堆 for(int k=N/2;k&gt;=0;k--)&#123; sink(a,k,N); &#125; //堆排序 while(N&gt;0)&#123; exch(a,1,N--); sink(a,1,N); &#125; &#125; private void sink(T[] a,int k,int N)&#123; while(2*k&lt;=N)&#123; int j=2*k; if(j&lt;N &amp;&amp; less(a[j],a[j+1]))&#123; j++; &#125; if(less(a[k],a[j]))&#123; exch(a,k,j); &#125;else&#123; break; &#125; k=j; &#125; &#125; public static void main(String[] args)&#123; HeapSort&lt;String&gt; b=new HeapSort&lt;String&gt;(); String[] str=&#123;"q","sss","aaa","ccc","qqq","bbb"&#125;; b.sort(str); for(int i=1;i&lt;=str.length-1;i++)&#123; System.out.println(str[i]); &#125; &#125;&#125; 算法分析： 时间复杂度： O(nlogn) 空间复杂度： 1]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构和算法-链表问题总结]]></title>
    <url>%2F2020%2F08%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[链表翻转（Reverse Linked List）实现翻转链表的功能 方法一：原地翻转12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class ReverseLinkedList &#123; public ListNode reverseList(ListNode head) &#123; //原地翻转法 if(head == null) return head; ListNode dumpy = head; ListNode pre = head; ListNode cur = head.next; while(cur != null) &#123; pre.next = cur.next; cur.next = dumpy.next; dumpy.next = cur; cur = pre.next; &#125; return dumpy.next; &#125;&#125;``` ## 方法二：建立新链表，插入式翻转 ```java public class ReverseLinkedList &#123; public ListNode reverseList(ListNode head) &#123; //建立新链表，添加节点翻转法 if(head == null) return head; ListNode dumpy = new ListNode(-1); ListNode cur = head; while(cur != null) &#123; ListNode nex = cur.next; cur.next = dumpy.next; dumpy.next = cur; cur = nex; &#125; return dumpy.next; &#125;&#125;``` # 链表中倒数第k个结点**问题描述：** &gt;输入一个链表，输出该链表中倒数第k个结点。**解题思路：快慢指针法** 使用两个指针，fast 和 slow。 首先 fast 从链表头顺序移动 k 个节点， 将 slow 指向链表头部， 连个指针此时相差 k 个节点， 让两个指针同时移动，直到 fast 到了链表尾部，此时 slow指针所指向的节点就是链表的倒数第 k 个节点。```java public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; if(head==null || k==0)&#123; return null; &#125; ListNode fast = head; ListNode slow = head; for(int i=0; i&lt;k-1; i++)&#123; fast = fast.next; if(fast == null)&#123; return null; &#125; &#125; while(fast.next != null)&#123; fast = fast.next; slow = slow.next; &#125; return slow; &#125;&#125; 链表中环的入口结点题目描述 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 解题思路： 方法一：哈希法 遍历单链表的每个结点 如果当前结点地址没有出现在set中，则存入set中 否则，出现在set中，则当前结点就是环的入口结点 整个单链表遍历完，若没出现在set中，则不存在环 123456789101112131415161718public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; if(pHead == null)&#123; return null; &#125; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); while(pHead != null)&#123; if(! set.contains(pHead.val))&#123; set.add(pHead.val); pHead = pHead.next; &#125;else&#123; return pHead; &#125; &#125; return null; &#125;&#125; 方法二：双指针法两个链表的第一个公共结点问题描述 输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） 解题思路 试想一种理想情况：链表A头结点到结点8的长度与链表B头结点到结点8的长度相等，那么就可以用双指针。 -1. 初始化：指针ta指向链表A头结点，指针tb指向链表B头结点 -2. 如果ta == tb， 说明找到了第一个公共的头结点，直接返回即可。 -3. 否则，ta != tb，则++ta，++tb 显然图一中第一个公共结点为8，但是链表A头结点到8的长度为2，链表B头结点到8的长度为3，显然并不相等。 所以需要制造这种理想情况。 假设链表A长度为a， 链表B的长度为b，此时a != b但是，a+b == b+a因此，可以让a+b作为链表A的新长度，b+a作为链表B的新长度。 代码实现1234567891011121314151617181920212223 /*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; if(pHead1==null || pHead2==null)&#123; return null; &#125; ListNode p1 = pHead1; ListNode p2 = pHead2; while(p1 != p2)&#123; p1 = p1 == null ? pHead2 : p1.next; p2 = p2 == null ? pHead1 : p2.next; &#125; return p1; &#125;&#125; 复杂链表的复制题目描述: 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 解题思路： 123456789101112131415161718192021222324252627282930public class Solution &#123; public RandomListNode Clone(RandomListNode pHead) &#123; if(pHead == null)&#123; return null; &#125; RandomListNode pNew = pHead; while(pNew != null)&#123; RandomListNode cloneNode = new RandomListNode(pNew.label); RandomListNode nextNode = pNew.next; cloneNode.next = nextNode; pNew.next = cloneNode; pNew = nextNode; &#125; pNew = pHead; while(pNew != null)&#123; pNew.next.random = pNew.random==null? null: pNew.random.next; pNew = pNew.next.next; &#125; pNew = pHead; RandomListNode pClone = pHead.next; while(pNew != null)&#123; RandomListNode tempNode = pNew.next; pNew.next = tempNode.next; tempNode.next = tempNode.next==null?null:tempNode.next.next; pNew = pNew.next; &#125; return pClone; &#125;&#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统原理总结]]></title>
    <url>%2F2020%2F08%2F12%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、事务概念事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。 事务的四大特征：ACID1. 原子性（Atomicity）事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。 回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。 2. 一致性（Consistency）数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。 3. 隔离性（Isolation）一个事务所做的修改在最终提交以前，对其它事务是不可见的。 4. 持久性（Durability）一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。 系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。 ######———————————————————————————————————————- 事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系： 只有满足一致性，事务的执行结果才是正确的。 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。 事务满足持久化是为了能应对系统崩溃的情况。 AUTOCOMMITMySQL 默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。 二、并发一致性问题在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。 丢失修改丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。 读脏数据读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。 不可重复读不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同 幻影读幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。 ——————————————————————————————————————产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。 三、封锁封锁粒度MySQL 中提供了两种封锁粒度：行级锁以及表级锁。 应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。 但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。 在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。 封锁类型1. 读写锁 互斥锁（Exclusive），简写为 X 锁，又称写锁。 共享锁（Shared），简写为 S 锁，又称读锁。 有以下两个规定： 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。 锁的兼容关系如下： 2. 意向锁使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。 在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。 意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定： 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁； 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。 通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。 各种锁的兼容关系如下： 解释如下： 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁； 这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。） 封锁协议1. 三级封锁协议一级封锁协议事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。 可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。 二级封锁协议在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。 可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。 三级封锁协议在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。 可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。 2. 两段锁协议加锁和解锁分为两个阶段进行。 可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。 事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。 lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B) 但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。 lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C) MySQL 隐式与显示锁定MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。 InnoDB 也可以使用特定的语句进行显示锁定： SELECT ... LOCK In SHARE MODE; SELECT ... FOR UPDATE; 四、隔离级别读未提交（READ UNCOMMITTED）事务中的修改，即使没有提交，对其它事务也是可见的。 读提交（READ COMMITTED）一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。 可重复读（REPEATABLE READ）保证在同一个事务中多次读取同一数据的结果是一样的。 可串行化（SERIALIZABLE）强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。 该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 五、关系数据库设计理论函数依赖记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。 如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。 对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。 对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。 异常以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。 冗余数据：例如 学生-2 出现了两次。 修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。 删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 课程-1 需要删除第一行和第三行，那么 学生-1 的信息就会丢失。 插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。 范式概念：范式理论是为了解决以上提到四种异常。设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小 高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式(3NF）就行了。 1. 第一范式第一范式(1NF)：数据库表的每一列都是不可分割的原子数据项，不能是集合、数组等非原子数据项。即第一范式每一列不可再拆分，称为原子性。 2.第二范式每个非主属性完全函数依赖于键码（在1NF基础上消除非主属性对主码的部分函数依赖）。可以通过分解来满足。 分解前： 以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖： Sno -&gt; Sname, Sdept Sdept -&gt; Mname Sno, Cname-&gt; Grade Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。 分解后：关系-1： 有以下函数依赖： Sno -&gt; Sname, Sdept Sdept -&gt; Mname 关系-2： 有以下函数依赖： Sno, Cname -&gt; Grade 3. 第三范式非主属性不传递函数依赖于键码。在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）。 上面的 关系-1 中存在以下传递函数依赖： Sno -&gt; Sdept -&gt; Mname 可分解为： 关系-11 关系-12 六、 ER 图Entity-Relationship，有三个组成部分：实体、属性、联系。 用来进行关系型数据库系统的概念设计。 实体的三种联系包含一对一，一对多，多对多三种。 果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B； 如果是一对一，画两个带箭头的线段； 如果是多对多，画两个不带箭头的线段。]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习与算法-树模型]]></title>
    <url>%2F2020%2F08%2F09%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[决策树决策树是一种常用的机器学习算法，该算法模型呈树形结构，在分类问题中，表示基于特征对实力进行分类的过程，以西瓜书中西瓜分类为例构建决策树对西瓜进行二分类。 决策树的学习给定数据集样本，构建一棵决策树能够对实力进行正确的分类。 决策树学习算法通常是一个递归地选择最优特征，根据特征对数据集进行分割，使得对各个子数据集有一个最好的分类的过程。 首先构建根节点，将所有训练数据放在根节点，选择一个最优的特征，按照这一特征将训练数据集分割成自己，使得各个自己有一个在当前条件下最好的分类。如果有子集已经被正确的分类，那么构建叶子结点，并将这些子集分到所对应的叶子结点中去；若还有子集没有被正确分类，那么对这些子集选择最优特征，继续进行分割，直到所有训练子集都被正确分类，或者没有合适的特征为止，生成了一棵决策树。（特征选择-&gt;决策树生成） 以上生成的决策树可能对训练数据有很好的的分类能力，但是对于新的测试样本未必有很好的分类能力，即发生过拟合现象。所以需要对已生成的树自下而上进行剪枝、使树变得简单，具有更好的泛化能力。（剪枝） 决策树学习算法主要包括三个过程：特征选择、决策树的生成和决策树的剪枝过程。 特征选择特征选择在于选取对训练数据具有分类能力的特征，以提高决策树学习的效率。 通常特征选择的准则是信息增益或者信息增益比。 信息增益熵熵（entropy）H(p) 是表示随机变量不确定性的度量，熵越大，随机变量的不确定性越大。当 p=0 或 p=1 时 H(p)=0， 随机变量玩却没有不确定性，而当p=0.5时，H(p)=1， 熵最大，随机变量的不确定性最大。 条件熵条件熵 （conditional entropy）H(Y|X) 表示在已知随机变量X的条件下随机变量Y的不确定性。随机变量X给定的条件下随机变量Y的条件熵定义为X给定条件下Y的条件概率分布的熵对X的数学期望： 信息增益信息增益表示得知特征X的信息而使得类Y的信息的不确定性减少的程度。 信息增益的特征选择方法：对于训练数据集/子集 D， 计算其每个特征的信息增益，并比较他们的大小，选择信息增益最大的特征。 信息增益比信息熵倾向于选择取值比较多的属性， 而有些属性可能对分类任务没有太大作用，但是他们仍然可能会被选为最优属性。这种缺陷不是每次都会发生，只是存在一定的概率。解决这个问题可以选择信息增益比。 决策树的生成 ID3算法：应用信息增益准则选择特征，递归地构建决策树 C4.5算法：基于ID3算法进行改进，使用信息增益比来选择特征 决策树的剪枝剪枝是决策树算法处理“过拟合”问题的主要手段。在决策树的学习中，为了尽可能的真确分类训练样本，不断递归的划分，优势造成决策树分支过多，对训练数据的分类很准乌尔，但位置的数据分类没有那么准确，构建出的决策树过于复杂，产生过拟合。 剪枝是简化已生成的决策树的过程。具体地，从已生成的树上去掉一些子树或叶节点，将其根节点或父节点作为新的节点，简化树模型。 回归树梯度提升树随机森林]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-多线程]]></title>
    <url>%2F2020%2F08%2F03%2FJava-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多线程并行和并发 并行：多个处理器或多核处理器同时处理在同一时刻 多个任务。 并发：同一时间段内多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。 进程和线程 进程是资源调度和分配的基本单位，是正运行的程序。 线程是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位，是进程中的一个执行单元。 进程和线程的区别和联系 一个进程中可以有多个线程，它们共享进程资源。 QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。 拥有资源 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 调度 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 系统开销 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 通信方面 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。 Java使用线程有三种使用线程的方法： 继承 Thread 类; 实现 Runnable 接口； 实现 Callable 接口； 实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。 1. 继承 Thread 类 创建类继承Thread类； 实现 run() 方法； 当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。 12345678910 public class MyThread extends Thread &#123; public void run() &#123; // ... &#125;&#125;public static void main(String[] args) &#123; MyThread mt = new MyThread(); mt.start();&#125; 2. 实现 Runnable 接口需要实现接口中的 run() 方法。 1234567 public class MyRunnable implements Runnable &#123; @Override public void run() &#123; // ... &#125;&#125; 使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。 123456 public static void main(String[] args) &#123; MyRunnable instance = new MyRunnable(); Thread thread = new Thread(instance); thread.start();&#125; 3. 实现 Callable 接口与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。 12345678910111213 public class MyCallable implements Callable&lt;Integer&gt; &#123; public Integer call() &#123; return 123; &#125;&#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyCallable mc = new MyCallable(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc); Thread thread = new Thread(ft); thread.start(); System.out.println(ft.get());&#125; 实现接口 VS 继承 Thread实现接口会更好一些，因为： Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；类可能只要求可执行就行，继承整个 Thread 类开销过大。 Thread 类中的start() 和 run() 方法有什么区别？start()方法被用来启动新创建的线程，而且start()内部 调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启 动，start()方法才会启动新线程。 Java中Runnable和Callable有什么不同？Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在 JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。 Thread类中的yield方法有什么作用？Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。 线程安全线程安全定义 如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。 线程同步当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。 要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复数据与不存在数据问题，Java中提供了同步机制(synchronized)来解决。 在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。 为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。有三种方式完成同步操作： 同步代码块 同步方法 锁机制 1. 同步代码块 同步代码块： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 1234 synchronized(同步锁)&#123;需要同步操作的代码&#125; 同步锁:对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁. 锁对象 可以是任意类型。 多个线程对象 要使用同一把锁。 注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。 12345678910111213141516171819202122232425262728 public class Ticket implements Runnable&#123; private int ticket = 100; Object lock = new Object(); /* * 执行卖票操作 */ @Override public void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while(true)&#123; synchronized (lock) &#123; if(ticket&gt;0)&#123; //有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; // TODO Auto‐generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name+"正在卖:"+ticket‐‐); &#125;&#125; 2. 同步方法 同步方法: 使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。 1234 public synchronized void method()&#123;可能会产生线程安全问题的代码&#125; 同步锁是谁? 对于非static方法,同步锁就是this。 对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。 3. 同步类123456 public void func() &#123; synchronized (SynchronizedExample.class) &#123; // ... &#125;&#125; 作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。 4. 锁机制java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。 Lock锁也称同步锁，加锁与释放锁方法化了，如下： public void lock() :加同步锁。 public void unlock() :释放同步锁。 1234567891011121314 public class LockExample &#123; private Lock lock = new ReentrantLock(); public void func() &#123; lock.lock(); try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + " "); &#125; &#125; finally &#123; lock.unlock(); // 确保释放锁，从而避免发生死锁。 &#125; &#125;&#125; 比较 锁的实现: synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。 性能: 新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。 等待可中断: 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock 可中断，而 synchronized 不行。 公平锁: 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。 锁绑定多个条件: 一个 ReentrantLock 可以同时绑定多个 Condition 对象。 使用选择除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 1) synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且2) 使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。 线程间的协作当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。 1. join()在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。 对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。 123456789101112131415161718192021222324252627282930 public class JoinExample &#123; private class A extends Thread &#123; @Override public void run() &#123; System.out.println("A"); &#125; &#125; private class B extends Thread &#123; private A a; B(A a) &#123; this.a = a; &#125; @Override public void run() &#123; try &#123; a.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("B"); &#125; &#125; public void test() &#123; A a = new A(); B b = new B(a); b.start(); a.start(); &#125;&#125; 12345 public static void main(String[] args) &#123; JoinExample example = new JoinExample(); example.test();&#125; 123 AB 2. wait() notify() notifyAll()调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。 它们都属于 Object 的一部分，而不属于 Thread。 只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。 使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。 1) wait() 和 sleep() 的区别 wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法； wait() 会释放锁，sleep() 不会; wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而 sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁. 2) 为什么wait, notify 和 notifyAll这些方法不在thread类里面？这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在 Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通 过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁 就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。 3. await() signal() signalAll()java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。 相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。 使用 Lock 来获取一个 Condition 对象。 12345678910111213141516171819202122232425 public class AwaitSignalExample &#123; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void before() &#123; lock.lock(); try &#123; System.out.println("before"); condition.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void after() &#123; lock.lock(); try &#123; condition.await(); System.out.println("after"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 1234567 public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); AwaitSignalExample example = new AwaitSignalExample(); executorService.execute(() -&gt; example.after()); executorService.execute(() -&gt; example.before());&#125; 123 beforeafter 线程状态一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态。 1. 新建（NEW）创建后尚未启动。 2. 可运行（RUNABLE）正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。 3. 阻塞（BLOCKED）请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。 4. 无限期等待（WAITING）等待其它线程显式地唤醒。 阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用 Object.wait() 等方法进入。 5. 限期等待（TIMED_WAITING）无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。 调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。 6. 死亡（TERMINATED）可以是线程结束任务之后自己结束，或者产生了异常而结束。 等待唤醒机制多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— 等待唤醒机制。 这是多个线程间的一种协作机制。谈到线程我们经常想到的是线程间的竞争（race），比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。就是在一个线程进行了规定操作后，就进入等待状态（wait()）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（notify()）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。 wait/notify 就是线程间的一种协作机制。 线程池 什么是线程池？ 为什么要使用它？创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短 的任务的程序的可扩展线程池）。 线程池的概念： 其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。 合理利用线程池能够带来三个好处： 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb-Spring框架（1）]]></title>
    <url>%2F2020%2F07%2F28%2FJavaWeb-Spring%E6%A1%86%E6%9E%B6%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Spring框架概述 Spring框架是什么？ Spring是分层的Java SE/EE应用 full-stack轻量级开源框架，以IoC（Inverse Of Control：反转控制）和AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。 Spring的优势 方便解耦，简化开发: 通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 AOP编程的支持: 通过Spring的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。 声明式事务的支持: 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。 方便程序的测试: 可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情 方便集成各种优秀框架: Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的直接支持。 降低JavaEE API的使用难度: Spring对JavaEE API（如JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。 Spring体系结构 IoC的概念和作用1. 程序的耦合与工程模式解耦 程序的耦合 耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差( 降低耦合性，可以提高其独立性)。耦合性存在于各个领域，而非软件设计中独有的，但是我们只讨论软件工程中的耦合。 工厂模式解耦 在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。 那么，这个读取配置文件，创建和获取三层对象的类就是工厂。 创建service和dao对象 1）.需要一个配置文件配置service和dao2）.通过读取配置文件中的配置内容，反射创建对象 2. IoC的概念 IoC的概念： IoC（Inverse Of Control：控制反转）：把创建对象的权利交给框架，是框架的重要特征，并非面向对象编程的术语。他包括依赖注入（Dependency Injection，DI）和依赖查找（Dependency Lookup） IoC的作用： 消减计算机程序的耦合（解除代码间的依赖关系） 3. 使用Spring Ioc解决程序耦合这里使用的案例是，账户的业务层和持久层的依赖关系解决。创建如下程序： 创建持久层接口和实现类 123456789101112131415161718 /** * 账户的持久层接口 */public interface IAccountDao &#123; /** * 模拟保存账户 */ void saveAccount();&#125;/** * 账户的持久层实现类 */public class AccountDaoImpl implements IAccountDao &#123; public void saveAccount()&#123; System.out.println("保存了账户"); &#125;&#125; 创建业务层接口和实现类 12345678910111213141516171819202122 /** * 账户业务层的接口 */public interface IAccountService &#123; /** * 模拟保存账户 */ void saveAccount();&#125; /** * 账户的业务层实现类 */public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao ; public AccountServiceImpl()&#123; System.out.println("对象创建了"); &#125; public void saveAccount()&#123; accountDao.saveAccount(); &#125; &#125; 基于XML的配置 导入Spring jar包 在resources目录下创建任意.xml文件 {% codeblock lang:java %} > > xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" > xsi:schemaLocation="http://www.springframework.org/schema/beans > http://www.springframework.org/schema/beans/spring-beans.xsd"> > > > > > {% endcodeblock %} 使用spring 123456789101112131415161718192021222324252627282930313233343536 /** * 模拟一个表现层，用于调用业务层 */public class Client &#123; /** * 获取spring的Ioc核心容器，并根据id获取对象 * * ApplicationContext的三个常用实现类： * ClassPathXmlApplicationContext：它可以加载类路径下的配置文件，要求配置文件必须在类路径下。不在的话，加载不了。(更常用) * FileSystemXmlApplicationContext：它可以加载磁盘任意路径下的配置文件(必须有访问权限） * * AnnotationConfigApplicationContext：它是用于读取注解创建容器的，是明天的内容。 * * 核心容器的两个接口引发出的问题： * ApplicationContext: 单例对象适用 采用此接口 * 它在构建核心容器时，创建对象采取的策略是采用立即加载的方式。也就是说，只要一读取完配置文件马上就创建配置文件中配置的对象。 * * BeanFactory: 多例对象使用 * 它在构建核心容器时，创建对象采取的策略是采用延迟加载的方式。也就是说，什么时候根据id获取对象了，什么时候才真正的创建对象。 * @param args */ public static void main(String[] args) &#123; //1.获取核心容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //ApplicationContext ac = new FileSystemXmlApplicationContext("C:\\Users\\zhy\\Desktop\\bean.xml"); //2.根据id获取Bean对象 IAccountService as = (IAccountService)ac.getBean("accountService"); IAccountDao adao = ac.getBean("accountDao",IAccountDao.class); System.out.println(as); System.out.println(adao); as.saveAccount(); &#125;&#125; Spring基于XML的IOC细节1. spring中工厂的类结构图 BeanFactory 和ApplicationContext 的区别 * BeanFactory 才是Spring 容器中的顶层接口。 * ApplicationContext 是它的子接口。 * BeanFactory 和 ApplicationContext 的区别： 创建对象的时间点不一样。 - ApplicationContext： 它在构建核心容器时，创建对象采取的策略是采用立即加载的方式。也就是说，只要一读取完配置文件马上就创建配置文件中配置的对象。 - BeanFactory：它在构建核心容器时，创建对象采取的策略是采用延迟加载的方式。也就是说，什么时候根据id获取对象了，什么时候才真正的创建对象。 ApplicationContext 接口的实现类 * ClassPathXmlApplicationContext： 它是从类的根路径下加载配置文件 推荐使用这种 * FileSystemXmlApplicationContext： 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 * AnnotationConfigApplicationContext: 当我们使用注解配置容器对象时，需要使用此类来创建spring 容器。它用来读取注解。 2. IOC中bean标签和管理对象细节1）创建Bean的三种方式第一种方式：使用默认无参构造函数 在Spring的配置文件中使用bean标签，配以id和class属性之后，没有其他属性标签时，根据默认无参构造函数来创建类对象。如果bean中没有默认无参构造函数，将会创建失败。 &lt;bean id=&quot;accountService&quot; class=&quot;bjtu.service.impl.AccountServiceImpl&quot;/&gt; 第二种方式：使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器） 第三种方式：使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器） 2）Bean的作用范围和生命周期 bean的作用范围 bean标签的scope属性： 作用：用于指定bean的作用范围 取值： 常用的就是单例的和多例的 singleton：单例的（默认值）-一个应用只有一个对象的实例。它的作用范围就是整个引用。 prototype：多例的-每次访问对象时，都会重新创建对象实例。 request：作用于web应用的请求范围 session：作用于web应用的会话范围 global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;--&gt; bean的生命周期 &lt;!-- bean对象的生命周期 单例对象 出生：当容器创建时对象出生 活着：只要容器还在，对象一直活着 死亡：容器销毁，对象消亡 总结：单例对象的生命周期和容器相同 多例对象 出生：当我们使用对象时spring框架为我们创建 活着：对象只要是在使用过程中就一直活着。 死亡：当对象长时间不用，且没有别的对象引用时，由Java的垃圾回收器回收 --&gt; 3. Spring中的依赖注入* 依赖注入： Dependency Injection * IOC的作用： 降低程序间的耦合（依赖关系） * 依赖关系的管理： 以后都交给spring来维护 在当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中说明 * 依赖关系的维护： 就称之为依赖注入。 *依赖注入： 1. 能注入的数据：有三类 1) 基本类型和String 2) 其他bean类型（在配置文件中或者注解配置过的bean） 3) 复杂类型/集合类型 2. 注入的方式：有三种 1) 第一种：使用构造函数提供 2) 第二种：使用set方法提供 3) 第三种：使用注解提供 1)构造函数注入123456789101112131415 public class AccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public AccountServiceImpl(String name, Integer age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday; &#125; @Override public void saveAccount() &#123; ystem.out.println(name+","+age+","+birthday); &#125; &#125; 使用的标签:constructor-arg 标签出现的位置：bean标签的内部 标签中的属性 type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型 index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始 name：用于指定给构造函数中指定名称的参数赋值 常用的 =============以上三个用于指定给构造函数中哪个参数赋值=============================== value：用于提供基本类型和String类型的数据 ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象 优势： 在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。 弊端： 改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。 --&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;泰斯特&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 配置一个日期对象 --&gt; &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt; 2) set方法注入12345678910111213141516171819202122232425262728 public class AccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public AccountServiceImpl(String name, Integer age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public void saveAccount() &#123; ystem.out.println(name+","+age+","+birthday); &#125;&#125; 涉及的标签：property 出现的位置：bean标签的内部 标签的属性 name：用于指定注入时所调用的set方法名称 value：用于提供基本类型和String类型的数据 ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象 优势： 创建对象时没有明确的限制，可以直接使用默认构造函数 弊端： 如果有某个成员必须有值，则获取对象是有可能set方法没有执行。 --&gt; &lt;bean id=&quot;accountService2&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl2&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;TEST&quot; &gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt; &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 3）注入集合顾名思义，就是给类中的集合成员传值，它用的也是set方法注入的方式，只不过变量的数据类型都是集合。我们这里介绍注入数组，List,Set,Map,Properties。具体代码如下： 123456789101112131415161718192021222324252627282930public class AccountServiceImpl implements IAccountService &#123; private String[] myStrs; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String,String&gt; myMap; private Properties myProps; public void setMyStrs(String[] myStrs) &#123; this.myStrs = myStrs; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, String&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125; @Override public void saveAccount() &#123; System.out.println(Arrays.toString(myStrs)); System.out.println(myList); System.out.println(mySet); System.out.println(myMap); System.out.println(myProps); &#125;&#125; 复杂类型的注入/集合类型的注入 *用于给List结构集合注入的标签： list array set * 用于个Map结构集合注入的标签: map props 结构相同，标签可以互换 123456789101112131415161718192021222324252627282930313233343536373839404142 &lt;bean id="accountService3" class="com.itheima.service.impl.AccountServiceImpl3"&gt; &lt;property name="myStrs"&gt; &lt;set&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name="myList"&gt; &lt;array&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name="mySet"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="myMap"&gt; &lt;props&gt; &lt;prop key="testC"&gt;ccc&lt;/prop&gt; &lt;prop key="testD"&gt;ddd&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name="myProps"&gt; &lt;map&gt; &lt;entry key="testA" value="aaa"&gt;&lt;/entry&gt; &lt;entry key="testB"&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; Spring 基于注解的IoC配置基于XML的IoC配置： 12345 &gt; &lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl" scope="" init-method="" destroy-method=""&gt;&gt; &lt;property name="" value="" | ref=""&gt;&lt;/property&gt;&gt; &lt;/bean&gt;&gt; 环境构建 在使用注解进行IoC配置前，应更改项目的 xml （bean.xml）配置文件。 基于注解整合时，导入约束时需要多导入一个context名称空间下的约束。 1234567891011121314 &gt; &lt;?xml version="1.0" encoding="UTF-8"?&gt;&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans"&gt; xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt; xmlns:context="http://www.springframework.org/schema/context"&gt; xsi:schemaLocation="http://www.springframework.org/schema/beans&gt; http://www.springframework.org/schema/beans/spring-beans.xsd&gt; http://www.springframework.org/schema/context&gt; http://www.springframework.org/schema/context/spring-context.xsd"&gt;&gt; &lt;!--告知spring在创建容器时要扫描的包，配置所需要的标签不是在beans的约束中，而是一个名称为&gt; context名称空间和约束中--&gt;&gt; &lt;context:component-scan base-package="bjtu"&gt;&lt;/context:component-scan&gt;&gt; &lt;/beans&gt;&gt; 1. 常用的注解分类1.1 用于创建对象的他们的作用就和在 XML 配置文件中编写一个 标签实现的功能是一样的, 相当于：id12345678910111213141516171819202122232425262728293031323334353637383940414243444546- **@Component** 作用：用于把当前类对象存入spring容器中 属性： value：指定bean的id。如果不指定value属性，默认bean的id是当前类的类名。首字母小写。- @Controller：一般用在表现层 - @Service：一般用在业务层 - @Repository：一般用在持久层 以上三个注解他们的作用和属性与Component是一模一样。 他们三个是spring框架为我们提供明确的三层使用的注解，使我们的三层对象更加清晰## 1.2 用于注入数据的相当于：&lt;property name=&quot;&quot; ref=&quot;&quot;&gt;&lt;property name=&quot;&quot; value=&quot;&quot;&gt; - **@Autowired** - 自动按照类型注入。当使用注解注入属性时，set方法可以省略。它只能注入其他bean类型。当有多个类型匹配时，使用要注入的对象变量名称作为bean的id，在spring容器查找，找到了也可以注入成功。找不到就报错。- **@Qualifier** - 在自动按照类型注入的基础之上，再按照Bean的id注入。它在给字段注入时不能独立使用，必须和@Autowire一起使用；但是给方法参数注入时，可以独立使用。 - 属性： value：指定bean的id。- **@Resource** - 直接按照Bean的id注入。它也只能注入其他bean类型。 - 属性：name：指定bean的id以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。 另外，集合类型的注入只能通过XML来实现。- **@Value** - 注入基本数据类型和String类型数据的 - 属性： value：用于指定值## 1.3 用于改变作用范围的相当于：&lt;bean id=&quot;&quot; class=&quot;&quot; scope=&quot;&quot;&gt; - **@Scope** - 指定bean的作用范围。 - 属性：value：指定范围的值。 取值：singleton、prototype、requestsession、 globalsession## 1.4 和生命周期相关的相当于：```&lt;bean id=&quot;&quot; class=&quot;&quot; init-method=&quot;&quot; destroy-method=&quot;&quot; /&gt; @PostConstruct： 用于指定初始化方法。 @PreDestroy： 用于指定销毁方法。 2. 新注解 @Configuration 用于指定当前类是一个spring配置类，当创建容器时会从该类上加载注解。获取容器时需要使用AnnotationConfigApplicationContext (有 @Configuration 注解的类.class )。 当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写 1public class SpringConfiguration &#123; &#125; @ComponentScan 用于指定spring在初始化容器时要扫描的包。作用和在spring的xml配置文件中的： &lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt; 是一样的。 属性： basePackages：用于指定要扫描的包 @Bean 该注解只能写在方法上，表明使用此方法创建一个对象，并且放入spring容器。 属性： name：给当前@Bean注解方法创建的对象指定一个名称(即bean的id）。 当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象。 查找的方式和Autowired注解的作用是一样的。 @Import 用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration注解。当然，写上也没问题。 属性： value[]：用于指定其他配置类的字节码 当我们使用Import的注解之后，有Import注解的类就父配置类，而导入的都是子配置类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 /*** 主配置类：bjtu/config/SpringConfiguration.java*/@ComponentScan("com.itheima")@Import(JdbcConfig.class)@PropertySource("classpath:jdbcConfig.properties")public class SpringConfiguration &#123;&#125;/** * 和spring连接数据库相关的配置类:bjtu/config/JdbcConfig.java */public class JdbcConfig &#123; @Value("$&#123;jdbc.driver&#125;") private String driver; @Value("$&#123;jdbc.url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;jdbc.password&#125;") private String password; /** * 用于创建一个QueryRunner对象 * @param dataSource * @return */ @Bean(name="runner") @Scope("prototype") public QueryRunner createQueryRunner(@Qualifier("ds2") DataSource dataSource)&#123; return new QueryRunner(dataSource); &#125; /** * 创建数据源对象 * @return */ @Bean(name="ds2") public DataSource createDataSource()&#123; try &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setDriverClass(driver); ds.setJdbcUrl(url); ds.setUser(username); ds.setPassword(password); return ds; &#125;catch (Exception e)&#123; throw new RuntimeException(e); &#125; &#125; @Bean(name="ds1") public DataSource createDataSource1()&#123; try &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setDriverClass(driver); ds.setJdbcUrl("jdbc:mysql://localhost:3306/eesy02"); ds.setUser(username); ds.setPassword(password); return ds; &#125;catch (Exception e)&#123; throw new RuntimeException(e); &#125; &#125;&#125; Spring 中的 AOP1. AOP的概念 AOP：全称是Aspect Oriented Programming即：面向切面编程。 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。 AOP的作用： 在程序运行期间，使用动态代理的技术不修改源码对已有方法进行增强。 AOP的优势： 减少重复代码 提高开发效率 维护方便 2. Spring中AOP的细节AOP相关术语 Joinpoint(连接点): 所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点。 Pointcut(切入点): 所谓切入点是指我们要对哪些Joinpoint进行拦截的定义。 Advice(通知/增强): 所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。 通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。 Target(目标对象): 代理的目标对象。 Weaving(织入): 是指把增强应用到目标对象来创建新的代理对象的过程。 spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。 Proxy（代理）: 一个类被AOP织入增强后，就产生一个结果代理类。 Aspect(切面): 是切入点和通知（引介）的结合 Spring框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 2.1 基于XML的AOP配置spring中基于XML的AOP配置步骤：1、把通知Bean也交给spring来管理2、使用aop:config标签表明开始AOP的配置3、使用aop:aspect标签表明配置切面id属性： 是给切面提供一个唯一标识 ref属性： 是指定通知类bean的Id。 4、在aop:aspect标签的内部使用对应标签来配置通知的类型aop:before：表示配置前置通知 method属性：用于指定Logger类中哪个方法是前置通知 pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强 ponitcut-ref： 用于指定切入点的表达式的引用，该引用使用aop:pointcut配置 通知类型： * aop:before - 作用： 用于配置前置通知。指定增强的方法在切入点方法之前执行 - 执行时间：切入点方法执行之前执行 * aop:after-returning - 用于配置后置通知 - 切入点方法正常执行之后。它和异常通知只能有一个执行 * aop:after-throwing - 用于配置异常通知 - 执行时间：切入点方法执行产生异常后执行。它和后置通知只能执行一个 * aop:after - 用于配置最终通知 - 执行时间：无论切入点方法执行时是否有异常，它都会在其后面执行。 5. 使用aop:pointcut配置切入点表达式1） 作用： 用于配置切入点表达式。就是指定对哪些类的哪些方法进行增强。 2） 属性： id属性： 用于指定表达式的唯一标识 expression属性： 用于指定表达式内容 此标签写在aop:aspect标签内部只能当前切面使用。 它还可以写在aop:aspect外面，此时就变成了所有切面可用 3）切入点表达式的写法： 关键字：execution(表达式) 表达式： 访问修饰符 返回值 包名.包名.包名...类名.方法名(参数列表) * 标准的表达式写法： public void com.itheima.service.impl.AccountServiceImpl.saveAccount() * 访问修饰符可以省略 void com.itheima.service.impl.AccountServiceImpl.saveAccount() * 返回值可以使用通配符，表示任意返回值 * com.itheima.service.impl.AccountServiceImpl.saveAccount() * 包名可以使用通配符，表示任意包。但是有几级包，就需要写几个*. * *.*.*.*.AccountServiceImpl.saveAccount()) * 包名可以使用..表示当前包及其子包 * *..AccountServiceImpl.saveAccount() * 类名和方法名都可以使用*来实现通配 * *..*.*() * 参数列表： 可以直接写数据类型： 基本类型直接写名称 int 引用类型写包名.类名的方式 java.lang.String 可以使用通配符表示任意类型，但是必须有参数 可以使用..表示有无参数均可，有参数可以是任意类型 * 全通配写法： * *..*.*(..) * 实际开发中切入点表达式的通常写法： 切到业务层实现类下的所有方法 * com.itheima.service.impl.*.*(..) bean.xml配置文件的配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&gt; &lt;?xml version="1.0" encoding="UTF-8"?&gt;&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans"&gt; xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt; xmlns:aop="http://www.springframework.org/schema/aop"&gt; xsi:schemaLocation="http://www.springframework.org/schema/beans&gt; http://www.springframework.org/schema/beans/spring-beans.xsd&gt; http://www.springframework.org/schema/aop&gt; http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;&gt; &gt; &lt;!-- 配置srping的Ioc,把service对象配置进来--&gt;&gt; &lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt;&lt;/bean&gt;&gt; &gt; &lt;!-- 配置Logger类： 通知类--&gt;&gt; &lt;bean id="logger" class="com.itheima.utils.Logger"&gt;&lt;/bean&gt;&gt; &gt; &lt;!--配置AOP--&gt;&gt; &lt;aop:config&gt;&gt; &lt;!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容&gt; 此标签写在aop:aspect标签内部只能当前切面使用。&gt; 它还可以写在aop:aspect外面，此时就变成了所有切面可用&gt; --&gt;&gt; &lt;aop:pointcut id="pt1" expression="execution(* com.itheima.service.impl.*.*(..))"&gt;&lt;/aop:pointcut&gt;&gt; &gt; &lt;!--配置切面 --&gt;&gt; &lt;aop:aspect id="logAdvice" ref="logger"&gt;&gt; &lt;!-- 配置前置通知：在切入点方法执行之前执行&gt; &lt;aop:before method="beforePrintLog" pointcut-ref="pt1" &gt;&lt;/aop:before&gt;--&gt;&gt; &gt; &lt;!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个&gt; &lt;aop:after-returning method="afterReturningPrintLog" pointcut-ref="pt1"&gt;&lt;/aop:after-returning&gt;--&gt;&gt; &gt; &lt;!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个&gt; &lt;aop:after-throwing method="afterThrowingPrintLog" pointcut-ref="pt1"&gt;&lt;/aop:after-throwing&gt;--&gt;&gt; &gt; &lt;!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行&gt; &lt;aop:after method="afterPrintLog" pointcut-ref="pt1"&gt;&lt;/aop:after&gt;--&gt;&gt; &gt; &lt;!-- 配置环绕通知 详细的注释请看Logger类中--&gt;&gt; &lt;aop:around method="aroundPringLog" pointcut-ref="pt1"&gt;&lt;/aop:around&gt;&gt; &lt;/aop:aspect&gt;&gt; &lt;/aop:config&gt;&gt; &gt; &lt;/beans&gt;&gt; 6. 环绕通知aop:around： 作用： 用于配置环绕通知 属性： method：指定通知中方法的名称。 pointct：定义切入点表达式 pointcut-ref：指定切入点表达式的引用 环绕通知是spring框架为我们提供的一种可以在代码中手动控制增强代码什么时候执行的方式。 通常情况下，环绕通知都是独立使用的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 /** * 用于记录日志的工具类，它里面提供了公共的代码 */public class Logger &#123; /** * 前置通知 */ public void beforePrintLog()&#123; System.out.println("前置通知Logger类中的beforePrintLog方法开始记录日志了。。。"); &#125; /** * 后置通知 */ public void afterReturningPrintLog()&#123; System.out.println("后置通知Logger类中的afterReturningPrintLog方法开始记录日志了。。。"); &#125; /** * 异常通知 */ public void afterThrowingPrintLog()&#123; System.out.println("异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了。。。"); &#125; /** * 最终通知 */ public void afterPrintLog()&#123; System.out.println("最终通知Logger类中的afterPrintLog方法开始记录日志了。。。"); &#125; /** * 环绕通知 * 问题： * 当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。 * 分析： * 通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。 * 解决： * Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。 * 该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。 * * spring中的环绕通知： * 它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。 */ public Object aroundPringLog(ProceedingJoinPoint pjp)&#123; Object rtValue = null; try&#123; Object[] args = pjp.getArgs();//得到方法执行所需的参数 System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。前置"); rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法） System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。后置"); return rtValue; &#125;catch (Throwable t)&#123; System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。异常"); throw new RuntimeException(t); &#125;finally &#123; System.out.println("Logger类中的aroundPringLog方法开始记录日志了。。。最终"); &#125; &#125;&#125; 2.2 基于注解的AOP配置]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识总结]]></title>
    <url>%2F2020%2F07%2F26%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一.数据类型基本类型我们都知道在Java语言中，new一个对象是存储在堆里的，我们通过栈中的引用来使用这些对象； 所以，对象本身来说是比较消耗资源的。对于经常用到的类型，如int等，如果我们每次使用这种变量的时候都需要new一个Java对象的话，就会比较笨重。 所以，和C++一样，Java提供了基本数据类型，这种数据的变量不需要使用new创建，他们不会在堆上创建，而是直接在栈内存中存储，因此会更加高效。 在java中有基本数据类型8个，其余都是引用类型； 六种数字类型（4个整数类型，2个浮点型），一种字符型，一种bool型； 包装类型Java是一个面相对象的编程语言，基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。 另外，当需要往ArrayList，HashMap中放东西时，像int，double这种基本类型是放不进去的，因为容器都是装object的，这是就需要这些基本类型的包装器类了。 每个基本类型，有对应的包装类型，包装类型提供对象的最大值、最小值及对象的相关操作。 值类型一般存在栈中，引用类型一般存在堆中 基本类型和包装类型的区别： 1. 声明方式不同： 基本类型不使用new关键字，而包装类型需要使用new关键字来在堆中分配存储空间； 2. 存储方式及位置不同： 基本类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用； 3. 初始值不同： 基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null； 4. 使用方式不同： 基本类型直接赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。 自动装箱与自动拆箱有了基本数据类型和包装类，肯定有些时候要在他们之间进行转换。比如把一个基本数据类型的int转换成一个包装类型的Integer对象。把基本数据类型转换成包装类的过程称为装箱；反之，把包装类转换成基本数据类型的过程就是拆箱。 在Java SE5中，为了减少开发人员的工作，Java提供了自动拆箱与自动装箱功能。 自动装箱: 就是将基本数据类型自动转换成对应的包装类。 自动拆箱：就是将包装类自动转换成对应的基本数据类型。 自动装箱都是通过包装类的 valueOf() 方法来实现的。自动拆箱都是通过包装类对象的 xxxValue() 来实现的。如int和Integer：12345678 public static void main(String[]args)&#123; Integer x = 2; // 装箱 调用了 Integer.valueOf(2) int y = x; // 拆箱 调用了 X.intValue() Integer integer=Integer.valueOf(1); //自动装箱 int i=integer.intValue(); //自动拆箱&#125; 缓存池new Integer(123) 与 Integer.valueOf(123) 的区别在于： new Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 1234567 Integer x = new Integer(123);Integer y = new Integer(123);System.out.println(x == y); // falseInteger z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // true valueOf()方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。编译器会在自动装箱过程调用valueOf()方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。 123Integer m = 123;Integer n = 123;System.out.println(m == n); // true String类型基本概述String类的部分源码如下，在 Java 8 中，String 内部使用 char 数组存储数据。 12345public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[];&#125; 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。 1234567public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final byte[] value; /** The identifier of the encoding used to encode the bytes in &#123;@code value&#125;. */ private final byte coder;&#125; 从源码中可以看到 String 被声明为 final，因此它不可被继承 (Integer 等包装类也不能被继承）；value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 String 不可变的好处： 可以缓存 hash 值因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算，之后直接使用无须重新生成，从而间接的提升访问效率。 String Pool 的需要如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。 安全性String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。 线程安全String 不可变性天生具备线程安全，可以在多个线程中安全地使用 String, StringBuffer and StringBuilder 可变性 String 不可变 StringBuffer 和 StringBuilder 可变 线程安全 String 不可变，因此是线程安全的 StringBuilder 不是线程安全的 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 String Pool字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得同一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。 123456String s1 = new String("aaa");String s2 = new String("aaa");System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4); // true 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。 123String s5 = "bbb";String s6 = "bbb";System.out.println(s5 == s6); // true 二. 关键字final1. 修饰数据声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变； 对于引用类型（类，接口，数组），final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 1234final int x = 1;// x = 2; // cannot assign value to final variable 'x'final A y = new A();y.a = 1; 2. 修饰方法 final 修饰的方法不能被子类重写（private方法也不可重写） private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 3. 修饰类final 修饰的类不可以被继承 static1. 静态变量 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。 12345678910class Static&#123; static int i=47;&#125; ``` 即使创建多个对象也共享同一个变量i：```java Static st1=new Static();Static st2=new Static(); 和 ```st2.i``` 指向同一个存储空间地址，有相同的值，也可以通过 ```Static.i``` 引用变量.1234567891011### 2. 静态方法静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。```java public abstract class A &#123; public static void func1()&#123; &#125; // public abstract static void func2(); // Illegal combination of modifiers: &apos;abstract&apos; and &apos;static&apos;&#125; 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因此这两个关键字与具体对象关联。 123456789public class A &#123; private static int x; private int y; public static void func1()&#123; int a = x; // int b = y; // Non-static field 'y' cannot be referenced from a static context // int b = this.y; // 'A.this' cannot be referenced from a static context &#125;&#125; static方法中没有this关键字 static方法不能调用非静态方法，反过来可以 所有构造方法都默认被static修饰 3. 静态语句块静态语句块在类初始化时运行一次, 随着类的加载而加载,与对象无关。 4. 静态内部类非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。 123456789101112public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法。 5. 初始化顺序静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 存在继承的情况下，初始化顺序为： 父类（静态变量、静态语句块） 子类（静态变量、静态语句块） 父类（实例变量、普通语句块） 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数） 成员变量与局部变量的区别1、在类中的位置不同成员变量：在类中方法外面局部变量：在方法或者代码块中，或者方法的声明上（即在参数列表中） 2、在内存中的位置不同成员变量：在堆中（方法区中的静态区）局部变量：在栈中 3、生命周期不同成员变量：随着对象的创建而存在，随着对象的消失而消失局部变量：随着方法的调用或者代码块的执行而存在，随着方法的调用完毕或者代码块的执行完毕而消失 4、初始值成员变量：有默认初始值局部变量：没有默认初始值，使用之前需要赋值，否则编译器会报错（The local variable xxx may not have been initialized） 三、Object 通用方法方法概述 1234567891011public native int hashCode()public boolean equals(Object obj)protected native Object clone() throws CloneNotSupportedExceptionpublic String toString()public final native Class&lt;?&gt; getClass()protected void finalize() throws Throwable &#123;&#125;public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedException equals()1. 等价关系两个对象具有等价关系，需要满足以下五个条件： I 自反性1x.equals(x); // true ####Ⅱ 对称性 1x.equals(y) == y.equals(x); // true Ⅲ 传递性12if (x.equals(y) &amp;&amp; y.equals(z)) x.equals(z); // true; Ⅳ 一致性多次调用 equals() 方法结果不变 x.equals(y) == x.equals(y); // true Ⅴ 与 null 的比较对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false x.equals(null); // false; 2. 等价与相等 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。 1234Integer x = new Integer(1);Integer y = new Integer(1);System.out.println(x.equals(y)); // trueSystem.out.println(x == y); // false 3. 实现 检查是否为同一个对象的引用，如果是直接返回 true； 检查是否是同一个类型，如果不是，直接返回 false； 将 Object 对象进行转型； 判断每个关键域是否相等。 12345678910111213141516171819public class EqualExample &#123; private int x; private int y; private int z; public EqualExample(int x, int y, int z) &#123; this.x = x; this.y = y; this.z = z; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; EqualExample that = (EqualExample) o; if (x != that.x) return false; if (y != that.y) return false; return z == that.z; &#125;&#125; hashCode()hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。 在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。 HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。 四、继承访问权限Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。 可以对类或类中的成员（字段和方法）加上访问修饰符。 类可见表示其它类可以用这个类创建实例对象。 成员可见表示其它类可以用这个类的实例对象访问到该成员； protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。 设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。 如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。 字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。 123public class AccessExample &#123; public String id;&#125; 可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。 123456789public class AccessExample &#123; private int id; public String getId() &#123; return id + ""; &#125; public void setId(String id) &#123; this.id = Integer.valueOf(id); &#125;&#125; 但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。 123456789101112public class AccessWithInnerClassExample &#123; private class InnerClass &#123; int x; &#125; private InnerClass innerClass; public AccessWithInnerClassExample() &#123; innerClass = new InnerClass(); &#125; public int getValue() &#123; return innerClass.x; // 直接访问 &#125;&#125; 抽象类与接口1. 抽象类抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。 抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。 2. 接口接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。 从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。 接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。 接口的字段默认都是 static 和 final 的。 123456789101112public interface InterfaceExample &#123; void func1(); default void func2()&#123; System.out.println("func2"); &#125; int x = 123; // int y; // Variable 'y' might not have been initialized public int z = 0; // Modifier 'public' is redundant for interface fields // private int k = 0; // Modifier 'private' not allowed here // protected int l = 0; // Modifier 'protected' not allowed here // private void fun3(); // Modifier 'private' not allowed here&#125; 3. 比较 从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 4. 使用选择使用接口： 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Comparable 接口中的 compareTo() 方法； 需要使用多重继承。 使用抽象类： 需要在几个相关的类中共享代码。 需要能控制继承来的成员的访问权限，而不是都为 public。 需要继承非静态和非常量字段。 在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。 重写与重载1. 重写（Override）存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。 为了满足里式替换原则，重写有以下三个限制： 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型。 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。 2. 重载（Overload）存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。 应该注意的是，返回值不同，其它都相同不算是重载。 五. 反射每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。 类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName(“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。 反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。 Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类： Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段； Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法； Constructor ：可以用 Constructor 的 newInstance() 创建新的对象。 反射的优点： 可扩展性 ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。 类浏览器和可视化开发环境 ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。 调试器和测试工具 ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。 反射的缺点： 性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。 安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。 内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。 https://blog.csdn.net/Sun_Army/article/details/84556081 六.小问题1. 泛型1）Java中的泛型是什么 ? 使用泛型的好处是什么? 泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中， 若没有泛型，在集合中存储对象并在使用前进行类型转换是不方便的。泛型防止了这种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。 Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 2） Java的泛型是如何工作的 ? 什么是类型擦除 ? Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的List和List等类型，在编译之后都会变成List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。 3） 什么是泛型中的限定通配符和非限定通配符 ?这是另一个非常流行的Java泛型面试题。限定通配符对类型进行了限制。有两种限定通配符： &lt;? extends T&gt;它通过确保类型必须是T的子类来设定类型的上界 &lt;? super T&gt;它通过确保类型必须是T的父类来设定类型的下界。 泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面&lt;?&gt;表示了非限定通配符，因为&lt;?&gt;可以用任意类型来替代。 4）List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?这和上一个面试题有联系，有时面试官会用这个问题来评估你对泛型的理解，而不是直接问你什么是限定通配符和非限定通配符。这两个List的声明都是限定通配符的例子，List&lt;? extends T&gt;可以接受任何继承自T的类型的List，而List&lt;? super T&gt;可以接受任何T的父类构成的List。例如List&lt;? extends Number&gt;可以接受List或List。 2. Java 与 C++ 的区别 Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。 Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。 Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。 Java 支持自动垃圾回收，而 C++ 需要手动回收。 Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。 Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。 Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。 3. JRE or JDK JRE：Java Runtime Environment，Java 运行环境的简称，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。 JDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac等。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识总结]]></title>
    <url>%2F2020%2F07%2F26%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[博客：cnblogs.com/inception6-lxc/p/9152691.html 并行和并发有什么区别 并行：多个处理器或多核处理器同时处理在同一时刻 多个任务。 并发：同一时间段内多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。 #进程和线程 进程进程是资源调度和分配的基本单位，是正运行的程序。 线程线程是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位，是进程中的一个执行单元。 进程和线程的区别和联系 一个进程中可以有多个线程，它们共享进程资源。 QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。 拥有资源 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 调度 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 系统开销 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 通信方面 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。 计算机网络体系结构 网络层IP 地址编址方式IP 地址的编址方式经历了三个历史阶段： 分类 子网划分 无分类 1. IP地址分类IP地址由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 2. 子网划分通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。 注意，外部网络看不到子网的存在。 子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。 3. 无分类无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。 IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。 CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 4. 与 IP 协议配套使用的还有三个协议：地址解析协议 ARP（Address Resolution Protocol）网际控制报文协议 ICMP（Internet Control Message Protocol）网际组管理协议 IGMP（Internet Group Management Protocol） 5. ARP网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。 APR协议工作原理： 首先，每台主机都会在自己的ARP缓冲区中建立一个 ARP列表，以表示IP地址和MAC地址的对应关系。 当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。 网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址； 源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 传输层传输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。 1. UDP 和 TCP 的特点UDP 的主要特点 UDP 是无连接的； UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）； UDP 是面向报文的； UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）； UDP 支持一对一、一对多、多对一和多对多的交互通信； UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。 TCP 的主要特点 TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）； TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达； 有流量控制和拥塞控制 每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）； TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据； 面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。 UDP首部格式 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 TCP首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 UDP 和 TCP 的区别 UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等 TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。 2. TCP 的三次握手 假设 A 为客户端，B 为服务器端。 首先服务器 B 处于 LISTEN（监听）状态，等待客户的连接请求。 客户端 A 向 服务器 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 三次握手的原因第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 如果已经建立了连接，但是客户端突然出现故障了怎么办？TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 3. TCP的四次握手 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。 A 发送连接释放报文，FIN=1。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 B 收到 A 的确认后释放连接。 四次挥手的原因客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 TIME_WAIT客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。 4. TCP 协议如何保证可靠传输 应用数据被分割成 TCP 认为最适合发送的数据块 通过序列号和确认应答信号提高可靠性 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 超时重传：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制） 拥塞控制： 当网络拥塞时，减少数据的发送。 TCP 滑动窗口窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 TCP流量控制流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 拥塞控制如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。 TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 为了便于讨论，做如下假设： 接收方有足够大的接收缓存，因此不会发生流量控制；虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 1). 慢开始与拥塞避免发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 2).快重传与快恢复在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。 应用层域名系统 DNSDNS 是一个分布式数据库，提供了域名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。 因特网上的节点都可以用IP地址惟一标识，并且可以通过IP地址被访问，但即使是将32位的二进制IP地址写成4个0～255的十位数形式，也依然太长、太难记。因此，人们发明了域名(Domian Name)，域名可将一个IP地址关联到一组有意义的字符上去。用户访问一个网站的时候，既可以输入该网站的IP地址，也可以输入其域名，对访问而言，两者是等价的。例如：微软公司的Web服务器的IP地址是207.46.230.229，其对应的域名是www.microsoft.com，不管用户在浏览器中输入的是207.46.230.229还是www.microsoft.com，都可以访问其Web网站。 域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。 DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输： 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。 文件传送协议 FTPFTP 使用 TCP 进行连接，它需要两个连接来传送一个文件： 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。 数据连接：用来传送一个文件数据。 动态主机配置协议DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。 DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。 DHCP 工作过程如下： 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。 DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。 电子邮件协议一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。 邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 SMTPSMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。 POP3POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。 IMAPIMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 常用端口协议常用的端口： 在浏览器中输入www.baidu.com后执行的全部过程 浏览器获取输入的域名www.baidu.com 浏览器向域名系统DNS请求解析www.baidu.com的IP地址 DNS解析出百度服务器的IP地址 浏览器与服务器建立TCP连接（默认端口80） 浏览器发出HTTP请求，请求百度首页 服务器通过HTTP请求把首页文件发给浏览器 TCP连接释放 浏览器解析首页文件，展示web界面 Web 页面请求过程（重要）1、应用层：客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。浏览器与服务器建立TCP连接。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。 DNS解析 HTTP请求和响应 2、传输层：在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层（网络层）的IP地址查找目的端。 3、网络层：客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 4、链路层：客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。 HTTP一、基本概念URI URL由三部分组成：资源类型、存放资源的主机域名、资源文件名。也可认为由4部分组成：协议、主机、端口、路径 请求和响应报文1.请求报文请求行、请求头、请求体 2.响应报文状态行、响应头、响应体 二、HTTP 方法客户端发送的 请求报文 第一行为请求行，包含了方法字段。 GET 获取资源 当前网络请求中，绝大部分使用的是 GET 方法。 HEAD 获取报文首部 和 GET 方法类似，但是不返回报文实体主体部分。 主要用于确认 URL 的有效性以及资源更新的日期时间等。 POST 传输实体主体 POST 主要用来传输数据，而 GET 主要用来获取资源。 PUT 上传文件 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。 PUT /new.html HTTP/1.1 Host: example.com Content-type: text/html Content-length: 16 &lt;p&gt;New File&lt;/p&gt; PATCH 对资源进行部分修改 PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。 PATCH /file.txt HTTP/1.1 Host: www.example.com Content-Type: application/example If-Match: &quot;e0023aa4e&quot; Content-Length: 100 [description of changes] DELETE 删除文件 与 PUT 功能相反，并且同样不带验证机制。 DELETE /file.html HTTP/1.1 OPTIONS 查询支持的方法 查询指定的 URL 能够支持的方法。 会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。 三、GET 和 POST 比较1. 作用 GET 用于获取资源 POST用于传输实体主体。 2. 参数GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。 因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参数支持标准字符集。 GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1 POST /test/demo_form.asp HTTP/1.1 Host: w3schools.com name1=value1&amp;name2=value2 3. 参数长度get参数有长度限制（受限于url长度），而post无限制 3. 安全安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。 GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。 安全的方法除了 GET 之外还有：HEAD、OPTIONS。 不安全的方法除了 POST 之外还有 PUT、DELETE。 4. 幂等性幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。 所有的安全方法也都是幂等的。 在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。 GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的： GET /pageX HTTP/1.1 GET /pageX HTTP/1.1 GET /pageX HTTP/1.1 GET /pageX HTTP/1.1 POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录： POST /add_row HTTP/1.1 -&gt; Adds a 1nd row POST /add_row HTTP/1.1 -&gt; Adds a 2nd row POST /add_row HTTP/1.1 -&gt; Adds a 3rd row DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样： DELETE /idX/delete HTTP/1.1 -&gt; Returns 200 if idX exists DELETE /idX/delete HTTP/1.1 -&gt; Returns 404 as it just got deleted DELETE /idX/delete HTTP/1.1 -&gt; Returns 404 5. 可缓存如果要对响应进行缓存，需要满足以下条件： 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。 响应报文的 Cache-Control 首部字段没有指定不进行缓存。 6. XMLHttpRequest为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest： XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。而 GET 方法 Header 和 Data 会一起发送。 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 四、HTTP 状态码服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 1XX 信息 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。 2XX 成功 200 OK 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。 3XX 重定向 301 Moved Permanently ：永久性重定向 302 Found ：临时性重定向 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。 4XX 客户端错误 400 Bad Request ：请求报文中存在语法错误。 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。 403 Forbidden ：请求被拒绝。 404 Not Found 5XX 服务器错误 500 Internal Server Error ：服务器正在执行请求时发生错误。 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 五、应用1、长连接和短连接当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。 长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close； 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。 2. Cookie和Session1）CookieHTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。 Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。 Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。 用途： 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） 2）Session除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。 Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。 区别： cookie数据存放在客户的浏览器上，session数据放在服务器上。 cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。 将登陆信息等重要信息存放为session其他信息如果需要保留，可以放在cookie中 六、 HTTPSHTTP 有以下安全性问题： 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。 HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。 通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。 HTTPS的加密方式对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案： 使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key） HTTPS的认证通过使用 证书 来对通信方进行认证。 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。 服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。 进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。 HTTP和HTTPs区别： http是超文本传输协议，信息是明文传输。https则是具有安全性的ssl加密传输协议 https有ca证书，http一般没有 http端口号为80，https端口号为443 https基于传输层、http基于应用层]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb-Mybatis框架(2)]]></title>
    <url>%2F2020%2F07%2F25%2FJavaWeb-Mybatis%E6%A1%86%E6%9E%B6-2%2F</url>
    <content type="text"><![CDATA[Mybatis对数据库的单表CUDA操作1. 配置Mybatis的主配置文件SqlMapConfig，配置数据库的基本信息以及操作的映射配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;!-- mybatis的主配置文件 --&gt; &lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;!-- 配置mysql的环境--&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;!-- 配置事务的类型--&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db_mybatis?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;bjtu/dao/UserDao.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 2. 实现User类，定义类属性，和数据库表user中的列值对应 3. 实现操作接口UserDao，定义每个操作数据库的方法 public interface UserDao { /* 查询所有操作 */ //@Select(&quot;select * from user&quot;) List&lt;user&gt; findAll(); /** * 保存user * @param u */ void saveUser(user u); /** * 更新信息 * @param u */ void updateUser(user u); /** * 删除用户 * @param userID */ void deleteUser(Integer userID); /** * 按ID查询用户信息 * @param userID */ user findById(Integer userID); /** * 按名称模糊查询用户信息 */ List&lt;user&gt; findByName(String username); /** * 聚合函数：查询总记录条数 */ int findTotal(); } 4. 将UserDao中的每个方法在映射配置文件UserDao.xml中进行配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;bjtu.dao.UserDao&quot;&gt; &lt;!--配置查询结果的列名与实体类的属性名的对应关系--&gt; &lt;resultMap id=&quot;userMap&quot; type=&quot;bjtu.domain.user&quot;&gt; &lt;!-- 主键字段的对应--&gt; &lt;id property=&quot;userId&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;!-- 非主键字段的对应--&gt; &lt;result property=&quot;userName&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userBirthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userSex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userAddress&quot; column=&quot;address&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--配置查询所有--&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt; select * from user &lt;/select&gt; &lt;!--插入保存用户--&gt; &lt;insert id=&quot;saveUser&quot; parameterType=&quot;bjtu.domain.user&quot;&gt; &lt;!--配置插入数据后，获取新增数据的id--&gt; &lt;selectKey keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt; select last_insert_id() &lt;/selectKey&gt; insert into user(username,address,sex,birthday) values(#{username},#{address},#{sex},#{birthday}) &lt;/insert&gt; &lt;!--更新用户信息--&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;bjtu.domain.user&quot;&gt; update user set username=#{username},address=#{address},sex=#{sex},birthday=#{birthday} where id=#{id} &lt;/update&gt; &lt;!--删除用户--&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from user where id=#{uid} &lt;/delete&gt; &lt;!--按ID查询一个用户的信息--&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultMap=&quot;userMap&quot;&gt; select * from user where id=#{uid} &lt;/select&gt; &lt;!--按名称模糊查询用户信息--&gt; &lt;select id=&quot;findByName&quot; parameterType=&quot;string&quot; resultMap=&quot;userMap&quot;&gt; select * from user where username like #{name} &lt;/select&gt; &lt;!--利用聚合函数查询总记录条数--&gt; &lt;select id=&quot;findTotal&quot; resultType=&quot;int&quot;&gt; select count(id) from user &lt;/select&gt; &lt;/mapper&gt; 其中 resultMap 是用来将User类中的属性名和mysql中user表中的类名对应： &lt;resultMap id=&quot;userMap&quot; type=&quot;bjtu.domain.user&quot;&gt; &lt;!-- 主键字段的对应--&gt; &lt;id property=&quot;userId&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;!-- 非主键字段的对应--&gt; &lt;result property=&quot;userName&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userBirthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userSex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userAddress&quot; column=&quot;address&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; 5. 在test目录下写测试程序 MybatisTest.java public class MybatisTest { private InputStream in; private SqlSession sqlSession; private UserDao userDao; @Before public void init() throws Exception{ //1. 读取配置文件 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //2. 获取SqlFactorySession SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3. 获取SqlSession对象 sqlSession = factory.openSession(); //4. 获取dao的代理对象 userDao = sqlSession.getMapper(UserDao.class); } @After public void destory() throws Exception{ sqlSession.commit(); //释放资源 sqlSession.close(); in.close(); } /* 测试查询所有数据功能 */ @Test public void testFindAll() throws Exception{ List&lt;user&gt; users = userDao.findAll(); for(user u: users){ System.out.println(u); } } /* 测试保存功能 */ @Test public void testSave() throws Exception{ user u = new user(); u.setUserName(&quot;李明&quot;); u.setUserAddress(&quot;北京海淀&quot;); u.setUserSex(&quot;男&quot;); u.setUserBirthday(new Date()); System.out.println(&quot;Before saving:&quot;+u); userDao.saveUser(u); System.out.println(&quot;After saving:&quot;+u); } /** * 测试更新信息功能 */ @Test public void testUpdate(){ user u = new user(); u.setUserId(49); u.setUserName(&quot;Mybatis&quot;); u.setUserAddress(&quot;bjtu&quot;); u.setUserSex(&quot;m&quot;); u.setUserBirthday(new Date()); userDao.updateUser(u); } /** * 测试删除功能 */ @Test public void testDelete(){ userDao.deleteUser(57); } /** * 按ID查询一个用户的信息 */ @Test public void testFindOne(){ user u = userDao.findById(48); System.out.println(u); } /** * 按名称模糊查询用户的信息 */ @Test public void testFindByName(){ List&lt;user&gt; users = userDao.findByName(&quot;%王%&quot;); for(user u: users){ System.out.println(u); } } /** * 利用聚合函数查询总记录的条数 */ @Test public void testFindTotal(){ int s = userDao.findTotal(); System.out.println(&quot;总记录条数:&quot;+s); } } Mybatis连接池和事务 事务 在Mybatis的SqlMapConfig.xml配置文件中，通过来实现Mybatis中连接池的配置。 type属性的三种取值： UNPOOLED 不使用连接池的数据源 POOLED 使用连接池的数据源 JNDI 使用JNDI实现的数据源 MyBatis内部分别定义了实现了java.sql.DataSource接口的UnpooledDataSource，PooledDataSource类来表示UNPOOLED、POOLED类型的数据源。 事务 什么是事务？ 事务的四大特性：ACID 不考虑隔离就产生的三个问题 解决方法：四种隔离级别 Mybatis多表查询1. 数据库创建表在数据库中创建user、account和role两个表，并设置外键关联。 1）创建user表 DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` int(11) NOT NULL auto_increment, `username` varchar(32) NOT NULL COMMENT &apos;用户名称&apos;, `birthday` datetime default NULL COMMENT &apos;生日&apos;, `sex` char(1) default NULL COMMENT &apos;性别&apos;, `address` varchar(256) default NULL COMMENT &apos;地址&apos;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; insert into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (41,&apos;老王&apos;,&apos;2018-02-27 17:47:08&apos;,&apos;男&apos;,&apos;北京&apos;),(42,&apos;小二王&apos;,&apos;2018-03-02 15:09:37&apos;,&apos;女&apos;,&apos;北京金燕龙&apos;),(43,&apos;小二王&apos;,&apos;2018-03-04 11:34:34&apos;,&apos;女&apos;,&apos;北京金燕龙&apos;),(45,&apos;传智播客&apos;,&apos;2018-03-04 12:04:06&apos;,&apos;男&apos;,&apos;北京金燕龙&apos;),(46,&apos;老王&apos;,&apos;2018-03-07 17:37:26&apos;,&apos;男&apos;,&apos;北京&apos;),(48,&apos;小马宝莉&apos;,&apos;2018-03-08 11:44:00&apos;,&apos;女&apos;,&apos;北京修正&apos;); 2） 创建account表 DROP TABLE IF EXISTS `account`; CREATE TABLE `account` ( `ID` int(11) NOT NULL COMMENT &apos;编号&apos;, `UID` int(11) default NULL COMMENT &apos;用户编号&apos;, `MONEY` double default NULL COMMENT &apos;金额&apos;, PRIMARY KEY (`ID`), KEY `FK_Reference_8` (`UID`), CONSTRAINT `FK_Reference_8` FOREIGN KEY (`UID`) REFERENCES `user` (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; insert into `account`(`ID`,`UID`,`MONEY`) values (1,46,1000),(2,45,1000),(3,46,2000); 3）创建role表 DROP TABLE IF EXISTS `role`; CREATE TABLE `role` ( `ID` int(11) NOT NULL COMMENT &apos;编号&apos;, `ROLE_NAME` varchar(30) default NULL COMMENT &apos;角色名称&apos;, `ROLE_DESC` varchar(60) default NULL COMMENT &apos;角色描述&apos;, PRIMARY KEY (`ID`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; insert into `role`(`ID`,`ROLE_NAME`,`ROLE_DESC`) values (1,&apos;院长&apos;,&apos;管理整个学院&apos;),(2,&apos;总裁&apos;,&apos;管理整个公司&apos;),(3,&apos;校长&apos;,&apos;管理整个学校&apos;); DROP TABLE IF EXISTS `user_role`; CREATE TABLE `user_role` ( `UID` int(11) NOT NULL COMMENT &apos;用户编号&apos;, `RID` int(11) NOT NULL COMMENT &apos;角色编号&apos;, PRIMARY KEY (`UID`,`RID`), KEY `FK_Reference_10` (`RID`), CONSTRAINT `FK_Reference_10` FOREIGN KEY (`RID`) REFERENCES `role` (`ID`), CONSTRAINT `FK_Reference_9` FOREIGN KEY (`UID`) REFERENCES `user` (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; insert into `user_role`(`UID`,`RID`) values (41,1),(45,1),(41,2);DROP TABLE IF EXISTS `role`; 2. 一对一和一对多查询本次案例主要以最为简单的用户和账户的模型来分析Mybatis 多表关系。 用户为User 表，账户为Account表。一个用户（User）可以有多个账户（Account）。 准备： 1. 建立两张表：用户表（User）和账户表（Account） 让用户和账户表之间具有一对多的关系，需要外键在账户表中添加 2. 简历两个实体类：用户实体类和账户实体类 让用户和账户实体类中体现一对多的关系 3. 建立两个配置文件： 用户配置文件 账户配置文件 4. 实现配置 当查询用户时，可以同时得到用户下所包含的账户信息 当查询账户时，可以同时得到账户所属的用户信息 账户一对一对应用户，AccountDao.xml查询配置文件 用户一对多用户1）首先要在User类中增加user与account一对多关系，即一个用户下有多个accounts，用集合封装。2）其次修改UserDao.xml查询配置文件 3. 多对多查询 示例描述 示例：用户和角色 一个用户可以有多个角色 一个角色可以赋予多个用户 步骤： 1、建立两张表：用户表，角色表 让用户表和角色表具有多对多的关系。需要使用中间表，中间表中包含各自的主键，在中间表中是外键。 2、建立两个实体类：用户实体类和角色实体类 让用户和角色的实体类能体现出来多对多的关系 各自包含对方一个集合引用 3、建立两个配置文件 用户的配置文件 角色的配置文件 4、实现配置： 当我们查询用户时，可以同时得到用户所包含的角色信息 当我们查询角色时，可以同时得到角色的所赋予的用户信息 这个多对多的搜索主要是修改SQL语句，映射文件.xml的配置和一对多查询操作类似 * UserDao.xml配置文件，RoleDao.xml文件配置类似 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;bjtu.dao.RoleDao&quot;&gt; &lt;!--定义User的resultMap--&gt; &lt;resultMap id=&quot;roleMap&quot; type=&quot;bjtu.domain.Role&quot;&gt; &lt;id property=&quot;roleId&quot; column=&quot;rid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;roleDesc&quot; column=&quot;role_desc&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;users&quot; ofType=&quot;bjtu.domain.User&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--配置查询所有--&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;roleMap&quot;&gt; select u.*, r.id as rid, r.role_name, r.role_desc from role r left outer join user_role ur on r.id = ur.rid left outer join user u on u.id = ur.uid &lt;/select&gt; &lt;/mapper&gt; Mybatis的缓存 Mybatis中的延迟加载 问题：在一对多中，当我们有一个用户，它有100个账户。 在查询用户的时候，要不要把关联的账户查出来？ 在查询账户的时候，要不要把关联的用户查出来？ 在查询用户时，用户下的账户信息应该是，什么时候使用，什么时候查询的。 在查询账户时，账户的所属用户信息应该是随着账户查询时一起查询出来。 什么是延迟加载? 在真正使用数据时才发起查询，不用的时候不查询。按需加载（懒加载） 什么是立即加载? 不管用不用，只要一调用方法，马上发起查询。 在对应的四种表关系中：一对多，多对一，一对一，多对多。 一对多，多对多：通常情况下我们都是采用延迟加载； 多对一，一对一：通常情况下我们都是采用立即加载。 Mybatis中的缓存 什么是缓存 存在于内存中的临时数据。 为什么使用缓存 减少和数据库的交互次数，提高执行效率。 什么样的数据能使用缓存，什么样的数据不能使用 适用于缓存： 经常查询并且不经常改变的。 数据的正确与否对最终结果影响不大的。 不适用于缓存： 经常改变的数据 数据的正确与否对最终结果影响很大的。 例如：商品的库存，银行的汇率，股市的牌价。 Mybatis中的一级缓存和二级缓存 一级缓存： * 它指的是Mybatis中SqlSession对象的缓存。 * 当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供一块区域中。该区域的结构是一个Map。当我们再次查询同样的数据，mybatis会先去sqlsession中查询是否有，有的话直接拿出来用。 * 当SqlSession对象消失时，mybatis的一级缓存也就消失了。 * 如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 二级缓存: * 它指的是Mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。 * 二级缓存的使用步骤： * 第一步：让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置） * 第二步：让当前的映射文件支持二级缓存（在IUserDao.xml中配置） * 第三步：让当前的操作支持二级缓存（在select标签中配置） Mybatis中的注解开发这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper(即UserDap.xml、AccountDao.xml等配置文件)映射文件了。在Mybatis中只能使用映射配置文件和注解配置一种方式，所以使用注解配置时，应将映射配置文件移除。 1. 单表的CUDA操作首先针对单表的CUDA操作，只需要在UserDao接口文件的相关方法上添加配置即可。Mybatis中有四种SQL相关的语句配置： @Insert: 实现新增 @Update: 实现更新 @Delete: 实现删除 @Select: 实现查询 以User类的接口UserDao为例，程序改写如下： public interface UserDao { /* 查询所有用户，同时获取用户下所有的账户信息 */ @Select(&quot;select * from user&quot;) @Results(id = &quot;userMap&quot;, value={ @Result(id = true, column = &quot;id&quot;, property = &quot;id&quot;), @Result(column = &quot;username&quot;, property = &quot;username&quot;), @Result(column = &quot;address&quot;, property = &quot;address&quot;), @Result(column = &quot;sex&quot;, property = &quot;sex&quot;), @Result(column = &quot;birthday&quot;, property = &quot;birthday&quot;), }) List&lt;User&gt; findAll(); /** * 按ID查询用户信息 * @param userID */ @Select(&quot;select * from user where id = #{uid}&quot;) @ResultMap(value = {&quot;userMap&quot;}) User findById(Integer userID); /** * 插入保存user * @param u */ @Insert(&quot;insert into user(username,address,sex,birthday) values(#{username},#{address},#{sex},#{birthday})&quot;) @ResultMap(value = {&quot;userMap&quot;}) void saveUser(User u); /** * 更新信息 * @param u */ @Update(&quot;update user set username=#{username},address=#{address},sex=#{sex},birthday=#{birthday} where id=#{id}&quot;) @ResultMap(value = {&quot;userMap&quot;}) void updateUser(User u); /** * 删除用户 * @param userID */ @Delete(&quot;delete from user where id = #{id}&quot;) @ResultMap(value = {&quot;userMap&quot;}) void deleteUser(Integer userID); /** * 按名称模糊查询用户信息 */ @Select(&quot;select * from user where username like #{username}&quot; ) @ResultMap(value = {&quot;userMap&quot;}) //@Select(&quot;select * from user where username like &apos;%${value}%&apos;&quot; ) List&lt;User&gt; findByName(String username); /** * 聚合函数：查询总记录条数 */ @Select(&quot;select count(id) from user&quot;) @ResultMap(value = {&quot;userMap&quot;}) int findTotal(); } 只需要在方法之上添加 @Select(“SQL语句”)，@Insert(“SQL语句”)，@Update(“SQL语句”)，@Delect(“SQL语句”)。 另外，若User类中的属性与数据库中user表的列名不一致，需要增加 @Results() 注解配置，类似于UserDao.xml中的配置。 2. 多表操作配置 一对一配置 一对多配置]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb-Mybatis框架(1)]]></title>
    <url>%2F2020%2F07%2F18%2FJavaWeb-Mybatis%E6%A1%86%E6%9E%B6-1%2F</url>
    <content type="text"><![CDATA[MVC模式 Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。 通常模型对象负责在数据库中存取数据。 View（视图）是应用程序中处理数据显示的部分。 通常视图是依据模型数据创建的。 Controller（控制器）是应用程序中处理用户交互的部分。 通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。 三层架构概述： 表现层UL：主要是指与用户交互的界面。用于接收用户输入的数据和显示处理后用户需要的数据。 业务层BLL：UI层和DAL层之间的桥梁。实现业务逻辑，处理业务需求。 持久层DAL：与数据库交互，主要实现对数据的增、删、改、查。（mybatis） MyBatis框架概述 mybatis是一个基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。 采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。 Mybatis简单入门搭建Mybatis开发环境： 1.创建Maven工程并在pom.xml文件中添加Mybatis的坐标 2.创建实体类和dao接口 首先在数据库中创建爱你user表，信息如下： 创建User类和UserDao(也可叫UserMapper)接口 // User类 public class user implements Serializable { private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return &quot;user{&quot; + &quot;id=&quot; + id + &quot;, username=&apos;&quot; + username + &apos;\&apos;&apos; + &quot;, birthday=&quot; + birthday + &quot;, sex=&apos;&quot; + sex + &apos;\&apos;&apos; + &quot;, address=&apos;&quot; + address + &apos;\&apos;&apos; + &apos;}&apos;; } } // UserDao 接口 public interface UserDao { /* 查询所有操作 */ List&lt;user&gt; findAll(); } 3.创建Mybatis的主配置文件：SqlMapconfig.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;!-- mybatis的主配置文件 --&gt; &lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;!-- 配置mysql的环境--&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;!-- 配置事务的类型--&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db_mybatis&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;bjtu/dao/UserDao.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 4.创建映射配置文件：UserDao.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;bjtu.dao.UserDao&quot;&gt; &lt;!--配置查询所有--&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;bjtu.domain.User&quot;&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; 注：1）Mybatis的映射配置文件结构必须和dao接口的文件结构相同；2）映射配置文件的mapper标签namespace必须是dao接口的全限定类名；3）映射配置文件的操作配置，id属性的取值必须是dao接口的方法名；满足以上几个配置，在开发中无需再写dao的实现类。 5.创建测试代码 public class MybatisTest { public static void main(String[] args) throws IOException { //1.读取配置文件 InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); //3.使用工厂生产SqlSession对象 SqlSession session = factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 UserDao userDao = session.getMapper(UserDao.class); //5.使用代理对象执行方法 List&lt;user&gt; users = userDao.findAll(); for(user u : users){ System.out.println(u); } //6.释放资源 session.close(); in.close(); } } 使用配置注解的方式 删除UserDao.xml文件，在UserDao接口文件的方法上添加 @Select(“SQL语句”) // UserDao 接口 public interface UserDao { /* 查询所有操作 */ @Select(&quot;select * from user&quot;) List&lt;user&gt; findAll(); } 并改变SqlMapconfig.xml中 mappers配置 &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;!--&lt;mappers&gt;--&gt; &lt;!--&lt;mapper resource=&quot;bjtu/dao/UserDao.xml&quot;/&gt;--&gt; &lt;!--&lt;/mappers&gt;--&gt; &lt;!--如果使用注解的方式配置，此处应使用class属性指定被注解的dao的全限定类名--&gt; &lt;mappers&gt; &lt;mapper class=&quot;bjtu.dao.UserDao&quot;/&gt; &lt;/mappers&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis知识概述]]></title>
    <url>%2F2020%2F07%2F16%2FRedis%E7%9F%A5%E8%AF%86%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Redis 概念： redis是一款高性能的NOSQL系列的非关系型数据库 1.1.什么是NOSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1.NOSQL和关系型数据库比较 优点： 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 3）不提供关系型数据库对事务的处理。 1.1.2.非关系型数据库的优势： 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 1.1.3.关系型数据库的优势： 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 1.1.4.总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 1.2.主流的NOSQL产品 • 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 • 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 • 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 • 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 1.3 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset 1.3.1 redis的应用场景 • 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒 • 分布式集群架构中的session分离 下载安装 1). 官网：https://redis.io 2). 中文网：http://www.redis.net.cn/ 3). 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端 命令操作 1). redis的数据结构： - redis存储的是：key,value格式的数据，其中**key都是字符串，value有5种不同的数据结构** - value的数据结构： * 字符串类型 string * 哈希类型 hash ： map格式 * 列表类型 list ： linkedlist格式。支持重复元素 * 集合类型 set ： 不允许重复元素 * 有序集合类型 sortedset：不允许重复元素，且元素有顺序 2). 字符串类型 string 1. 存储： set key value 127.0.0.1:6379&gt; set username zhangsan OK 2. 获取： get key 127.0.0.1:6379&gt; get username &quot;zhangsan&quot; 3. 删除： del key 127.0.0.1:6379&gt; del age (integer) 1 3). 哈希类型 hash 1. 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 2. 获取： * hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; * hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; 3. 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 4). 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： - lpush key value: 将元素加入列表左表 - rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： * lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： * lpop key： 删除列表最左边的元素，并将元素返回 * rpop key： 删除列表最右边的元素，并将元素返回 5). 集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 1 6). 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 1. 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500&quot; 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 7). 通用命令 - keys * : 查询所有的键 - type key ： 获取键对应的value的类型 - del key：删除指定的key value Redis持久化 redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 redis持久化机制： 1) RDB：默认方式，不需要进行配置，默认就使用这种机制 * 在一定的间隔时间中，检测key的变化情况，然后持久化数据 - 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 - 重新启动redis服务器，并指定配置文件名称 D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf 2) AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 - 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化 Java客户端 Jedis Jedis: 一款java操作redis数据库的工具. 使用步骤： 1). 下载jedis的jar包 2). 使用 //1. 获取连接 Jedis jedis = new Jedis(&quot;localhost&quot;,6379); //2. 操作 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //3. 关闭连接 jedis.close(); * Jedis操作各种redis中的数据结构 1) 字符串类型 string set get //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 //存储 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //获取 String username = jedis.get(&quot;username&quot;); System.out.println(username); //可以使用setex()方法存储可以指定过期时间的 key value jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对 //3. 关闭连接 jedis.close(); 2) 哈希类型 hash ： map格式 hset hget hgetAll //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // 存储hash jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;); jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;); jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;); // 获取hash String name = jedis.hget(&quot;user&quot;, &quot;name&quot;); System.out.println(name); // 获取hash的所有map中的数据 Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;); // keyset Set&lt;String&gt; keySet = user.keySet(); for (String key : keySet) { //获取value String value = user.get(key); System.out.println(key + &quot;:&quot; + value); } //3. 关闭连接 jedis.close(); 3) 列表类型 list ： linkedlist格式。支持重复元素 lpush / rpush lpop / rpop lrange start end : 范围获取 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // list 存储 jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存 jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存 // list 范围获取 List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop(&quot;mylist&quot;);//c System.out.println(element1); String element2 = jedis.rpop(&quot;mylist&quot;);//c System.out.println(element2); // list 范围获取 List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 4) 集合类型 set ： 不允许重复元素 sadd smembers:获取所有元素 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // set 存储 jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;); // set 获取 Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;); System.out.println(myset); //3. 关闭连接 jedis.close(); 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 zadd zrange //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // sortedset 存储 jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;); jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;); jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;); // sortedset 获取 Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1); System.out.println(mysortedset); //3. 关闭连接 jedis.close(); * jedis连接池： JedisPool * 使用： 1. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(&quot;hehe&quot;,&quot;heihei&quot;); //4. 关闭 归还到连接池中 jedis.close(); * 连接池工具类 public class JedisPoolUtils { private static JedisPool jedisPool; static{ //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); //创建Properties对象 Properties pro = new Properties(); //关联文件 try { pro.load(is); } catch (IOException e) { e.printStackTrace(); } //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); } /** * 获取连接方法 */ public static Jedis getJedis(){ return jedisPool.getResource(); } } 案例：案例需求： 1. 提供index.html页面，页面中有一个省份 下拉列表 2. 当 页面加载完成后 发送ajax请求，加载所有省份 注意：使用redis缓存一些不经常发生变化的数据。 数据库的数据一旦发生改变，则需要更新缓存。 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入 在service对应的增删改方法中，将redis数据删除。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb-Cookie & Session]]></title>
    <url>%2F2020%2F07%2F15%2FJavaWeb-Cookie-Session%2F</url>
    <content type="text"><![CDATA[会话技术 会话：一次会话中包含多次请求和响应。 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围内的多次请求间，共享数据 方式： 1). 客户端会话技术：Cookie 2). 服务器端会话技术：Session Cookie： 概念：客户端会话技术，将数据保存到客户端 快速入门： 1). 创建Cookie对象，绑定数据 * new Cookie(String name, String value) 2). 发送Cookie对象 * response.addCookie(Cookie cookie) 3). 获取Cookie，拿到数据 * Cookie[] request.getCookies() 实现原理: 基于响应头set-cookie和请求头cookie实现 cookie的细节 1). 一次可不可以发送多个cookie? * 可以 * 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 2). cookie在浏览器中保存多长时间？ 1. 默认情况下，当浏览器关闭后，Cookie数据被销毁 2. 持久化存储： * setMaxAge(int seconds) 1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 2. 负数：默认值 3. 零：删除cookie信息 3). cookie能不能存中文？ * 在tomcat 8 之前 cookie中不能直接存储中文数据。 * 需要将中文数据转码---一般采用URL编码(%E3) * 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 4). cookie共享问题？ 1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ * 默认情况下cookie不能共享 * setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录 * 如果要共享，则可以将path设置为&quot;/&quot; 2. 不同的tomcat服务器间cookie共享问题？ * setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 * setDomain(&quot;.baidu.com&quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享 Cookie的特点和作用 1). cookie存储数据在客户端浏览器 2). 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) * 作用： 1). cookie一般用于存出少量的不太敏感的数据 2). 在不登录的情况下，完成服务器对客户端的身份识别 案例：记住上一次访问时间 1. 需求： 1. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。 2. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串 2. 分析： 1. 可以采用Cookie来完成 2. 在服务器中的Servlet判断是否有一个名为lastTime的cookie 1. 有：不是第一次访问 1. 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20 2. 写回Cookie：lastTime=2018年6月10日11:50:01 2. 没有：是第一次访问 1. 响应数据：您好，欢迎您首次访问 2. 写回Cookie：lastTime=2018年6月10日11:50:01 3. 代码实现： package cn.itcast.cookie; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.net.URLDecoder; import java.net.URLEncoder; import java.text.SimpleDateFormat; import java.util.Date; @WebServlet(&quot;/cookieTest&quot;) public class CookieTest extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //设置响应的消息体的数据格式以及编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //1.获取所有Cookie Cookie[] cookies = request.getCookies(); boolean flag = false;//没有cookie为lastTime //2.遍历cookie数组 if(cookies != null &amp;&amp; cookies.length &gt; 0){ for (Cookie cookie : cookies) { //3.获取cookie的名称 String name = cookie.getName(); //4.判断名称是否是：lastTime if(&quot;lastTime&quot;.equals(name)){ //有该Cookie，不是第一次访问 flag = true;//有lastTime的cookie //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String str_date = sdf.format(date); System.out.println(&quot;编码前：&quot;+str_date); //URL编码 str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;); System.out.println(&quot;编码后：&quot;+str_date); cookie.setValue(str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); //响应数据 //获取Cookie的value，时间 String value = cookie.getValue(); System.out.println(&quot;解码前：&quot;+value); //URL解码： value = URLDecoder.decode(value,&quot;utf-8&quot;); System.out.println(&quot;解码后：&quot;+value); response.getWriter().write(&quot;&lt;h1&gt;欢迎回来，您上次访问时间为:&quot;+value+&quot;&lt;/h1&gt;&quot;); break; } } } if(cookies == null || cookies.length == 0 || flag == false){ //没有，第一次访问 //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String str_date = sdf.format(date); System.out.println(&quot;编码前：&quot;+str_date); //URL编码 str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;); System.out.println(&quot;编码后：&quot;+str_date); Cookie cookie = new Cookie(&quot;lastTime&quot;,str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); response.getWriter().write(&quot;&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;&quot;); } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } } JSP：入门学习 概念：Java Server Pages, java服务器端页面 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 用于简化书写！！！ 原理:JSP本质上就是一个Servlet JSP的脚本：JSP定义Java代码的方式 1). &lt;% 代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。 2). &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。 3). &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。 JSP的内置对象： 在jsp页面中不需要获取和创建，可以直接使用的对象 jsp一共有9个内置对象。 今天学习3个： request response out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似 response.getWriter()和out.write()的区别： 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 response.getWriter()数据输出永远在out.write()之前 案例:改造Cookie案例 Session：主菜 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession 快速入门： 1). 获取HttpSession对象： HttpSession session = request.getSession(); 2). 使用HttpSession对象： Object getAttribute(String name) void setAttribute(String name, Object value) void removeAttribute(String name) 原理 Session的实现是依赖于Cookie的。 细节： 1). 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？ * 默认情况下。不是。 * 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 Cookie c = new Cookie(&quot;JSESSIONID&quot;,session.getId()); c.setMaxAge(60*60); response.addCookie(c); 2). 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ * 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 * session的钝化： * 在服务器正常关闭之前，将session对象系列化到硬盘上 * session的活化： * 在服务器启动后，将session文件转化为内存中的session对象即可。 3). session什么时候被销毁？ 1. 服务器关闭 2. session对象调用invalidate() 。 3. session默认失效时间 30分钟 选择性配置修改 &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; session的特点 1). session用于存储一次会话的多次请求的数据，存在服务器端 2). session可以存储任意类型，任意大小的数据 session与Cookie的区别： 1). session存储数据在服务器端，Cookie在客户端 2). session没有数据大小限制，Cookie有 3). session数据安全，Cookie相对于不安全 案例：验证码1. 案例需求： 1. 访问带有验证码的登录页面login.jsp 2. 用户输入用户名，密码以及验证码。 * 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误 * 如果验证码输入有误，跳转登录页面，提示：验证码错误 * 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您 2. 分析：]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java Web-Servlet & HTTP]]></title>
    <url>%2F2020%2F07%2F13%2FJava-Web-Servlet-HTTP%2F</url>
    <content type="text"><![CDATA[web相关概念回顾1. 软件架构 1. C/S：客户端/服务器端 2. B/S：浏览器/服务器端 2. 资源分类 1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析 * 如： html,css,JavaScript 2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器 * 如：servlet/jsp,php,asp.... 3. 网络通信三要素 1. IP：电子设备(计算机)在网络中的唯一标识。 2. 端口：应用程序在计算机中的唯一标识。 0~65536 3. 传输协议：规定了数据传输的规则 1. 基础协议： 1. tcp:安全协议，三次握手。 速度稍慢 2. udp：不安全协议。 速度快 web服务器软件：* 服务器：安装了服务器软件的计算机 * 服务器软件：接收用户的请求，处理请求，做出响应 * web服务器软件：接收用户的请求，处理请求，做出响应。 * 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目 * web容器 * 常见的java相关的web服务器软件： * webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 * webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 * JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 * Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。 * JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 * Tomcat：web服务器软件 1. 下载：http://tomcat.apache.org/ 2. 安装：解压压缩包即可。 * 注意：安装目录建议不要有中文和空格 3. 卸载：删除目录就行了 4. 启动： * bin/startup.bat ,双击运行该文件即可 * 访问：浏览器输入：http://localhost:8080 回车访问自己 http://别人的ip:8080 访问别人 * 可能遇到的问题： 1. 黑窗口一闪而过： * 原因： 没有正确配置JAVA_HOME环境变量 * 解决方案：正确配置JAVA_HOME环境变量 2. 启动报错： 1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程 * netstat -ano 2. 温柔：修改自身的端口号 * conf/server.xml * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8445&quot; /&gt; * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。 * 好处：在访问时，就不用输入端口号 5. 关闭： 1. 正常关闭： * bin/shutdown.bat * ctrl+c 2. 强制关闭： * 点击启动窗口的× 6. 配置: * 部署项目的方式： 1. 直接将项目放到webapps目录下即可。 * /hello：项目的访问路径--&gt;虚拟目录 * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。 * war包会自动解压缩 2. 配置conf/server.xml文件 在&lt;Host&gt;标签体中配置 &lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt; * docBase:项目存放的路径 * path：虚拟目录 3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写 &lt;Context docBase=&quot;D:\hello&quot; /&gt; * 虚拟目录：xml文件的名称 * 静态项目和动态项目： * 目录结构 * java动态项目的目录结构： -- 项目的根目录 -- WEB-INF目录： -- web.xml：web项目的核心配置文件 -- classes目录：放置字节码文件的目录 -- lib目录：放置依赖的jar包 * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。 Servlet： server applet* 概念：运行在服务器端的Java小程序 * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。 * 将来我们自定义一个类，实现Servlet接口，复写方法。 * 快速入门： 1. 创建JavaEE项目 2. 定义一个类，实现Servlet接口 * public class ServletDemo1 implements Servlet 3. 实现接口中的抽象方法 4. 配置Servlet 在web.xml中配置： &lt;!--配置Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; * 执行原理： 1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径； 2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容； 3. 如果有，则在找到对应的&lt;servlet-class&gt;全类名； 4. tomcat会将字节码文件加载进内存，并且创建其对象； 5. 调用其方法。 public class tomcat_demo1 implements Servlet{ /** * 在Servlet被创建时执行，只会执行一次。 * @param servletConfig * @throws ServletException */ @Override public void init(ServletConfig servletConfig) throws ServletException { } /** * 获取ServletConfig对象 * ServletConfig: Servlet的配置对象 * @return */ @Override public ServletConfig getServletConfig() { return null; } /** * 提供服务方法 * 每一次Servlet被访问时执行，执行多次。 * @param servletRequest * @param servletResponse * @throws ServletException * @throws IOException */ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(&quot;Hello, Tomcat!&quot;); } @Override public String getServletInfo() { return null; } /** * 销毁方法 * 在服务器正常关闭时执行，执行一次 */ @Override public void destroy() { } } * Servlet中的生命周期方法： 1. 被创建：执行init方法，只执行一次 * Servlet什么时候被创建？ * 默认情况下，第一次被访问时，Servlet被创建 * 可以配置执行Servlet的创建时机。 * 在&lt;servlet&gt;标签下配置 1. 第一次被访问时，创建 * &lt;load-on-startup&gt;的值为负数 2. 在服务器启动时，创建 * &lt;load-on-startup&gt;的值为0或正整数 * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的 * 多个用户同时访问时，可能存在线程安全问题。 * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值 2. 提供服务：执行service方法，执行多次 * 每次访问Servlet时，Service方法都会被调用一次。 3. 被销毁：执行destroy方法，只执行一次 * Servlet被销毁时执行。服务器关闭时，Servlet被销毁 * 只有服务器正常关闭时，才会执行destroy方法。 * destroy方法在Servlet被销毁之前执行，一般用于释放资源 * Servlet3.0： * 好处： * 支持注解配置。可以不需要web.xml了。 * 步骤： 1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml 2. 定义一个类，实现Servlet接口 3. 复写方法 4. 在类上使用@WebServlet注解，进行配置 * @WebServlet(&quot;资源路径&quot;) @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface WebServlet { String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt; String[] value() default {};//代表urlPatterns()属性配置 String[] urlPatterns() default {};//相当于&lt;url-pattern&gt; int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt; WebInitParam[] initParams() default {}; boolean asyncSupported() default false; String smallIcon() default &quot;&quot;; String largeIcon() default &quot;&quot;; String description() default &quot;&quot;; String displayName() default &quot;&quot;; } IDEA与tomcat的相关配置1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件 * 查看控制台的log：Using CATALINA_BASE: &quot;C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast&quot; 2. 工作空间项目和tomcat部署的web项目 * tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot; 的web目录下的所有资源 * WEB-INF目录下的资源不能被浏览器直接访问。 3. 断点调试：使用&quot;小虫子&quot;启动 dubug 启动 Servlet：1. 概念 2. 步骤 3. 执行原理 4. 生命周期 5. Servlet3.0 注解配置 6. Servlet的体系结构 Servlet -- 接口 | GenericServlet -- 抽象类 | HttpServlet -- 抽象类 * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象 * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可 * HttpServlet：对http协议的一种封装，简化操作 1. 定义类继承HttpServlet 2. 复写doGet/doPost方法 7. Servlet相关配置 1. urlpartten:Servlet访问路径 1. 一个Servlet可以定义多个访问路径 ： @WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;}) 2. 路径定义规则： 1. /xxx：路径匹配 2. /xxx/xxx:多层路径，目录结构 3. *.do：扩展名匹配 HTTP：* 概念：Hyper Text Transfer Protocol 超文本传输协议 * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式 * 特点： 1. 基于TCP/IP的高级协议 2. 默认端口号:80 3. 基于请求/响应模型的:一次请求对应一次响应 4. 无状态的：每次请求之间相互独立，不能交互数据 * 历史版本： * 1.0：每一次请求响应都会建立新的连接 * 1.1：复用连接 * 1. 请求消息数据格式 1. 请求行 请求方式 请求url 请求协议/版本 GET /login.html HTTP/1.1 * 请求方式： * HTTP协议有7中请求方式，常用的有2种 * GET： 1. 请求参数在请求行中，在url后。 2. 请求的url长度有限制的 3. 不太安全 * POST： 1. 请求参数在请求体中 2. 请求的url长度没有限制的 3. 相对安全 2. 请求头：客户端浏览器告诉服务器一些信息 请求头名称: 请求头值 * 常见的请求头： 1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 2. Referer：http://localhost/login.html * 告诉服务器，我(当前请求)从哪里来？ * 作用： 1. 防盗链： 2. 统计工作： 3. 请求空行 空行，就是用于分割POST请求的请求头，和请求体的。 4. 请求体(正文)： * 封装POST请求消息的请求参数的 * 字符串格式： POST /login.html HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 username=zhangsan *2. 响应消息：服务器端发送给客户端的数据 * 数据格式： 1. 响应行 1. 组成：协议/版本 响应状态码 状态码描述 2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态 1. 状态码都是3位数字 2. 分类： 1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2. 2xx：成功。代表：200 3. 3xx：重定向。代表：302(重定向)，304(访问缓存) 4. 4xx：客户端错误 * 代表： * 404（请求路径没有对应的资源） * 405：请求方式没有对应的doXxx方法 5. 5xx：服务器端错误。代表：500(服务器内部出现异常) 2. 响应头： 1. 格式：头名称： 值 2. 常见的响应头： 1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据 * 值： * in-line:默认值,在当前页面内打开 * attachment;filename=xxx：以附件形式打开响应体。文件下载 3. 响应空行 4. 响应体:传输的数据 * 响应字符串格式 HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt; Request：1. request对象和response对象的原理 1. request和response对象是由服务器创建的。我们来使用它们 2. request对象是来获取请求消息，response对象是来设置响应消息 2. request对象继承体系结构： ServletRequest -- 接口 | 继承 HttpServletRequest -- 接口 | 实现 org.apache.catalina.connector.RequestFacade 类(tomcat) 3. request功能： 1. 获取请求消息数据 1. 获取请求行数据 * GET /day14/demo1?name=zhangsan HTTP/1.1 * 方法： 1. 获取请求方式 ：GET * String getMethod() 2. (*)获取虚拟目录：/day14 * String getContextPath() 3. 获取Servlet路径: /demo1 * String getServletPath() 4. 获取get方式请求参数：name=zhangsan * String getQueryString() 5. (*)获取请求URI：/day14/demo1 * String getRequestURI(): /day14/demo1 * StringBuffer getRequestURL(): http://localhost/day14/demo1 * URL:统一资源定位符 ： http://localhost/day14/demo1 * URI：统一资源标识符 : /day14/demo1 6. 获取协议及版本：HTTP/1.1 * String getProtocol() 7. 获取客户机的IP地址： * String getRemoteAddr() 2. 获取请求头数据 * 方法： * (*)String getHeader(String name):通过请求头的名称获取请求头的值 * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称 3. 获取请求体数据: * 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 * 步骤： 1. 获取流对象 * BufferedReader getReader()：获取字符输入流，只能操作字符数据 * ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 * 在文件上传知识点后讲解 2. 再从流对象中拿数据 2. 其他功能： 1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数 1. String getParameter(String name):根据参数名称获取参数值 username=zs&amp;password=123 2. String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game 3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称 4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合 * 中文乱码问题： * get方式：tomcat 8 已经将get方式乱码问题解决了 * post方式：会乱码 * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;); 2. 请求转发：一种在服务器内部的资源跳转方式 1. 步骤： 1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 2. 特点： 1. 浏览器地址栏路径不发生变化 2. 只能转发到当前服务器内部资源中。 3. 转发是一次请求 3. 共享数据： * 域对象：一个有作用范围的对象，可以在范围内共享数据 * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 * 方法： 1. void setAttribute(String name,Object obj):存储数据 2. Object getAttitude(String name):通过键获取值 3. void removeAttribute(String name):通过键移除键值对 4. 获取ServletContext： * ServletContext getServletContext() Response对象* 功能：设置响应消息 1. 设置响应行 1. 格式：HTTP/1.1 200 ok 2. 设置状态码：setStatus(int sc) 2. 设置响应头：setHeader(String name, String value) 3. 设置响应体： * 使用步骤： 1. 获取输出流 * 字符输出流：PrintWriter getWriter() * 字节输出流：ServletOutputStream getOutputStream() 2. 使用输出流，将数据输出到客户端浏览器 * 案例： 1. 完成重定向 * 重定向：资源跳转的方式 * 代码实现： //1. 设置状态码为302 response.setStatus(302); //2.设置响应头location response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;); //简单的重定向方法 response.sendRedirect(&quot;/day15/responseDemo2&quot;); * 重定向的特点:redirect 1. 地址栏发生变化 2. 重定向可以访问其他站点(服务器)的资源 3. 重定向是两次请求。不能使用request对象来共享数据 * 转发的特点：forward 1. 转发地址栏路径不变 2. 转发只能访问当前服务器下的资源 3. 转发是一次请求，可以使用request对象来共享数据 * forward 和 redirect 区别 * 路径写法： 1. 路径分类 1. 相对路径：通过相对路径不可以确定唯一资源 * 如：./index.html * 不以/开头，以.开头路径 * 规则：找到当前资源和目标资源之间的相对位置关系 * ./：当前目录 * ../:后退一级目录 2. 绝对路径：通过绝对路径可以确定唯一资源 * 如：http://localhost/day15/responseDemo2 /day15/responseDemo2 * 以/开头的路径 * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出 * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) * 建议虚拟目录动态获取：request.getContextPath() * &lt;a&gt; , &lt;form&gt; 重定向... * 给服务器使用：不需要加虚拟目录 * 转发路径 2. 服务器输出字符数据到浏览器 * 步骤： 1. 获取字符输出流 2. 输出数据 * 注意： * 乱码问题： 1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 2. 设置该流的默认编码 3. 告诉浏览器响应体使用的编码 //简单的形式，设置编码，是在获取流之前设置 response.setContentType(&quot;text/html;charset=utf-8&quot;); 3. 服务器输出字节数据到浏览器 * 步骤： 1. 获取字节输出流 2. 输出数据 4. 验证码 1. 本质：图片 2. 目的：防止恶意表单注册 ServletContext对象：1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信 2. 获取： 1. 通过request对象获取 request.getServletContext(); 2. 通过HttpServlet获取 this.getServletContext(); 3. 功能： 1. 获取MIME类型： * MIME类型:在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型/小类型 text/html image/jpeg * 获取：String getMimeType(String file) 2. 域对象：共享数据 1. setAttribute(String name,Object value) 2. getAttribute(String name) 3. removeAttribute(String name) * ServletContext对象范围：所有用户所有请求的数据 3. 获取文件的真实(服务器)路径 1. 方法：String getRealPath(String path) String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问 System.out.println(b); String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问 System.out.println(c); String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问 System.out.println(a); 案例：* 文件下载需求： 1. 页面显示超链接 2. 点击超链接后弹出下载提示框 3. 完成图片文件下载 * 分析： 1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求 2. 任何资源都必须弹出下载提示框 3. 使用响应头设置资源的打开方式： * content-disposition:attachment;filename=xxx * 步骤： 1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename 2. 定义Servlet 1. 获取文件名称 2. 使用字节输入流加载文件进内存 3. 指定response的响应头： content-disposition:attachment;filename=xxx 4. 将数据写出到response输出流 * 问题： * 中文文件问题 * 解决思路： 1. 获取客户端使用的浏览器版本信息 2. 根据不同的版本信息，设置filename的编码方式不同 案例：用户登录* 用户登录案例需求： 1.编写login.html登录页面 username &amp; password 两个输入框 2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表 3.使用JdbcTemplate技术封装JDBC 4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您 5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误 * 分析 * 开发步骤 1. 创建项目，导入html页面，配置文件，jar包 2. 创建数据库环境 CREATE DATABASE day14; USE day14; CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) UNIQUE NOT NULL, PASSWORD VARCHAR(32) NOT NULL ); 3. 创建包cn.itcast.domain,创建类User package cn.itcast.domain; /** * 用户的实体类 */ public class User { private int id; private String username; private String password; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, username=&apos;&quot; + username + &apos;\&apos;&apos; + &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; + &apos;}&apos;; } } 4. 创建包cn.itcast.util,编写工具类JDBCUtils package cn.itcast.util; import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.DataSource; import javax.xml.crypto.Data; import java.io.IOException; import java.io.InputStream; import java.sql.Connection; import java.sql.SQLException; import java.util.Properties; /** * JDBC工具类 使用Durid连接池 */ public class JDBCUtils { private static DataSource ds ; static { try { //1.加载配置文件 Properties pro = new Properties(); //使用ClassLoader加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //2.初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接池对象 */ public static DataSource getDataSource(){ return ds; } /** * 获取连接Connection对象 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } } 5. 创建包cn.itcast.dao,创建类UserDao,提供login方法 package cn.itcast.dao; import cn.itcast.domain.User; import cn.itcast.util.JDBCUtils; import org.springframework.dao.DataAccessException; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; /** * 操作数据库中User表的类 */ public class UserDao { //声明JDBCTemplate对象共用 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 登录方法 * @param loginUser 只有用户名和密码 * @return user包含用户全部数据,没有查询到，返回null */ public User login(User loginUser){ try { //1.编写sql String sql = &quot;select * from user where username = ? and password = ?&quot;; //2.调用query方法 User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getUsername(), loginUser.getPassword()); return user; } catch (DataAccessException e) { e.printStackTrace();//记录日志 return null; } } } 6. 编写cn.itcast.web.servlet.LoginServlet类 package cn.itcast.web.servlet; import cn.itcast.dao.UserDao; import cn.itcast.domain.User; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/loginServlet&quot;) public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.设置编码 req.setCharacterEncoding(&quot;utf-8&quot;); //2.获取请求参数 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password); //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //5.判断user if(user == null){ //登录失败 req.getRequestDispatcher(&quot;/failServlet&quot;).forward(req,resp); }else{ //登录成功 //存储数据 req.setAttribute(&quot;user&quot;,user); //转发 req.getRequestDispatcher(&quot;/successServlet&quot;).forward(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } 7. 编写FailServlet和SuccessServlet类 @WebServlet(&quot;/successServlet&quot;) public class SuccessServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取request域中共享的user对象 User user = (User) request.getAttribute(&quot;user&quot;); if(user != null){ //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录成功！&quot;+user.getUsername()+&quot;,欢迎您&quot;); } } @WebServlet(&quot;/failServlet&quot;) public class FailServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录失败，用户名或密码错误&quot;); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 8. login.html中form表单的action路径的写法 * 虚拟目录+Servlet的资源路径 9. BeanUtils工具类，简化数据封装 * 用于封装JavaBean的 1. JavaBean：标准的Java类 1. 要求： 1. 类必须被public修饰 2. 必须提供空参的构造器 3. 成员变量必须使用private修饰 4. 提供公共setter和getter方法 2. 功能：封装数据 2. 概念： 成员变量： 属性：setter和getter方法截取后的产物 例如：getUsername() --&gt; Username--&gt; username 3. 方法： 1. setProperty() 2. getProperty() 3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb-Http与Servlet概述]]></title>
    <url>%2F2020%2F07%2F13%2FHttp%E4%B8%8EServlet%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Servlet Servlet的概述 Servlet的定义及其作用：Servlet是运行在Web服务器(eg.Tomcat)上的java程序，通过HTTP协议接收好响应来自Web客户端的请求。 Servlet的实现 Servlet接口定义了初始化servlet的方法、为请求提供服务的方法和从服务器移除servlet的方法,这些方法成为生命周期方法 Servlet实现方法：定义一个类implements Servlet 或者 Extends GenericServlet/HttpServlet(最常用) Servlet中的生命周期方法是按以下顺序调用的： 构造Servlet，使用init方法初始化 创建Servlet实例的时候回执行init方法 一个Servlet只会初始化一次，init方法只会被执行一次 处理客户端的请求对service方法的调用 当客户端有请求的时候回调用service方法 一次请求对应着service的执行，所以它可以被多次执行 从服务器中一处Servlet，并用destroy销毁它，最后垃圾回收终止它 Servlet销毁时会执行： 当Servlet从服务器移除时执行； 当关闭服务器时执行 下面是实现了Servlet的代码： 12345678public class Sever_servlet extends HttpServlet&#123; @Override public void init(ServletConfig arg0) throws ServletException &#123;&#125; @Override public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException &#123;&#125; @Override public void destroy() &#123;&#125;&#125; Servlet的配置 在一个Web工程中当我们实现了一个Servlet的时候，我们应该在Web工程中将这的Servlet加入到配置文件Web。xml文件中，配置Servlet。 下面是在web.xml天剑一个Servlet的写法 获取Servlet配置信息 //1. 得到servlet配置对象 专门用于在配置servlet的信息 ServletConfig config = getServletConfig(); //获取到的是配置servlet里面servlet-name 的文本内容 String servletName = config.getServletName(); System.out.println(&quot;servletName=&quot;+servletName); //2. 可以获取具体的某一个参数。 String address = config.getInitParameter(&quot;address&quot;); System.out.println(&quot;address=&quot;+address); //3. 获取所有的参数名称 Enumeration&lt;String&gt; names = config.getInitParameterNames(); //遍历取出所有的参数名称 while (names.hasMoreElements()) { String key = (String) names.nextElement(); String value = config.getInitParameter(key); System.out.println(&quot;key===&quot;+key + &quot; value=&quot;+value); } ServletContext 每个web工程都只有一个ServletContext对象。 在同一个Web工程中不管是哪个servlet，获取到的这个类的对象都是同一个 ServletContext主要有三个作用： 获取Web工程的全局配置参数 获得Web工程中的资源（properities） 存取数据，Servlet间共享数据，即域对象 获取全局配置参数在web.xml文件中有定义全局参数，每个Servlet都可以访问，而Servlet内部的参数只可以由自己访 icon 通过调用getServletContext()方法可以获得Web工程的ServletContext对象，通过这个对象来访问全局参数 icon 获取Web工程中的资源Web工程里的properities文件资源 //获取Web工程的ServletContext对象 ServletContext context=getServletContext(); //获得对去加载读取资源的对象property Properities property=new Properities(); //获取输入流，就是资源 InputStream in=null; //加载资源并读取 property.load(in); String city=property.getProperty(); 这里的关键是如何读入资源，获得资源的输入流InputStream，有三种方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//获得Servlet对象ServletContext context=getServletContext();Properties properity=new Properties();//方法一：通过ServletContext的getRealpath()方法获得资源输入流，只需要传入资源的相对路径/* * getRealPath("")这个得到的是运行在服务器TomCat中Web项目的根路径 * D:\tomcat\apache-tomcat-7.0.52\apache-tomcat-7.0.52\wtpwebapps\Web\ * getRealPath("file/file.properties")这个会将传入的相对路径拼接到上面的项目根路径的后面 * D:\tomcat\apache-tomcat-7.0.52\apache-tomcat-7.0.52\wtpwebapps\Web\file/file.properties* */String path= context.getRealPath("file/file.properties");InputStream in=new FileInputStream(path);//方式二：通过context.getResourceAsStream("file/file.properties")直接过得资源的输入流InputStream in=context.getResourceAsStream("file/file.properties");//方式三：通过类加载器直接获得资源的输入流InputStream in=this.getClass().getClassLoader().getResourceAsStream("../../file/file.properities");properity.load(in);String city=properity.getProperty("city");System.out.println("city:"+city); ``` ## HttpServletRequest ### 获取客户端的信息&gt;HttpServletRequest中封装了客户端所有的信息 &gt;通过request可以获得客户端请求头的全部信息和客户端传递的参数```javapublic class Request extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //取出客户端请求里面的所有头信息(名称-值) Enumeration&lt;String&gt;headers=request.getHeaderNames(); while(headers.hasMoreElements()) &#123; String name=headers.nextElement(); String value=request.getHeader(name); System.out.println(name+":"+value); &#125; //获得客户端上传的参数 //1.利用枚举方法获得参数 Enumeration&lt;String&gt;parameter=request.getParameterNames(); while(parameter.hasMoreElements()) &#123; String name=parameter.nextElement(); String value=request.getParameter(name); System.out.println(name+":"+value); &#125; //2.利用Map来获取参数 Map&lt;String,String[]&gt;parameter=request.getParameterMap(); Set&lt;String&gt; paras=parameter.keySet(); Iterator&lt;String&gt; it=paras.iterator(); while(it.hasNext()) &#123; String name=it.next(); String value=parameter.get(name)[0]; System.out.println(name+":"+value); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;&#125;&#125; 中文乱码 当客户端提交的数据中有中文的时候会出现乱码的现象，Get和POST方式的解决方法不同 Get请求方式 由于Get请求方式上传提交的数据是在Url地址中的，所以服务器接收的时候已经过编码了，服务器端直接获得的数据是乱码的 //tomcat收到了这批数据，getParameter 默认使用ISO-8859-1去解码 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); //先让文字回到ISO-8859-1对应的字节数组 ， 然后再按utf-8组拼字符串 username = new String(username.getBytes(&quot;ISO-8859-1&quot;) , &quot;UTF-8&quot;); System.out.println(&quot;userName=&quot;+username+&quot;==password=&quot;+password); 直接在tomcat里面做配置，以后get请求过来的数据永远都是用UTF-8编码。 可以在tomcat里面做设置处理 conf/server.xml 加上URIEncoding=&quot;utf-8&quot; &lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt; Post请求 在getParameter之前加入这行代码，是在设置请求体的编码方式 request.setCharacterEncoding(&quot;UTF-8&quot;); HttpServletResponse 它的作用是响应返回数据给客户端输出数据到页面上 //以字符流的方式写数据 response.getWriter().write(&quot;&lt;h1&gt;hello response...&lt;/h1&gt;&quot;); //以字节流的方式写数据 response.getOutputStream().write(&quot;hello&quot;.getBytes()); 中文乱码 以字符流输出 response.getWriter() //1. 指定输出到客户端的时候，这些文字使用UTF-8编码 response.setCharacterEncoding(&quot;UTF-8&quot;); //2. 直接规定浏览器看这份数据的时候，使用什么编码来看。 response.setHeader(&quot;Content-Type&quot;, &quot;text/html; charset=UTF-8&quot;); response.getWriter().write(&quot;北京&quot;); 以字节流输出 response.getOutputStream() //1. 指定浏览器看这份数据使用的码表 response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;); //2. 指定输出的中文用的码表 response.getOutputStream().write(&quot;我爱北京&quot;.getBytes(&quot;UTF-8&quot;)); 不管是字节流还是字符流，直接使用一行代码，然后再写数据 response.setContentType(&quot;text/html;charset=UTF-8&quot;); id: 96 论文名称：Attention-based Dynamic Preference Model for Next Point-of-Interest Recommendation 作者：Chenwang Zheng and Dan Tao]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb-JDBC]]></title>
    <url>%2F2020%2F06%2F18%2FJavaWeb-JDBC%2F</url>
    <content type="text"><![CDATA[JDBC 概念：Java DataBase Connectivity, Java 数据库连接, Java语言操作数据库. JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 快速入门： 步骤： 1). 导入驱动jar包, mysql-connector-java-5.1.37-bin.jar * 复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 * 右键--&gt;Add As Library 2). 注册驱动 3). 获取数据库连接对象 Connection 4). 定义sql 5). 获取执行sql语句的对象 Statement 6). 执行sql，接受返回结果 7). 处理结果 8). 释放资源 代码实现： //1. 导入驱动jar包 //2.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;); //4.定义sql语句 String sql = &quot;update account set balance = 500 where id = 1&quot;; //5.获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //6.执行sql int count = stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 stmt.close(); conn.close(); 详解各个对象： 1). DriverManager：驱动管理对象 * 功能： 1. 注册驱动：告诉程序该使用哪一个数据库驱动jar * static void registerDriver(Driver driver): 注册与给定的驱动程序 DriverManager 。 * 写代码使用： Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 static { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(&quot;Can&apos;t register driver!&quot;); } } 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。 2. 获取数据库连接： * 方法：static Connection getConnection(String url, String user, String password) * 参数： * url：指定连接的路径 * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 * 例子：jdbc:mysql://localhost:3306/db3 * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 * user：用户名 * password：密码 2). Connection：数据库连接对象 1. 功能： 1. 获取执行sql 的对象 * Statement createStatement() * PreparedStatement prepareStatement(String sql) 2. 管理事务： * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 * 提交事务：commit() * 回滚事务：rollback() 3). Statement：执行sql的对象 1. 执行sql 1. boolean execute(String sql) ：可以执行任意的sql 了解 2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。 3. ResultSet executeQuery(String sql) ：执行DQL（select)语句 2. 练习： 1. account表 添加一条记录 2. account表 修改记录 3. account表 删除一条记录 代码： Statement stmt = null; Connection conn = null; try { //1. 注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2. 定义sql String sql = &quot;insert into account values(null,&apos;王五&apos;,3000)&quot;; //3.获取Connection对象 conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;); //4.获取执行sql的对象 Statement stmt = conn.createStatement(); //5.执行sql int count = stmt.executeUpdate(sql);//影响的行数 //6.处理结果 System.out.println(count); if(count &gt; 0){ System.out.println(&quot;添加成功！&quot;); }else{ System.out.println(&quot;添加失败！&quot;); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); }finally { //stmt.close(); //7. 释放资源 //避免空指针异常 if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } 4). ResultSet：结果集对象,封装查询结果 * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true * getXxx(参数):获取数据 * Xxx：代表数据类型 如： int getInt() , String getString() * 参数： 1. int：代表列的编号,从1开始 如： getString(1) 2. String：代表列名称。 如： getDouble(&quot;balance&quot;) * 注意： * 使用步骤： 1. 游标向下移动一行 2. 判断是否有数据 3. 获取数据 //循环判断游标是否是最后一行末尾。 while(rs.next()){ //获取数据 //6.2 获取数据 int id = rs.getInt(1); String name = rs.getString(&quot;name&quot;); double balance = rs.getDouble(3); System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance); } * 练习： * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。 1. 定义Emp类 2. 定义方法 public List&lt;Emp&gt; findAll(){} 3. 实现方法 select * from emp; 5). PreparedStatement：执行sql的对象 1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 1. 输入用户随便，输入密码：a&apos; or &apos;a&apos; = &apos;a 2. sql：select * from user where username = &apos;fhdsjkf&apos; and password = &apos;a&apos; or &apos;a&apos; = &apos;a&apos; 2. 解决sql注入问题：使用PreparedStatement对象来解决 3. 预编译的SQL：参数使用?作为占位符 4. 步骤： 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 5. 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 6. 给？赋值： * 方法： setXxx(参数1,参数2) * 参数1：？的位置编号 从1 开始 * 参数2：？的值 7. 执行sql，接受返回结果，不需要传递sql语句 8. 处理结果 9. 释放资源 5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作 1. 可以防止SQL注入 2. 效率更高 抽取JDBC工具类： JDBCUtils *目的：简化书写 * 分析： 1. 注册驱动也抽取 2. 抽取一个方法获取连接对象 * 需求：不想传递参数（麻烦），还得保证工具类的通用性。 * 解决：配置文件 jdbc.properties url= user= password= 3. 抽取一个方法释放资源 * 代码实现： public class JDBCUtils { private static String url; private static String user; private static String password; private static String driver; /** * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块 */ static{ //读取资源文件，获取值。 try { //1. 创建Properties集合类。 Properties pro = new Properties(); //获取src路径下的文件的方式---&gt;ClassLoader 类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource(&quot;jdbc.properties&quot;); String path = res.getPath(); System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties //2. 加载文件 // pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;)); pro.load(new FileReader(path)); //3. 获取数据，赋值 url = pro.getProperty(&quot;url&quot;); user = pro.getProperty(&quot;user&quot;); password = pro.getProperty(&quot;password&quot;); driver = pro.getProperty(&quot;driver&quot;); //4. 注册驱动 Class.forName(driver); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } /** * 获取连接 * @return 连接对象 */ public static Connection getConnection() throws SQLException { return DriverManager.getConnection(url, user, password); } /** * 释放资源 * @param stmt * @param conn */ public static void close(Statement stmt,Connection conn){ if( stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if( conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } /** * 释放资源 * @param stmt * @param conn */ public static void close(ResultSet rs,Statement stmt, Connection conn){ if( rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if( stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if( conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } 练习 * 需求： 1. 通过键盘录入用户名和密码 2. 判断用户是否登录成功 * select * from user where username = &quot;&quot; and password = &quot;&quot;; * 如果这个sql有查询结果，则成功，反之，则失败 * 步骤： 1. 创建数据库表 user CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32), PASSWORD VARCHAR(32) ); INSERT INTO USER VALUES(NULL,&apos;zhangsan&apos;,&apos;123&apos;); INSERT INTO USER VALUES(NULL,&apos;lisi&apos;,&apos;234&apos;); 2. 代码实现： public class login_demo { public static void main(String[] args) { // 1. 键盘录入，接受用户名和密码 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入姓名：&quot;); String username = sc.nextLine(); System.out.println(&quot;请输入密码：&quot;); String password = sc.nextLine(); // 2. 调用方法 boolean flag = login(username, password); // 3. 判断结果 if(flag){ System.out.println(&quot;登陆成功！&quot;); }else{ System.out.println(&quot;登录失败！&quot;); } } public static boolean login(String username, String password){ if(username==null || password==null){ return false; } Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; try { // 1. 获取数据库连接 conn = JDBCutils.getConnection(); // 2. 定义sql语句 String sql = &quot;select * from user where username = ? and password = ?&quot;; // 3. 获取执行sql的对象 pstmt = conn.prepareStatement(sql); // 给 ? 赋值 pstmt.setString(1, username); pstmt.setString(2, password); // 4. 执行sql rs = pstmt.executeQuery(); return rs.next(); } catch (SQLException e) { e.printStackTrace(); } finally { JDBCutils.close(rs,pstmt,conn); } return false; } } JDBC控制事务： 1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 2. 操作： 1. 开启事务 2. 提交事务 3. 回滚事务 3. 使用Connection对象来管理事务 * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 * 在执行sql之前开启事务 * 提交事务：commit() * 当所有sql都执行完提交事务 * 回滚事务：rollback() * 在catch中回滚事务 4. 代码： public class JDBCDemo10 { public static void main(String[] args) { Connection conn = null; PreparedStatement pstmt1 = null; PreparedStatement pstmt2 = null; try { //1.获取连接 conn = JDBCUtils.getConnection(); //开启事务 conn.setAutoCommit(false); //2.定义sql //2.1 张三 - 500 String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;; //2.2 李四 + 500 String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;; //3.获取执行sql对象 pstmt1 = conn.prepareStatement(sql1); pstmt2 = conn.prepareStatement(sql2); //4. 设置参数 pstmt1.setDouble(1,500); pstmt1.setInt(2,1); pstmt2.setDouble(1,500); pstmt2.setInt(2,2); //5.执行sql pstmt1.executeUpdate(); // 手动制造异常 int i = 3/0; pstmt2.executeUpdate(); //提交事务 conn.commit(); } catch (Exception e) { //事务回滚 try { if(conn != null) { conn.rollback(); } } catch (SQLException e1) { e1.printStackTrace(); } e.printStackTrace(); }finally { JDBCUtils.close(pstmt1,conn); JDBCUtils.close(pstmt2,null); } } } 数据库连接池1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 2. 好处： 1. 节约资源 2. 用户访问高效 3. 实现： 1. 标准接口：DataSource javax.sql包下的 1. 方法： * 获取连接：getConnection() * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 2. 一般我们不去实现它，有数据库厂商来实现 1. C3P0：数据库连接池技术 2. Druid：数据库连接池实现技术，由阿里巴巴提供的 4. C3P0：数据库连接池技术 * 步骤： 1. 导入jar包 (两个) c3p0-0.9.5.2.jar 和 mchange-commons-java-0.2.12.jar ， * 不要忘记导入数据库驱动jar包 2. 定义配置文件： * 名称： c3p0.properties 或者 c3p0-config.xml * 路径：直接将文件放在src目录下即可。 3. 创建核心对象 数据库连接池对象 ComboPooledDataSource 4. 获取连接： getConnection * 代码： //1.创建数据库连接池对象 DataSource ds = new ComboPooledDataSource(); //2. 获取连接对象 Connection conn = ds.getConnection(); 5. Druid：数据库连接池实现技术，由阿里巴巴提供的 1. 步骤： 1. 导入jar包 druid-1.0.9.jar 2. 定义配置文件： * 是properties形式的 * 可以叫任意名称，可以放在任意目录下 3. 加载配置文件。Properties 4. 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory 5. 获取连接：getConnection * 代码： //3.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //4.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //5.获取连接 Connection conn = ds.getConnection(); 2. 定义工具类 1. 定义一个类 JDBCUtils 2. 提供静态代码块加载配置文件，初始化连接池对象 3. 提供方法 1. 获取连接方法：通过数据库连接池获取连接 2. 释放资源 3. 获取连接池的方法 * 代码： public class JDBCUtils { //1.定义成员变量 DataSource private static DataSource ds ; static{ try { //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;)); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } /** * 释放资源 */ public static void close(Statement stmt,Connection conn){ /* if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close();//归还连接 } catch (SQLException e) { e.printStackTrace(); } }*/ close(null,stmt,conn); } public static void close(ResultSet rs , Statement stmt, Connection conn){ if(rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close();//归还连接 } catch (SQLException e) { e.printStackTrace(); } } } /** * 获取连接池方法 */ public static DataSource getDataSource(){ return ds; } } Spring JDBC : JDBC Template* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 * 步骤： 1. 导入jar包 2. 创建JdbcTemplate对象。依赖于数据源DataSource * JdbcTemplate template = new JdbcTemplate(ds); 3. 调用JdbcTemplate的方法来完成CRUD的操作 * update():执行DML语句。增、删、改语句 * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 * 注意：这个方法查询的结果集长度只能是1 * queryForList():查询结果将结果集封装为list集合 * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 * query():查询结果，将结果封装为JavaBean对象 * query的参数：RowMapper * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 * new BeanPropertyRowMapper&lt;类型&gt;(类型.class) * queryForObject：查询结果，将结果封装为对象 * 一般用于聚合函数的查询 4. 练习： * 需求： 1. 修改1号数据的 salary 为 10000 2. 添加一条记录 3. 删除刚才添加的记录 4. 查询id为1的记录，将其封装为Map集合 5. 查询所有记录，将其封装为List 6. 查询所有记录，将其封装为Emp对象的List集合 7. 查询总记录数 * 代码： import cn.itcast.domain.Emp; import cn.itcast.utils.JDBCUtils; import org.junit.Test; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.RowMapper; import java.sql.Date; import java.sql.ResultSet; import java.sql.SQLException; import java.util.List; import java.util.Map; public class JdbcTemplateDemo2 { //Junit单元测试，可以让方法独立执行 //1. 获取JDBCTemplate对象 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 1. 修改1号数据的 salary 为 10000 */ @Test public void test1(){ //2. 定义sql String sql = &quot;update emp set salary = 10000 where id = 1001&quot;; //3. 执行sql int count = template.update(sql); System.out.println(count); } /** * 2. 添加一条记录 */ @Test public void test2(){ String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;; int count = template.update(sql, 1015, &quot;郭靖&quot;, 10); System.out.println(count); } /** * 3.删除刚才添加的记录 */ @Test public void test3(){ String sql = &quot;delete from emp where id = ?&quot;; int count = template.update(sql, 1015); System.out.println(count); } /** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */ @Test public void test4(){ String sql = &quot;select * from emp where id = ? or id = ?&quot;; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20} } /** * 5. 查询所有记录，将其封装为List */ @Test public void test5(){ String sql = &quot;select * from emp&quot;; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) { System.out.println(stringObjectMap); } } /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6(){ String sql = &quot;select * from emp&quot;; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() { @Override public Emp mapRow(ResultSet rs, int i) throws SQLException { Emp emp = new Emp(); int id = rs.getInt(&quot;id&quot;); String ename = rs.getString(&quot;ename&quot;); int job_id = rs.getInt(&quot;job_id&quot;); int mgr = rs.getInt(&quot;mgr&quot;); Date joindate = rs.getDate(&quot;joindate&quot;); double salary = rs.getDouble(&quot;salary&quot;); double bonus = rs.getDouble(&quot;bonus&quot;); int dept_id = rs.getInt(&quot;dept_id&quot;); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; } }); for (Emp emp : list) { System.out.println(emp); } } /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6_2(){ String sql = &quot;select * from emp&quot;; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) { System.out.println(emp); } } /** * 7. 查询总记录数 */ @Test public void test7(){ String sql = &quot;select count(id) from emp&quot;; Long total = template.queryForObject(sql, Long.class); System.out.println(total); } }]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库知识]]></title>
    <url>%2F2020%2F06%2F12%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[数据库的基本概念 数据库的英文单词： DataBase 简称 ： DB 什么数据库？ 用于存储和管理数据的仓库。 数据库的特点： 持久化存储数据的。其实数据库就是一个文件系统 方便存储和管理数据 使用了统一的方式操作数据库 — SQL MySQL数据库Mysql的几个操作： - MySQL服务启动 1. 手动。 2. cmd--&gt; services.msc 打开服务的窗口 3. 使用管理员打开cmd * net start mysql: 启动mysql的服务 * net stop mysql: 关闭mysql服务 - MySQL登录 1. mysql -uroot -p密码 : 本地mysql连接 2. mysql -hip -uroot -p连接目标的密码 3. mysql --host=ip --user=root --password=连接目标的密码 - MySQL退出 1. exit 2. quit SQL1.什么是SQL？ Structured Query Language：结构化查询语言 2.SQL的作用 SQL是一种所有关系型数据库的查询规范，不同的数据库都支持。 通用的数据库操作语言，可以用在不同的数据库中。 不同的数据库SQL语句有一些区别 3.SQL通用语法 SQL 语句可以单行或多行书写，以分号结尾。 可使用空格和缩进来增强语句的可读性。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 3 种注释 单行注释: -- 注释内容 或 # 注释内容(mysql特有) 多行注释: /* 注释美容 */ 4. SQL分类 DDL(Data Definition Language) 数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language) 数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language )数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language) 数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 SQL语句-数据库的操作DDL:操作数据库、表 操作数据库（CRUD） 1）C (Create)： 创建 * 创建数据库： * create database 数据库名称； * 创建数据库，判断不存在，再创建： * create database if not exists 数据库名称; * 创建数据库，并指定字符集： * create database 数据库名称 character set 字符集名; 2）R (Retrieve)： 查询 * 查询所有数据库的名称： * show databases； * 查看某个数据库的定义信息： * show create database 数据库名称； 3）U (Update)： 更新 * 修改数据库的字符集： * alter database 数据库名称 character set 字符集名； 4）D (Delect)： 删除 * 删除数据库 * drop database 数据库名称; * 判断数据库存在，存在再删除 * drop database if exists 数据库名称; 5）使用数据库 * 查询当前正在使用的数据库名称 * select database(); * 使用数据库 * use 数据库名称; 操作表 (CRUD) 1) C(Create): 创建 *语法 creat table 表名( 列名1 数据类型1， 列名2 数据类型2， ...... 列名n 数据类型n ) * 注意：最后一列，不需要加逗号（,） * 数据库类型 1. int： 整数类型 * age int, 2. double: 小数类型 * score double(5,2) 3. date: 日期，只包含年月日，yyyy-MM-dd 4. datetime: 日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 5. timestamp: 时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 6. varchar：字符串 * name varchar(20):姓名最大20个字符 * zhangsan 8个字符 张三 2个字符 * 复制一个表： * create table 表名 like 被复制的表名; 2) R(Retrieve): 查询 * 查询某个数据库中所有表的名称 * show tables; * 查询某个表的信息 * show create table 表名; * 查询某个表的结构 * desc 表名； 3）U(Update): 更新 * 修改表名 * alter table 表名 rename to 新的表名; * 修改表的字符集 * alter table 表名 charaster set 字符集名称; * 添加一列 * alter table 表名 add 列名 数据类型; * 修改列命名称,数据类型 * alter table 表名 change 列名 新列名 新数据类型; * alter table 表名 modify 列名 新数据类型; * 删除列 * alter table 表名 drop 列名; 4）D(Delect): 删除 * drop table 表名； * drop table if exists 表名； 数据库的数据类型 DML: 增删改表中数据1. 增添数据 * insert into 表名(列名1, ..., 列名n) values（值1, ..., 值n); * 注意： * 列名和值要一一对应 * 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,...值n); * 除了数字类型，其他类型需要使用引号(单双都可以)引起来 2. 删除数据 * delete from 表名 where条件; eg, delete from db where id=3; * 注意： * 如果不加条件，则删除表中所有记录。 * 如果要删除所有记录 - delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作 - TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 3. 修改数据 * undate 表名 set 列名1=值1,列名2=值2,... where 条件; eg, update db set age=18 where id=3; DQL：查询表中的记录* select * from 表名; 1. 语法 select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 2. 基础查询 * 多个字段的查询 * select 字段1，字段2... from 表名; eg, select name, address from student; * 去除重复 * distinct eg, select distinct address from student; * 计算列 * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） eg, select name, math, english, math+english from student; * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null * 表达式1：哪个字段需要判断是否为null * 表达式如果该字段为null后的替换值。 eg, select name, math, english, math + ifnull(english) from student; * 起别名 * as eg, select name, math, english, math + ifnull(english) as totalscore from student; 3. 条件选择 * where子句后跟条件 * 运算符 * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; * BETWEEN...AND * IN( 集合) * LIKE：模糊查询 * 占位符： * _:单个任意字符 * %：多个任意字符 * IS NULL * and 或 &amp;&amp; * or 或 || * not 或 ! eg， -- 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20; SELECT * FROM student WHERE age &gt;= 20; -- 查询年龄等于20岁 SELECT * FROM student WHERE age = 20; -- 查询年龄不等于20岁 SELECT * FROM student WHERE age != 20; SELECT * FROM student WHERE age &lt;&gt; 20; -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30; SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; -- 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25 SELECT * FROM student WHERE age IN (22,18,25); -- 查询英语成绩为null SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断 SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; * 模糊查询 like * 占位符： * _:单个任意字符 * %：多个任意字符 -- 查询姓马的有哪些？ like SELECT * FROM student WHERE NAME LIKE &apos;马%&apos;; -- 查询姓名第二个字是化的人 SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;; -- 查询姓名是3个字的人 SELECT * FROM student WHERE NAME LIKE &apos;___&apos;; -- 查询姓名中包含德的人 SELECT * FROM student WHERE NAME LIKE &apos;%德%&apos;; 4. 排序查询 * 语法： order by 子句; * order by 排序字段1 排序方式1，排序字段2 排序方式2....; * 排序方式 * ASC：升序（默认） * DESC：降序 * 注意： * 如果有多个排序条件，当前面的条件值一样时，才会判断第二条件 eg， -- 如果数学成绩一样，则按照英语成绩排名 select * from student order by math ASC, english ASC; 5. 聚合函数：将一列数据作为一个整体，进行这一列纵向的计算 * count： 计算个数 * 一般选择非空的列：主键 * count(*) * max： 计算最大值 * min： 计算最小值 * sum： 计算和 * avg： 计算平均值 *注意：聚合函数的计算会排除null值 解决方案： - 选择不包含非空的列进行计算 - 使用IFNULL函数 eg， -- 统计name的数目 select count(name) from student; select count(ifnull(english, 0)) from student; 6. 分组查询 * 语法： group by 分组字段; * 注意： * 分组之后查询字段：分组字段、聚合函数 * where 和 having的区别： * where在分组之前进行限定，将不符合where条件的行去掉，在分组前过滤数据，即先过滤后分组；having在分组之后进行限定，筛选满足条件的组，在分组之后过滤数据，即先分组再过滤。 * where后不可以使用聚合函数，having可以使用聚合函数。 eg， -- 按照性别分组，分别查询男、女同学的平均分，人数 select sex，avg(math)，count(id) from student group by sex; -- 按照性别分组，分别查询男、女同学的平均分，人数 要求：分数低于70的不参与分组 select sex，avg(math)，count(id) from student where math &gt; 70 group by sex; -- 按照性别分组，分别查询男、女同学的平均分，人数 要求：分数低于70的不参与,分组之后人数要大于2人 select sex，avg(math)，count(id) from student where math &gt; 70 group by sex having count(id) &gt; 2; select sex，avg(math)，count(id) usernum from student where math &gt; 70 group by sex having usernum &gt; 2; 7. 分页查询 * 语法： limit 开始的索引,每页查询的条数; 数据库表的约束 约束的作用： 对表中的数据进行限制，保证数据的正确性、有效性和完整性。一个表如果添加了约束，不正确的数据将无法插入到表中。约束在创建表的时候添加比较合适。 约束的分类： 主键约束：primary key 非空约束：not null 唯一约束：unique 外键约束：foreign key 键的介绍 * 非空约束：not null，值不能为null 1. 创建表时添加约束 CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空 ); 2. 创建表完后，添加非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 3. 删除name的非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20); * 唯一约束：unique，值不能重复 1. 创建表时，添加唯一约束 CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束 ); * 注意mysql中，唯一约束限定的列的值可以有多个null 2. 删除唯一约束 ALTER TABLE stu DROP INDEX phone_number; 3. 在创建表后，添加唯一约束 ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE; * 主键约束：primary key 1. 注意： * 含义：非空且唯一 * 一张表只能有一个字段为主键 * 主键就是表中记录的唯一标识 2. 在创建表时，添加主键约束 create table stu( id int primary key,-- 给id添加主键约束 name varchar(20) ); 3. 删除主键 -- 错误 alter table stu modify id int ; ALTER TABLE stu DROP PRIMARY KEY; 4. 创建完表后，添加主键 ALTER TABLE stu MODIFY id INT PRIMARY KEY; 5. 自动增长： * 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长 * 在创建表时，添加主键约束，并且完成主键自增长 create table stu( id int primary key auto_increment,-- 给id添加主键约束 name varchar(20) ); * 删除自动增长 ALTER TABLE stu MODIFY id INT; * 添加自动增长 ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; * 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性 1. 在创建表时，可以添加外键 * 语法： create table 表名( .... 外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) ); 2. 删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 3. 创建表之后，添加外键 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 4. 级联操作 * 添加级联操作 语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE ; * 分类： * 级联更新：ON UPDATE CASCADE * 级联删除：ON DELETE CASCADE 数据库的设计多表之间的关系1. 分类： 1. 一对一(了解)： * 如：人和身份证 * 分析：一个人只有一个身份证，一个身份证只能对应一个人 2. 一对多(多对一)： * 如：部门和员工 * 分析：一个部门有多个员工，一个员工只能对应一个部门 3. 多对多： * 如：学生和课程 * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 2. 实现关系： 1. 一对多(多对一)： * 如：部门和员工 * 实现方式：在多的一方建立外键，指向一的一方的主键。 2. 多对多： * 如：学生和课程 * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 3. 一对一(了解)： * 如：人和身份证 * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。 3. 案例 -- 创建旅游线路分类表 tab_category -- cid 旅游线路分类主键，自动增长 -- cname 旅游线路分类名称非空，唯一，字符串 100 CREATE TABLE tab_category ( cid INT PRIMARY KEY AUTO_INCREMENT, cname VARCHAR(100) NOT NULL UNIQUE ); -- 创建旅游线路表 tab_route /* rid 旅游线路主键，自动增长 rname 旅游线路名称非空，唯一，字符串 100 price 价格 rdate 上架时间，日期类型 cid 外键，所属分类 */ CREATE TABLE tab_route( rid INT PRIMARY KEY AUTO_INCREMENT, rname VARCHAR(100) NOT NULL UNIQUE, price DOUBLE, rdate DATE, cid INT, FOREIGN KEY (cid) REFERENCES tab_category(cid) ); /*创建用户表 tab_user uid 用户主键，自增长 username 用户名长度 100，唯一，非空 password 密码长度 30，非空 name 真实姓名长度 100 birthday 生日 sex 性别，定长字符串 1 telephone 手机号，字符串 11 email 邮箱，字符串长度 100 */ CREATE TABLE tab_user ( uid INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) UNIQUE NOT NULL, PASSWORD VARCHAR(30) NOT NULL, NAME VARCHAR(100), birthday DATE, sex CHAR(1) DEFAULT &apos;男&apos;, telephone VARCHAR(11), email VARCHAR(100) ); /* 创建收藏表 tab_favorite rid 旅游线路 id，外键 date 收藏时间 uid 用户 id，外键 rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次 */ CREATE TABLE tab_favorite ( rid INT, -- 线路id DATE DATETIME, uid INT, -- 用户id -- 创建复合主键 PRIMARY KEY(rid,uid), -- 联合主键 FOREIGN KEY (rid) REFERENCES tab_route(rid), FOREIGN KEY(uid) REFERENCES tab_user(uid) ); 数据库设计的范式* 概念：设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 * 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 * 满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式(3NF）就行了 * 分类 * 第一范式(1NF)：数据库表的每一列都是不可分割的原子数据项，不能是集合、数组等非原子数据项。即第一范式每一列不可再拆分，称为**原子性**。 * 第二范式(2NF)：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） * 几个概念： 1. 函数依赖：A--&gt;B, 如果通过A属性(属性组)的值,可以确定唯一B属性的值, 则称B依赖于A。 例如：学号--&gt;姓名。 （学号，课程名称) --&gt; 分数 2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。 例如：（学号，课程名称）--&gt; 分数 3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如：（学号，课程名称）--&gt; 姓名 4. 传递函数依赖：A--&gt;B, B--&gt;C. 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A。 例如：学号--&gt;系名，系名--&gt;系主任 5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码。 例如：该表中码为：（学号，课程名称） * 主属性：码属性组中的所有属性 * 非主属性：除过码属性组的属性 * 第三范式：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）。 多表的操作多表的查询* 语法 * 准备sql # 创建部门表 CREATE TABLE dept( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); INSERT INTO dept (NAME) VALUES (&apos;开发部&apos;),(&apos;市场部&apos;),(&apos;财务部&apos;); # 创建员工表 CREATE TABLE emp ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), gender CHAR(1), -- 性别 salary DOUBLE, -- 工资 join_date DATE, -- 入职日期 dept_id INT, FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键) ); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;孙悟空&apos;,&apos;男&apos;,7200,&apos;2013-02-24&apos;,1); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;猪八戒&apos;,&apos;男&apos;,3600,&apos;2010-12-02&apos;,2); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;唐僧&apos;,&apos;男&apos;,9000,&apos;2008-08-08&apos;,2); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;白骨精&apos;,&apos;女&apos;,5000,&apos;2015-10-07&apos;,3); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;蜘蛛精&apos;,&apos;女&apos;,4500,&apos;2011-03-14&apos;,1); * 笛卡尔积： * 有两个集合A,B .取这两个集合的所有组成情况。 * 要完成多表查询，需要消除无用的数据 * 查询的分类 * 内连接查询 1. 隐式内连接： 使用where条件消除无用数据 * 例子： -- 查询所有员工信息和对应的部门信息 SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`; -- 查询员工表的名称，性别； 部门表的名称 SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`; 为了防止表名过于复杂，可以给表重新命名 SELECT t1.name, -- 员工表的姓名 t1.gender,-- 员工表的性别 t2.name -- 部门表的名称 FROM emp t1, dept t2 WHERE t1.`dept_id` = t2.`id`; 2. 显式内连接 * 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件 * 例如： * SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`; * SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`; 3. 内连接查询需要确定： * 从哪些表中查询数据 * 条件是什么 * 查询哪些字段 * 外连接查询 1. 左外连接： * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件； * 查询的是左表所有数据以及其交集部分。 * 例子： -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称 SELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`; 2. 右外连接： * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件； * 查询的是右表所有数据以及其交集部分。 * 例子： SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`; * 子查询 * 概念：查询中嵌套查询，称嵌套查询为子查询。 * 例子 -- 查询工资最高的员工信息 -- 1. 查询最高的工资是多少 9000 SELECT MAX(salary) FROM emp; -- 2. 查询员工信息，并且工资等于9000的 SELECT * FROM emp WHERE emp.`salary` = 9000; -- 一条sql就完成这个操作。子查询 SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp); * 子查询不同情况 1. 子查询的结果是单行单列的： * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= = *例子 -- 查询员工工资小于平均工资的人 SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp); 2. 子查询的结果是多行单列的： * 子查询可以作为条件，使用运算符in来判断 * 例子 -- 查询&apos;财务部&apos;和&apos;市场部&apos;所有的员工信息 SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;; SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2; -- 子查询 SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;); 3. 子查询的结果是多行多列的： * 子查询可以作为一张虚拟表参与查询 * 例子 -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息 -- 子查询 SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &apos;2011-11-11&apos;) t2 WHERE t1.id = t2.dept_id; -- 普通内连接 SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt; &apos;2011-11-11&apos; 事务1. 事务的基本介绍 * 概念： * 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 * 操作： 1. 开启事务： start transaction; 2. 回滚：rollback; 3. 提交：commit; * 例子： 创建表 CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), balance DOUBLE ); 添加数据 INSERT INTO account (NAME, balance) VALUES (&apos;zhangsan&apos;, 1000), (&apos;lisi&apos;, 1000); SELECT * FROM account; UPDATE account SET balance = 1000; -- 张三给李四转账 500 元 -- 0. 开启事务 START TRANSACTION; -- 1. 张三账户 -500 UPDATE account SET balance = balance - 500 WHERE NAME = &apos;zhangsan&apos;; -- 2. 李四账户 +500 -- 出错了... UPDATE account SET balance = balance + 500 WHERE NAME = &apos;lisi&apos;; -- 发现执行没有问题，提交事务 COMMIT; -- 发现出问题了，回滚事务 ROLLBACK; 2. 事物的四大特征 * 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 * 持久性：当事务提交或回滚后，数据库会持久化的保存数据。 * 隔离性：多个事务之间。相互独立。 * 一致性：事务操作前后，数据总量不变 3. 事务的隔离级别 * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 * 存在问题： 1. 脏读：一个事务，读取到另一个事务中没有提交的数据 2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 * 隔离级别： 1. read uncommitted：读未提交 * 产生的问题：脏读、不可重复读、幻读 2. read committed：读已提交 （Oracle） * 产生的问题：不可重复读、幻读 3. repeatable read：可重复读 （MySQL默认） * 产生的问题：幻读 4. serializable：串行化 * 可以解决所有的问题 * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 * 数据库查询隔离级别： * select @@tx_isolation; * 数据库设置隔离级别： * set global transaction isolation level 级别字符串; * 演示： set global transaction isolation level read uncommitted; start transaction; -- 转账操作 update account set balance = balance - 500 where id = 1; update account set balance = balance + 500 where id = 2;]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-动态规划]]></title>
    <url>%2F2020%2F06%2F12%2F%E5%89%91%E6%8C%87offer-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[分治策略：将原问题分解为若干个规模较小但类似于原问题的子问题（Divide），「递归」的求解这些子问题（Conquer），然后再合并这些子问题的解来建立原问题的解。 动态规划: 动态规划其实和分治策略是类似的，也是将一个原问题分解为若干个规模较小的子问题，递归的求解这些子问题，然后合并子问题的解得到原问题的解。 区别在于这些子问题会有重叠，一个子问题在求解后，可能会再次求解，于是我们想到将这些子问题的解存储起来，当下次再次求解这个子问题时，直接拿过来就是。 其实就是说，动态规划所解决的问题是分治策略所解决问题的一个子集，只是这个子集更适合用动态规划来解决从而得到更小的运行时间。 即用动态规划能解决的问题分治策略肯定能解决，只是运行时间长了。因此，分治策略一般用来解决子问题相互对立的问题，称为标准分治，而动态规划用来解决子问题重叠的问题。 https://www.zhihu.com/question/39948290/answer/883302989https://www.zhihu.com/question/39948290 1. 连续子数组最大和题目描述 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1). 解题思路这是一道典型的动态规划题目。 最大子数组的和一定是由当前元素和之前最大连续子数组的和叠加在一起形成的。 假设dp[i]代表以当前元素a[i]为截止点的连续子序列的最大和; 若dp[i-1]&gt;0, dp[i]=a[i]+dp[i-1], 因为当前数加上正数一定会变大; 若dp[i-1]&lt;0, dp[i]=a[i], 因为当前数加上负数一定会变小； 使用max记录最大的dp值。 max=Math.max(max, dp[i]). 1234567891011 public class Solution &#123; public int FindGreatestSumOfSubArray(int[] array) &#123; int max = array[0]; for(int i=1; i&lt;array.length; i++)&#123; array[i] += array[i-1] &gt; 0 ? array[i-1]: 0; max = Math.max(max, array[i]); &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-数组与数学问题]]></title>
    <url>%2F2020%2F06%2F07%2F%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[数组问题1. 数字统计题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 解题思路 哈希法：先遍历一遍数组，利用Map存储每个元素出现的次数，在遍历一次Map，找出众数。 12345678910111213141516171819202122232425262728293031 import java.util.HashMap;import java.util.Set;import java.util.Map;public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; if(array.length==0)&#123; return 0; &#125; int l = (int)(array.length / 2); Map&lt;Integer, Integer&gt; count = new HashMap&lt;&gt; (); for(int i=0; i&lt;array.length; i++)&#123; int num = array[i]; if(count.containsKey(num))&#123; count.put(num, count.get(num)+1); &#125;else&#123; count.put(num, 1); &#125; &#125; Set&lt;Integer&gt; set = count.keySet(); for(Integer k: set)&#123; Integer v = count.get(k); if(v.intValue() &gt; l)&#123; return k.intValue(); &#125; &#125; return 0; &#125;&#125;// 时间复杂度：O(n)// 空间复杂度：O(n) 排序法：先将数组进行排序，众数一定在数组中间，再比遍历数组统计该数出现的次数，进行判断。 1234567891011121314151617181920 import java.util.Arrays;public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; if(array.length==0)&#123; return 0; &#125; Arrays.sort(array); int num = array[array.length / 2]; int count = 0; for(int i=0; i&lt;array.length; i++)&#123; if(array[i] == num)&#123; count ++; &#125; &#125; return count&gt;(array.length / 2)?num:0; &#125;&#125; // 时间复杂度：O(nlogn)// 空间复杂度：O(1) 候选法（最优解):如果两个数不相等，就消去这两个数，最坏情况下，每次消去一个众数和一个非众数，那么如果存在众数，最后留下的数肯定是众数。 12345678910111213141516171819202122232425262728 public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; int num = -1; int cnt = 0; for(int i=0; i&lt;array.length; i++)&#123; if(cnt == 0)&#123; num = array[i]; cnt ++; &#125;else&#123; if(num == array[i])&#123; cnt++; &#125;else&#123; cnt --; &#125; &#125; &#125; cnt = 0; for(int i=0; i&lt;array.length; i++)&#123; if(array[i] == num)&#123; cnt ++; &#125; &#125; return cnt&gt;(array.length/2)?num: 0; &#125;&#125;// 时间复杂度：O(n)// 空间复杂度：O(1) 2. 连续子数组最大和题目描述 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1). 解题思路这是一道典型的动态规划题目。 最大子数组的和一定是由当前元素和之前最大连续子数组的和叠加在一起形成的。 假设dp[i]代表以当前元素a[i]为截止点的连续子序列的最大和; 若dp[i-1]&gt;0, dp[i]=a[i]+dp[i-1], 因为当前数加上正数一定会变大; 若dp[i-1]&lt;0, dp[i]=a[i], 因为当前数加上负数一定会变小； 使用max记录最大的dp值。 max=Math.max(max, dp[i]). 1234567891011 public class Solution &#123; public int FindGreatestSumOfSubArray(int[] array) &#123; int max = array[0]; for(int i=1; i&lt;array.length; i++)&#123; array[i] += array[i-1] &gt; 0 ? array[i-1]: 0; max = Math.max(max, array[i]); &#125; return max; &#125;&#125; 3. 把数组排成最小的数题目描述 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 解题思路将各个元素从小到大进行排序，排序之后再把他们串联起来。 比较两个字符串s1, s2大小的时候，先将它们拼接起来，比较s1+s2,和s2+s1那个大，如果s1+s2大，那说明s2应该放前面，所以按这个规则，s2就应该排在s1前面。 123456789101112131415161718192021222324 import java.util.ArrayList;public class Solution &#123; public String PrintMinNumber(int [] numbers) &#123; if(numbers.length == 0) return ""; for(int i=0; i&lt;numbers.length; i++)&#123; for(int j=i+1; j&lt;numbers.length; j++)&#123; int s1 = Integer.parseInt(numbers[i] + "" + numbers[j]); int s2 = Integer.parseInt(numbers[j] + "" + numbers[i]); if(s1 &gt; s2)&#123; int temp = numbers[i]; numbers[i] = numbers[j]; numbers[j] = temp; &#125; &#125; &#125; String str = new String(""); for(int i=0; i&lt;numbers.length; i++)&#123; str = str + numbers[i]; &#125; return str; &#125;&#125; 4. 数组中的逆序对问题描述 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 输入描述 题目保证输入的数组中没有的相同的数字 数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 解题思路归并排序法：二路归并即merge，是将两个有序的序列合并为一个有序的序列，在两个子序列left、right合并过程中，当left中当前元素A小于right中当前元素B时，因为right序列已经有序，所以不用比较，A一定是left、right两个子序列当前剩余元素中最小的元素，这省去了A与B后其他元素比较的操作。 对于本题，在两个子序列left、right合并过程中，当left中当前元素A大于right中当前元素B时，因为left序列已经有序，所以不用比较，B一定小于left序列当前所有剩余元素，其全部可以与B组成逆序对，即通过一次比较可到一批逆序对，加速统计过程。 123456789101112131415161718192021222324252627282930313233343536373839404142 public class Solution &#123; private int num = 0; public int InversePairs(int [] array) &#123; if(array.length &lt;= 1)&#123; return 0; &#125; mergeSort(array, 0, array.length-1); return num; &#125; public void mergeSort(int[] array, int lo, int hi)&#123; if(lo &gt;= hi)&#123; return; &#125; int mid = lo + (hi - lo) / 2; mergeSort(array, lo, mid); mergeSort(array, mid+1, hi); merge(array, lo, mid, hi); &#125; public void merge(int[] array, int lo, int mid, int hi)&#123; int i=lo, j=mid+1, k=0; int[] temp = new int[hi-lo+1]; while(i&lt;=mid &amp;&amp; j&lt;=hi)&#123; if(array[i]&gt;array[j])&#123; temp[k++] = array[j++]; num += mid-i+1; num %= 1000000007; &#125;else&#123; temp[k++] = array[i++]; &#125; &#125; while(i &lt;= mid)&#123; temp[k++] = array[i++]; &#125; while(j &lt;= hi)&#123; temp[k++] = array[j++]; &#125; for(int l=0; l&lt;k; l++)&#123; array[lo+l] = temp[l]; &#125; &#125;&#125; 数学问题1. 统计1出现的次数题目描述 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 解题思路https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/ https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6?answerType=1&amp;f=discussion 2. 丑数题目描述 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 解题思路丑数能够分解成2^x3^y5^z, 所以只需要把得到的丑数不断地乘以2、3、5之后并放入他们应该放置的位置即可，而此题的难点就在于如何有序的放在合适的位置。1乘以 （2、3、5）=2、3、5；2乘以（2、3、5）=4、6、10；3乘以（2、3、5）=6,9,15；5乘以（2、3、5）=10、15、25；如果不加策略地添加丑数是会有重复并且无序，而在2x，3y，5z中，如果x=y=z那么最小丑数一定是乘以2的，但关键是有可能存在x》y》z的情况，所以我们要维持三个指针来记录当前乘以2、乘以3、乘以5的最小值，然后当其被选为新的最小值后，要把相应的指针+1；因为这个指针会逐渐遍历整个数组，因此最终数组中的每一个值都会被乘以2、乘以3、乘以5，也就是实现了我们最开始的想法，只不过不是同时成乘以2、3、5，而是在需要的时候乘以2、3、5. 123456789101112131415161718 import java.util.ArrayList;public class Solution &#123; public int GetUglyNumber_Solution(int index) &#123; if(index &lt;= 0) return 0; int p2=0, p3=0, p5=0; int[] result = new int[index]; result[0] = 1; for(int i=1; i&lt;index; i++)&#123; result[i] = Math.min(result[p2]*2, Math.min(result[p3]*3, result[p5]*5)); if(result[i] == result[p2]*2) p2++; if(result[i] == result[p3]*3) p3++; if(result[i] == result[p5]*5) p5++; &#125; return result[index-1]; &#125;&#125; 3. 和为S的两个数字题目描述 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 解题思路双指针法:因为数组是有序的，所以可以用双指针，指向数组的首尾，具体步骤如下： 1.初始化：指针i指向数组首，指针j指向数组尾部; 2. 如果arr[i] + arr[j] == sum , 说明是可能解; 3. 否则如果arr[i] + arr[j] &gt; sum, 说明和太大，所以--j; 4. 否则如果arr[i] + arr[j] &lt; sum, 说明和太小，所以++i. 123456789101112131415161718192021222324252627282930 import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if(array.length&lt;2)&#123; return ret; &#125; int min = Integer.MAX_VALUE; int i=0; int j=array.length-1; while(i&lt;j)&#123; int s = array[i] + array[j]; if(s &lt; sum)&#123; i++; &#125;else if(s &gt; sum)&#123; j--; &#125;else&#123; if(array[i]*array[j]&lt;min)&#123; ret.clear(); min=array[i]*array[j]; ret.add(array[i]); ret.add(array[j]); &#125; i++; &#125; &#125; return ret; &#125;&#125; 4. 和为S的连续正数序列题目描述 输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。 解题思路 方法一：暴力法 求和为sum的连续子序列，可用暴力方法，算法步骤： 1）用指针i枚举目标序列的左边界； 2）用指针j枚举目标序列的右边界； 3）用指针k枚举区间[i, j]，来计算区间和，看是否等于目标sum。 1234567891011121314151617181920212223242526 public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); for(int i=1; i&lt;=sum/2; i++)&#123; for(int j=i+1; j&lt;sum; j++)&#123; int tmp=0; for(int k=i; k&lt;=j; k++)&#123; tmp += k; &#125; if(tmp == sum)&#123; ArrayList&lt;Integer&gt; s = new ArrayList&lt;&gt;(); for(int k=i; k&lt;=j; k++)&#123; s.add(k); &#125; ret.add(s); &#125;else if(tmp &gt; sum)&#123; break; &#125; &#125; &#125; return ret; &#125;&#125; // 时间复杂度：O(N^3)// 空间复杂度：O(1) 方法二：前缀和 对于求一个区间和，一贯的优化技巧是使用前缀和。比如： sum[i]表示前i个数的和。比如sum[1] = 1,表示前一个数的和为1，sum[2] = 3, 表示前2个数的和为3. 现在我们要求区间[2,4]表示求第2,3,4个数的和，就等于sum[4] - sum[1] = 9。 代码中我们用一个变量来模拟这个前缀和。 12345678910111213141516171819202122232425 public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); int temp=0; for(int i=1; i&lt;=sum/2; i++)&#123; for(int j=i; j&lt;sum; j++)&#123; temp += j; if(temp==sum)&#123; ArrayList&lt;Integer&gt; s = new ArrayList&lt;&gt;(); for(int k=i; k&lt;=j; k++)&#123; s.add(k); &#125; ret.add(s); &#125;else if(temp &gt; sum)&#123; temp = 0; break; &#125; &#125; &#125; return ret; &#125;&#125; // 时间复杂度：O(N^2)// 空间复杂度：O(1) 方法三：滑动窗口 1. 什么是滑动窗口？ 顾名思义，首先是一个窗口，既然是一个窗口，就需要用窗口的左边界i和右边界j来唯一表示一个窗口， 其次，滑动代表，窗口始终从左往右移动，这也表明左边界i和右边界j始终会往后移动，而不会往左移动。 这里我用左闭右开区间来表示一个窗口。比如： 2. 滑动窗口的操作 * 扩大窗口，j += 1 * 缩小窗口，i += 1 算法步骤： 1）初始化，i=1,j=1, 表示窗口大小为0 2）如果窗口中值的和小于目标值sum， 表示需要扩大窗口，j += 1 3）否则，如果狂口值和大于目标值sum，表示需要缩小窗口，i += 1 4）否则，等于目标值，存结果，缩小窗口，继续进行步骤2,3,4 这里需要注意2个问题： *什么时候窗口终止呢，这里窗口左边界走到sum的一半即可终止，因为题目要求至少包含2个数 *什么时候需要扩大窗口和缩小窗口？解释可看上述算法步骤。 1234567891011121314151617181920212223242526272829 public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); int l=1; int r=1; int temp=0; while(l &lt;= sum/2)&#123; if(temp &lt; sum)&#123; temp += r; r++; &#125;else if(temp &gt; sum)&#123; temp -= l; l++; &#125;else&#123; ArrayList&lt;Integer&gt; s = new ArrayList&lt;&gt;(); for(int k=l; k&lt;r; k++)&#123; s.add(k); &#125; ret.add(s); temp -= l; l++; &#125; &#125; return ret; &#125;&#125; // 时间复杂度：O(N)// 空间复杂度：O(1)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-字符串问题]]></title>
    <url>%2F2020%2F06%2F07%2F%E5%89%91%E6%8C%87offer-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 字符串的排列题目描述 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 解题思路利用递归的思想，首先固定第一个字符，将剩余的部分看做一个新的字符串，递归的取得首位后面各种字符串的组合。再第一个字符串与后面的每一个字符串进行交换，同样递归的获得其字符串组合。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 import java.util.ArrayList;import java.util.Collections;// 使用数组public class Solution &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; ret = new ArrayList&lt;String&gt;(); if(str.length()==0 &amp;&amp; str==null)&#123; return ret; &#125; Permute(str.toCharArray(), 0, ret); Collections.sort(ret); return ret; &#125; public void Permute(char[] str, int i, ArrayList&lt;String&gt; ret)&#123; if(i == str.length - 1)&#123; if(!ret.contains(new String(str)))&#123; ret.add(new String(str)); &#125; &#125;else&#123; for(int j=i; j&lt;str.length; j++)&#123; swap(str, i, j); Permute(str, i+1, ret); swap(str, i, j); &#125; &#125; &#125; public void swap(char[] str, int i, int j)&#123; char temp = str[i]; str[i] = str[j]; str[j] = temp; &#125;&#125; // 使用StringBuffer public class Solution &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; ret = new ArrayList&lt;String&gt;(); if(str.length()==0 &amp;&amp; str==null)&#123; return ret; &#125; Permute(new StringBuffer(str), 0, ret); Collections.sort(ret); return ret; &#125; public void Permute(StringBuffer str, int i, ArrayList&lt;String&gt; ret)&#123; if(i == str.length() - 1)&#123; if(!ret.contains(str.toString()))&#123; ret.add(str.toString()); &#125; &#125;else&#123; for(int j=i; j&lt;str.length(); j++)&#123; swap(str, i, j); Permute(str, i+1, ret); swap(str, i, j); &#125; &#125; &#125; public void swap(StringBuffer str, int i, int j)&#123; char temp = str.charAt(i); str.setCharAt(i, str.charAt(j)); str.setCharAt(j, temp); &#125;&#125; // 算法时间复杂度： O(n!) // 空间复杂度：O(1) 2. 第一个只出现一次的字符题目描述 在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数） 解题思路遍历一遍字符串，统计每个字符出现的次数。然后再遍历一遍字符串，找出答案。 1234567891011121314151617181920212223242526272829303132333435363738394041 import java.util.HashMap;public class Solution &#123; public int FirstNotRepeatingChar(String str) &#123; if(str==null || str.length()==0)&#123; return -1; &#125; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0; i&lt;str.length(); i++)&#123; if(!map.keySet().contains(str.charAt(i)))&#123; map.put(str.charAt(i), 1); &#125;else&#123; map.put(str.charAt(i), map.get(str.charAt(i))+1); &#125; &#125; for(int i=0; i&lt;str.length(); i++)&#123; if(map.get(str.charAt(i))==1)&#123; return i; &#125; &#125; return -1; &#125;&#125;// ************** 使用数组实现 ************** public class Solution &#123; public int FirstNotRepeatingChar(String str) &#123; if(str==null || str.length()==0)&#123; return -1; &#125; int[] count = new int[128]; for(int i=0; i&lt;str.length(); i++)&#123; count[str.charAt(i)] ++; &#125; for(int i=0; i&lt;str.length(); i++)&#123; if(count[str.charAt(i)] == 1)&#123; return i; &#125; &#125; return -1; &#125;&#125; 3. 左旋转字符串题目描述 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。 解题思路123456789101112 public class Solution &#123; public String LeftRotateString(String str,int n) &#123; if(n &gt; str.length())&#123; return str; &#125; int k = n % str.length(); String s1 = str.substring(0, k); String s2 = str.substring(k); return s2+s1; &#125;&#125; 4. 翻转单词顺序列题目描述 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 解题思路 题目抽象：给定一个首尾可能带空格的字符串，请让你翻转该字符串。首尾不能有多余空格。如果全部是空格，请返回原字符串。 然后以空格为分割单元将单词分开并按正常顺序拼接。 12345678910111213141516171819202122232425262728 public class Solution &#123; public String ReverseSentence(String str) &#123; //判断str是否为空 if(str.isEmpty()) return str; //判断str中是否全为空格 int i=0, size=str.length(); while(i&lt;size &amp;&amp; str.charAt(i)==' ') i++; if(i == size) return str; String ret = ""; String tmp = ""; boolean hasstr = false; for(i=size-1; i&gt;=0; i--)&#123; char c = str.charAt(i); if(c != ' ')&#123; tmp = c + tmp; hasstr = true; &#125;else if(c==' ' &amp;&amp; hasstr)&#123; ret = ret + tmp + " "; tmp = ""; hasstr = false; &#125; &#125; if(tmp != "") ret = ret + tmp; return ret; &#125;&#125; 5. 扑克牌顺子题目描述 LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 解题思路12345678910111213141516171819202122232425import java.util.Arrays;public class Solution &#123; public boolean isContinuous(int [] numbers) &#123; if(numbers.length == 0) return false; Arrays.sort(numbers); int zeor_num = 0; int gap = 0; for(int i=0; i&lt;numbers.length-1; i++)&#123; if(numbers[i] == 0)&#123; zeor_num += 1; continue; &#125; if(numbers[i+1] == numbers[i]) return false; int g = numbers[i+1]-numbers[i]; if(g &gt; 1) gap = gap + g - 1; &#125; if(zeor_num &gt;= gap)&#123; return true; &#125; return false; &#125;&#125; 6. 把字符串转换成整数题目描述将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 输入描述 输入一个字符串,包括数字字母符号,可以为空 输出描述 如果是合法的数值表达则返回该数字，否则返回0 解题思路这道题难点在于边界的考察。对于一般规则的数字“字符串”转化为数字如下： int的范围为[2^31-1, -2^31]如果超过了这两个范围该怎么办？其实也很简单，首先判断这个数的正负，如果正数，超过了Integer.MAX_VALUE，就设置Integer.MAX_VALUE，如果是负数，首先我们不考虑负号，如果超过了Integer.MAX_VALUE, 则就置为Integer.MAX_VALUE+1, 最后再根据正负号，来加负号。 123456789101112131415161718192021222324252627282930313233343536 public class Solution &#123; public int StrToInt(String str) &#123; if(str == null || "".equals(str.trim()))&#123; return 0; &#125; int l = str.length(); //if(l == 0) return 0; int i = 0; int ret = 0; int flag = 1; char[] arr = str.toCharArray(); if(arr[i] == '-')&#123; flag = -1; &#125; if(arr[i] == '+' || arr[i] == '-')&#123; i++; &#125; while(i &lt; l)&#123; if(arr[i] &gt;= '0' &amp;&amp; arr[i] &lt;= '9')&#123; int cur = arr[i] - '0'; if(flag==1 &amp;&amp; (ret&gt;Integer.MAX_VALUE/10 || (ret==Integer.MIN_VALUE/10 &amp;&amp; cur &gt; 7)))&#123; return 0; &#125; if(flag==-1 &amp;&amp; (ret&gt;Integer.MAX_VALUE/10 || (ret==Integer.MIN_VALUE/10 &amp;&amp; cur &gt; 8)))&#123; return 0; &#125; ret = ret * 10 + cur; i++; &#125;else&#123; return 0; &#125; &#125; return ret * flag; &#125;&#125; 7. 正则表达式匹配题目描述请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 解题思路 12345678910111213141516171819202122232425 public class Solution &#123; public class Solution &#123; public boolean match(char[] str, char[] pattern)&#123; boolean flag = imatch(str, pattern, 0, 0); return flag; &#125; public boolean imatch(char[] str, char[] pattern, int s, int p)&#123; if(s==str.length &amp;&amp; p==pattern.length) return true; if(s&lt;str.length &amp;&amp; p&gt;=pattern.length) return false; if(p+1 &lt; pattern.length &amp;&amp; pattern[p+1]=='*')&#123; if((s &lt; str.length &amp;&amp; pattern[p] == '.') || (s &lt; str.length &amp;&amp; str[s] == pattern[p]))&#123; return imatch(str, pattern, s, p+2) || imatch(str, pattern, s+1, p); &#125;else&#123; return imatch(str,pattern, s, p+2); &#125; &#125; if(s &lt; str.length &amp;&amp; (str[s] == pattern[p] || pattern[p] == '.'))&#123; return imatch(str, pattern, s+1, p+1); &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法-树结构总结]]></title>
    <url>%2F2020%2F06%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[“树”是数据结构中常见的非线性存储结构。在“树”结构中有一些常用的术语，总结为下： 父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点。 子节点：一个节点含有的子树的根节点称为该节点的子节点。 兄弟节点：拥有共同父节点的节点互称为兄弟节点。 度：节点的子树数目就是节点的度。 叶子节点：度为零的节点就是叶子节点。 节点的层次：从根节点开始，根节点为第一层，根的子节点为第二层，以此类推。 节点深度：对任意节点x，x节点的深度表示为根节点到x节点的路径长度。例如：根节点深度为0，第二层节点深度为1，以此类推。 “根节点—&gt;节点的路径长度” 节点高度：对任意节点x，叶子节点到x节点的路径长度就是节点x的高度。 “节点—&gt;叶子节点的路径长度” 树的深度：一棵树中节点的最大深度就是树的深度，也称为高度。 数据结构中有很多种树结构：二叉树，二叉搜索树， 红黑树，B+树等，下面对常见的几种树结构的的定义以及用途进行简单的介绍。 1. 二叉树 二叉树的定义：二叉树的每个结点最多只有二棵子树(不存在度大于2的结点)的树结构。每个节点有左右两个子节点。 二叉树示例： 满二叉树 和 完全二叉树： 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。即除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点都在同一层上。 完全二叉树：对于一颗二叉树，假设其深度为d（d&gt;1）。除第d层外的所有节点构成满二叉树，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树 示例： 判断一颗二叉树是否为完全二叉树 思路：利用层序遍历，如果我们当前遍历到了NULL结点，如果后续还有非NULL结点，说明是非完全二叉树 123456789101112131415161718192021222324252627 public isBCT(TreeNode root)&#123; if(root==null)&#123; return true; &#125; Queue&lt;TreeNode&gt; q = new Queue&lt;TreeNode&gt;(); boolean leaf = false; q.push(root); while(q!=null)&#123; node = q.pop(); //如果已经碰到叶子结点，判断之后是否遇到非叶子节点 if((leaf&amp;&amp;(node.left!=null||node.right!=null))||(node.left==null&amp;&amp;node.right!=null))&#123; return false; &#125; if（node.left!=null)&#123; q.push(node.left); &#125; if(node.right!=null)&#123; q.push(node.right); &#125; //判断是否为叶子节点 if((node.left!=null&amp;&amp;node.right==null)||(node.left==null&amp;&amp;node.right==null))&#123; leaf=true; &#125; &#125; reurn true;&#125; 二叉树的性质： 在非空二叉树中，第i层的结点总数不超过2i-1, i&gt;=1; 深度为d的二叉树最多有2d-1个结点(d&gt;=1)，最少有d个结点; 具有n个结点的完全二叉树的深度为log2(n+1)； 2. 二叉查找树（二叉搜索树、二叉排序树、BST） 二叉查找树定义:二叉查找树又称二叉搜索树、二叉排序树、BST. 它是具有以下性质的二叉树： 若左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值； 左、右子树也分别为二叉排序树； 没有键值相等的节点。 示例左边的是BST，右边的不是： 判断一颗二叉树是否为BST树 思路：根据二叉查找树的性质我们可以知道：如果我们用中序遍历遍历二叉查找树的话，遍历到的每个节点是依次增大的。根据这个思路，我们可以遍历一遍树，将遍历到的值保存到数组中，然后再判断这个数组是否为递增数组就可以了 1234567891011121314151617181920//递归实现 int last = Integer.MIN_VALUE;public isBST(TreeNode root)&#123; if(root==null)&#123; return true; &#125; if(!isBST(root.left))&#123; return false; &#125; if(root.val &lt;= last)&#123; return false; &#125; last = root.val; if(!isBST(root.right))&#123; return false; &#125; return true;&#125; //非递归实现 对二叉查找树进行中序遍历，即可得到有序的数列。 它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。 二叉查找树的高度决定了二叉查找树的查找效率。 3. 二叉树的操作 二叉树的遍历 二叉树有三种遍历方式： 先序遍历：先访问根节点，再前序遍历左子树，最后前序遍历右子树。 中序遍历：先中序访问左子树，再访问根节点，再中序访问右子树。中序遍历得到一个有序（递增）的数列。 后序遍历：先后序访问左子树，再后序访问右子树，再访问根节点。 递归实现 12345678910111213141516171819202122232425262728 // 二叉树的定义public class TreeNode&#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val)&#123; this.val = val; &#125;&#125; // 先序遍历 (根节点-&gt;左子树-&gt;右子树)public void PreOrderTraversal(TreeNode root)&#123; System.out.println(root.val); PreOrderTraversal(root.left); PreOrderTraversal(root.right);&#125; // 中序遍历 （左子树-&gt;根节点-&gt;右子树）public void InOrderTraversal(TreeNode root)&#123; InOrderTraversal(root.left); System.out.println(root.val); InOrderTraversal(root.right);&#125; // 后序遍历 (左子树-&gt;右子树-&gt;根节点)public void PostOrderTraversal(TreeNode root)&#123; PostOrderTraversal(root.left); PostOrderTraversal(root.right); System.out.println(root.val);&#125; 非递归实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 // 二叉树的定义public class TreeNode&#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val)&#123; this.val = val; &#125;&#125; // 先序遍历 (根节点-&gt;左子树-&gt;右子树)public void PreOrderTraversal(TreeNode root)&#123; LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;(); while(!stack.isEmpty() || root!=null)&#123; if(root!=null)&#123; System.out.println(root.val); stack.push(root); root = root.left; &#125;else&#123; root = root.pop(); root = root.right; &#125; &#125;&#125; // 中序遍历 （左子树-&gt;根节点-&gt;右子树）public void InOrderTraversal(TreeNode root)&#123; LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;(); while(!stack.isEmpty() || root!=null)&#123; if(root!=null)&#123; stack.push(root); root = root.left; &#125;else&#123; root = root.pop(); System.out.println(root.val); root = root.right; &#125; &#125;&#125; // 后序遍历 (左子树-&gt;右子树-&gt;根节点)public void PostOrderTraversal(TreeNode root)&#123; LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); TreeNode tmp; while(!stack.isEmpty() || root!=null)&#123; if(root!=null)&#123; stack.push(root.val); map.put(root.val, 1); root = root.left; &#125;else&#123; tmp=stack.getFirst(); if(map.get(tmp.val)==2)&#123; stack.pop(); System.out.println(tmp.val); root=null; &#125;else&#123; map.put(tmp.val, 2); root = tmp.right; &#125; &#125; &#125;&#125; 参考博客：https://www.cnblogs.com/bigsai/p/11393609.htmlhttps://www.cnblogs.com/hapjin/p/5679482.html 二叉树的层级遍历 二叉树的层级遍历需要借助一个队列(queue)来保存当前节点的子节点。 1. 初始化：一个队列queue，将root节点入队列q 2. 如果队列不空，做如下操作： 3. 弹出队列头，保存为node，将node的左右非空孩子加入队列 4. 重复2,3步骤，直到队列为空 以上图左子图为例： 1. 创建空队列q=[]; 2. 将根节点6入队列，q=[6]; 3. 队列不空，取出队列中头元素6，若6节点左右子节点不空，入队，q=[2,8]; 4. 队列不空，取出头元素2，将节点2的左右子节点入队，q=[8,1,4]; 5. 重复上述步骤，直到队列为空。 123456789101112131415161718192021222324252627282930 import java.util.Queue;import java.util.LinkedList;import java.util.ArrayList;public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public int TreeDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; ArrayList&lt;TreeNode&gt; ret = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;(); q.add(root); while(q.size()!=0)&#123; TreeNode node = q.poll(); ret.add(node); if(node.left != null)&#123; q.add(node.left); &#125; if(node.right != null)&#123; q.add(node.right); &#125; &#125; &#125; 若需记录树的深度或有几层，可作如下改进： 1234567891011121314151617181920212223242526272829303132333435363738 //递归方法 public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root == null)return 0; int ld = TreeDepth(root.left); int rd = TreeDepth(root.right); return Math.max(ld,rd) + 1; &#125;&#125; //非递归方法 public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;(); q.add(root); int level = 0; int size; TreeNode node; while(q.size()!=0)&#123; size = q.size(); while(size != 0)&#123; node = q.poll(); if(node.left != null)&#123; q.add(node.left); &#125; if(node.right != null)&#123; q.add(node.right); &#125; size--; &#125; level++; &#125; return level; &#125;&#125; 二叉查找树插入节点操作 二叉查找树的插入过程如下： 1) 若当前的二叉查找树为空，则插入的元素为根节点; 2) 若插入的元素值小于根节点值，则将元素插入到左子树中; 3) 若插入的元素值不小于根节点值，则将元素插入到右子树中。 二叉查找树删除节点操作 二叉查找树的删除，分三种情况进行处理： 1）p为叶子节点，直接删除该节点，再修改其父节点的指针（注意分是根节点和不是根节点），如图a; 2）p为单支节点（即只有左子树或右子树）。让p的子树与p的父亲节点相连，删除p即可（注意分是根节点和不是根节点），如图b; 3）p的左子树和右子树均不空。找到p的后继y，y为这个节点右子树的最小值或者左子树的最大值。 如图c。 4. 平衡二叉树对于一般的二叉搜索树，其期望高度（即为一棵平衡树时）为log2n，其各操作的时间复杂度O(log2n)同时也由此而决定。但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即O(n)。我们可以通过随机化建立二叉搜索树来尽量的避免这种情况，但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。于是就有了我们下边介绍的平衡二叉树。 平衡二叉树（Balanced Binary Tree）：又被称为AVL树（有别于AVL算法），且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 并且平衡二叉树必定是二叉搜索树。平衡二叉树的常用算法有红黑树、AVL树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。 最小二叉平衡树的节点的公式为：F(n)=F(n-1)+F(n-2)+1这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。 判断一颗二叉树是不是平衡二插树1234567891011121314151617 public class Solution &#123; public boolean IsBalanced_Solution(TreeNode root) &#123; return depth(root) != -1; &#125; public int depth(TreeNode root)&#123; if(root == null)return 0; int left = depth(root.left); if(left == -1)return -1; //如果发现子树不平衡之后就没有必要进行下面的高度的求解了 int right = depth(root.right); if(right == -1)return -1;//如果发现子树不平衡之后就没有必要进行下面的高度的求解了 if(left - right &lt;(-1) || left - right &gt; 1) return -1; else return 1+(left &gt; right?left:right); &#125;&#125; AVL树的查找、插入和删除在平均和最坏情况下都是O(logn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。 AVL树平衡操作：https://blog.csdn.net/qq_25343557/article/details/89110319https://www.cnblogs.com/zhuwbox/p/3636783.html 5. 红黑树红黑树的定义：红黑树是一种自平衡二叉查找树。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。 红黑树与AVL树的区别： 区别： 1）红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。 2）平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。 共同点： 进行插入或者删除是都是需要进行一定的平衡操作的。 红黑树的性质： 红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制的一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求: 性质1. 节点是红色或黑色。 性质2. 根是黑色。 性质3. 所有叶子都是黑色（叶子是NIL节点）。 性质4. 每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。) 性质5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。 参考： 书籍《算法 第四版》 https://www.cnblogs.com/maybe2030/p/4732377.htmlhttps://blog.csdn.net/u014532217/article/details/79118023https://blog.csdn.net/qq_31709249/article/details/103092783]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-String Problem]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-String%20problem%2F</url>
    <content type="text"><![CDATA[Longest Substring Without Repeating CharactersDescription Given a string, find the length of the longest substring without repeating character. example Input: &quot;abcabcbb&quot; Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. solution1. 方法一：暴力法 检查每一个子字符串是否有重复的字符12345678910111213141516171819public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); int ans = 0; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt;= n; j++) if (allUnique(s, i, j)) ans = Math.max(ans, j - i); return ans; &#125; public boolean allUnique(String s, int start, int end) &#123; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (int i = start; i &lt; end; i++) &#123; Character ch = s.charAt(i); if (set.contains(ch)) return false; set.add(ch); &#125; return true; &#125;&#125; 算法分析：时间复杂度：O(n3)；空间复杂度：O(min(m,n)) 2. 方法二：滑动窗口 滑动窗口经常用在数组和字符串的问题中，滑动窗口是数组和字符串中的一些元素，它用两个索引来表示滑动窗口的起始位置[i,j),滑动窗口通过滑动左右的两个索引来改变滑动窗口滑动的方向以及窗口内的元素. 本题用HashSet来存储现在的滑动窗口内的元素[i,j),通过检查第j个元素，如果不在集合中就存储到集合并继续增加滑动窗口右侧可值j，如果第j个元素已经在集合中了，那么就滑动左侧的索引i，从集合中删除第i个元素，直到此时第j个元素不在集合中了。 代码实现12345678910111213141516171819 public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int ans = 0, i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; n) &#123; // try to extend the range [i, j] if (!set.contains(s.charAt(j)))&#123; set.add(s.charAt(j++)); ans = Math.max(ans, j - i); &#125; else &#123; set.remove(s.charAt(i++)); &#125; &#125; return ans; &#125;&#125; 算法分析：时间复杂度：O(2n)=O(n) 3. 方法三:滑动窗口的优化 利用HashMap来代替HashSet123456789101112131415class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n=s.length(); int maxn=0; Map&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(); for(int i=0,j=0;j&lt;n;j++)&#123; if(map.contains(s.charAt(j)))&#123; i=Math.max(map.get(s.charAt(j)),i); &#125; amxn=Math.max(maxn,j-i+1); map.put(s.charAt(j),j+1); &#125; return maxn; &#125;&#125; 算法分析：时间复杂度O(n) Longest Palindromic Substring 回文字符串：正读反读都一样 1.方法一：暴力法 遍历所有的子字符串，判断它是不是回文字符串 1234567891011121314151617181920212223242526272829303132333435363738 class Solution &#123; public String longestPalindrome(String s) &#123; if(s.length()==1)&#123; return s; &#125; if(s.isEmpty())&#123; return ""; &#125; int maxn=0; int iMin=0; //遍历每个子字符串并判断是不是回文的 for(int i=0;i&lt;s.length();i++)&#123; for(int j=s.length()-1;j&gt;=i;j--) if(s.charAt(i)==s.charAt(j))&#123; if(check(s,i,j))&#123; if(j-i+1&gt;maxn)&#123; maxn=j-i+1; iMin=i; &#125; break; &#125; &#125; &#125; return s.substring(iMin,maxn); &#125; //检测一个字符串是不是回文 public boolean check(String s,int i,int j)&#123; while(i&lt;=j)&#123; if(s.charAt(i)!=s.charAt(j))&#123; return false; &#125; i++; j--; &#125; return true; &#125;&#125; 算法分析： 时间复杂度O(n^3) 2. 方法二：动态规划 暴力法时间复杂度高的原因是去检查每一个子字符串是不是回文的，降低时间复杂度就要减少对子字符串是不是回文的判断 假设一个字符串”ababa”,当我已经确认了”bab”是回文字符串，由于它左右两边的字符都是a，那么这个完整的字符串本身就是回文的，就可以不用对整个字符串再进行完整的判断。 假设一个字符串的长度为n，那么建立一个n*n数组P。在矩阵中P[i][j]=l，若l&gt;0：表示以字符S[i]开始和以S[j]结尾的字符串是回文字符串，字符串的长度为l;若l=0，表示此字符串不是回文字符串 只需要对矩阵中j&gt;=i的部分赋值即可，就j&lt;i部分为0； 1.一个字符的情况：将矩阵的对角线赋值为1，因为每个字符本身是回文的 2.两个字符的情况：j-i=1 P[i][j]=2,if S[i]=S[j] 3.多个字符的情况：j-i&gt;=2 if S[i]!=S[j] P[i][j]=0; if S[i]=S[j] if P[i+1][j-1]&gt;0 P[i][j]=p[i+1][j-1]+2; else P[i][j]=0; 字符串有多个字符组成时，如果两边的字符相等，那么这个字符串可能是回文的，这时将字符串去掉首末字符得到子字符串，如果子字符串回文的，那么这个字符串也是回文的。 12345678910111213141516171819202122232425262728293031323334353637383940 public static String longestPalindrome(String s)&#123; if(s.length()==0)&#123; return ""; &#125; if(s.length()==1)&#123; return s; &#125; int[][] p=new int[s.length()][s.length()]; int indexMin=0,maxn=1; //初始化二维数组P for(int i=0;i&lt;s.length();i++)&#123; for(int j=0;j&lt;s.length();j++)&#123; if(i==j) p[i][j]=1; &#125; &#125; for(int j=0;j&lt;s.length();j++)&#123; for(int i=j-1;i&gt;=0;i--)&#123; if(s.charAt(i)==s.charAt(j))&#123; if(j-i==1)&#123; p[i][j]=2; &#125; if(j-i&gt;=2)&#123; if(p[i+1][j-1]&gt;0)&#123; p[i][j]=p[i+1][j-1]+2; &#125;else&#123; p[i][j]=0; &#125; &#125; &#125;else&#123; p[i][j]=0; &#125; if(p[i][j]&gt;maxn)&#123; maxn=p[i][j]; indexMin=i; &#125; &#125; &#125; return s.substring(indexMin, indexMin+maxn);&#125; 算法分析： 时间复杂度：O(n^2) 空间复杂度：O(n^2)需要一个n*n的矩阵来存储数据 3.方法三：Expand Around Center 对于动态规划算法时间复杂度为O(n^2)，空间复杂度为O(n^2)，可以进一步优化只用O(1)的空间实现O(n^2)的时间复杂度 一个回文字符串它是成中心对称的，比如”baab”,”bab”,但是回文字符串分为两种：奇数字符数，偶数字符数 1234567891011121314151617181920212223242526272829 class Solution &#123; public String longestPalindrome(String s) &#123; if(s.length()==0)&#123; return ""; &#125; if(s.length()==1)&#123; return s; &#125; int indexMin=0,maxn=1; for(int i=0;i&lt;s.length();i++)&#123; int len1=expandAroundCenter(s,i,i); int len2=expandAroundCenter(s,i,i+1); int len=Math.max(len1,len2); if(len&gt;maxn)&#123; indexMin=i-(len-1)/2; maxn=len; &#125; &#125; return s.substring(indexMin,indexMin+maxn); &#125; private int expandAroundCenter(String s,int L,int R)&#123; while(L&gt;=0 &amp;&amp; R&lt;s.length() &amp;&amp; s.charAt(L)==s.charAt(R))&#123; L--; R++; &#125; return R-L-1; &#125; &#125; 算法分析 时间复杂度：O(n^2) 空间复杂苏：O(1) 4.方法四：最长公共字符串 将字符串S翻转为S’,检查S和S’的最长公共字符串就是S的最长回文子字符串此方法中存在一种问题，就是当字符串中某一个子串存在一个镜像子串本身并不是回文的，翻转之后会被检测为回文的。 Longest Common Substring 最长公共子字符串 动态规划问题 动态规划问题的两个特点： 1.最优子结构 2.重叠子问题 因为有重叠子问题，当前计算的过程中可能有的问题在之前的计算已经计算过了，现在又要计算一遍，导致大量重复的计算动态规划通过找到解决问题的递推关系，将已经完成计算的存储起来，当开始新的计算时如果包含之前计算的子问题时，不需要再次计算，只需要访问已经存储的计算结果就可以动态规划解决问题的方法一般减少了时间复杂度，增加了存储空间。 对于这个问题，假设有两个字符串s[0,…m],t[0,…,n],求两个字符串的最长公共子字符串定义矩阵mXn的矩阵L,L[i][j]表示以s[i]开始和t[j]结尾的公共子字符串长度的最大值，那么对于L[i+1][j+1]只是比L[i][j]增加了s[i+1]和t[j+1] 因此可以构造出最长公共子字符串的递归式： if s[i]==t[j] L[i][j]=L[i-1][j-1]+1 if s[i]!=t[j] L[i][j]=0 假设有两个字符串：”ABAB”和”BABA” ,构造出了上述的矩阵代码实现123456789101112131415161718192021222324 public static String LCS(String s1,String s2)&#123; if(s1.isEmpty() || s2.isEmpty())&#123; return ""; &#125; int indexMax=0,maxn=0; int[][] L=new int[s1.length()][s2.length()]; for(int i=0;i&lt;s1.length();i++)&#123; for(int j=0;j&lt;s2.length();j++)&#123; if(s1.charAt(i)==s2.charAt(j))&#123; if(i==0 || j==0)&#123; L[i][j]=1; &#125;else&#123; L[i][j]=L[i-1][j-1]+1; &#125; &#125; if(L[i][j]&gt;maxn)&#123; maxn=L[i][j]; indexMax=i; &#125; &#125; &#125; return s1.substring(indexMax+1-maxn, indexMax+1);&#125; 算法分析： 时间复杂度：O(m*n) 空间复杂度：O(m*n) 算法优化 从上面动态查找最长公共子字符串的过程中发现，在循环查找的过程中只会用到矩阵L中的两行，即正在计算的一行和完成计算的上一行，之前计算的和带计算的都用不到，所以只需要维护两行数据就足够了，不需要使用mxn的数组 代码实现：123456789101112131415161718192021222324252627282930 public class LCS_improve &#123; public static String LCS_improve(String s1,String s2)&#123; if(s1.isEmpty() || s2.isEmpty())&#123; return ""; &#125; int indexMax=0,maxn=0; int [][] L=new int[2][s1.length()]; for(int i=0;i&lt;s1.length();i++)&#123; int cur=(i+2)%2; int pre=(i+1)%2; for(int j=0;j&lt;s2.length();j++)&#123; if(s1.charAt(i)==s2.charAt(j))&#123; if(i==0 || j==0)&#123; L[cur][j]=1; &#125;else&#123; L[cur][j]=L[pre][j-1]+1; &#125; &#125;else&#123; L[cur][j]=0; &#125; if(L[cur][j]&gt;maxn)&#123; maxn=L[cur][j]; indexMax=i; &#125; &#125; &#125; return s1.substring(indexMax+1-maxn, indexMax+1); &#125;&#125; 算法分析时间复杂度：O(mn)空间复杂度：O(min(m,n)) Longest Common PrefixDescription Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “” Example Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] Output: &quot;fl&quot; Solution 1. 方法一：横向比较 这是一种迭代的方法，假设字符串数组的长度为n，先将第一个字符串和第二个字符串比较得到最长公共前缀prefix，再将得到的prefix和第三个字符串比较得到新的prefix，依次向后比较，直到最后一个字符串。如果比较的过程中有prefix为空时，直接返回” “,LCP(S1,S2,.....,SN)=LCP(LCP(LCP(S1,S2),S3),.....SN)。 public String longestCommonPrefix(String[] strs) { if (strs.length == 0) return ""; String prefix = strs[0]; for (int i = 1; i &lt; strs.length; i++) while (strs[i].indexOf(prefix) != 0) { prefix = prefix.substring(0, prefix.length() - 1); if (prefix.isEmpty()) return ""; } return prefix; } 算法分析时间复杂度：在最坏的情况下为O(S),S为字符串数组中所有字符的总数空间复杂度：O(1) 2. 方法二：纵向比较 横向比较需要从第一个字符串比较到最后一个，如果数组中最短的字符串再最后的位置，那么在整个算法执行的过程中会有很多不必要的比较运算，增加了时间复杂度。因此采用纵向的比较，以最短字符串的长度l为标准，最多只比较到每个字符串的l位。从所有字符串的第一个字符开始比较，对位比较所有的字符串，直到在某一位的字符不相同或者已经到了最短的字符串的末尾字符，就结束运算。 public class Longest_Common_Prefix { public String longestCommonPrefix(String[] strs) { if(strs.length == 0) { return ""; } for(int i=0;i&lt;strs[0].length();i++) { char t = strs[0].charAt(i); for(int j=1;j&lt;strs.length;j++) { if(i == strs[j].length() || strs[j].charAt(i) != t) { return strs[0].substring(0, i); } } } return strs[0]; } } 算法分析时间复杂度：最坏情况下(所有字符串相同)O(S),一般情况下n*min(Si)空间复杂度：O(1) 3. 方法三：分而治之 将字符数组分为两组，分别对两组查找最长公共前缀sl,sr，最后再计算sl和sr的公共前缀。 public class Longest_Common_Prefix { //分而治之的方法 public String longestCommonPrefix(String[] strs) { if(strs.length==0) { return ""; } return longestCommonPrefix(strs,0,strs.length-1); } private String longestCommonPrefix(String[] strs,int l,int r) { if(l==r) { return strs[l]; } int mid = (l+r)/2; String lcpLeft=longestCommonPrefix(strs,l,mid); String lcpRight=longestCommonPrefix(strs,mid+1,r); return commonPrefix(lcpLeft,lcpRight); } private String commonPrefix(String s1,String s2) { int len=Math.min(s1.length(), s2.length()); for(int i=0;i&lt;len;i++) { if(s1.charAt(i) != s2.charAt(i)) { return s1.substring(0, i); } } return s1.substring(0,len); } } 算法分析时间复杂度：最坏情况下为O(S),(S=mn,m为每个字符串的长度，n为字符串的个数)空间复杂度：O(mlogn),算法logn次的递归调用，每次都需要m个存储空间 4. 方法四：二分法 首先找到字符串数组中最短字符串的长度minLen,它也是公共前缀的最大的长度，那么查找最长公共前缀的范围就缩小到每个字符串[0,minLen]之间。 将查找范围分为等长的两部分，[0,mid]和[mid+1,minLen]，取第一个字符串的前半部分的子字符串substr1 = str1.subString(0,mid),去和其他的字符串比较判断substr1是不是公共前缀，这时会有两种情况： 如果substr1是公共前缀，那么就将substr1增加判断更长的子字符串是不是公共前缀 如果substr1不是公共前缀，那么对于长度大于substr1的字符串都不是公共前缀，这时减小substr1去判断更小的子字符串是不是公共前缀 class Solution { public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return ""; int minLen = Integer.MAX_VALUE; for (String str : strs) minLen = Math.min(minLen, str.length()); int low = 1; int high = minLen; while (low &lt;= high) { int middle = (low + high) / 2; if (isCommonPrefix(strs, middle)) low = middle + 1; else high = middle - 1; } return strs[0].substring(0, (low + high) / 2); } private boolean isCommonPrefix(String[] strs, int len){ String str1 = strs[0].substring(0,len); for (int i = 1; i &lt; strs.length; i++) if (!strs[i].startsWith(str1)) return false; return true; } } 算法分析时间复杂度：O(S * logn)空间复杂度：O(1) Valid ParenthesesDescription Given a string containing just the characters &apos;(&apos;, &apos;)&apos;, &apos;{&apos;, &apos;}&apos;, &apos;[&apos; and &apos;]&apos;, determine if the input string is valid. An input string is valid if: 1.Open brackets must be closed by the same type of brackets. 2.Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example Example 1: Input: &quot;()&quot; Output: true Example 2: Input: &quot;()[]{}&quot; Output: true Example 3: Input: &quot;(]&quot; Output: false Example 4: Input: &quot;([)]&quot; Output: false Example 5: Input: &quot;{[]}&quot; Output: true Solution 方法概述-堆栈法 对于一个有效的字符表达式，字符串中的括号都是成对出现的。正如题中所说，打开的括号必须有相同形式的关闭括号，并且所有打开的括号必须以正确的顺序关闭。 从起始位置开始检查字符串，如果第一个字符是关闭字符，那么这个字符串一定不是有效的；如果第一个是某种打开字符，将它压入堆栈 stack.push(char c)，每遇到一个打开字符就做相同的操作；如果遍历字符串中遇到的关闭字符，看栈顶的字符是不是和此关闭字符相匹配的打开字符，如果是，将字符出栈并继续遍历，如果不是，那么就不是有效的字符串；顺利遍历完整个字符串时，检查栈是否为空，如果是空，那么字符串时有效的，否则无效。 class Solution { public boolean isValid(String s) { if(s.isEmpty()) { return true; } char[] stack = new char[s.length()]; int top = 0; for(int i=0;i&lt;s.length();i++) { char c = s.charAt(i); if(c=='{' || c=='[' || c=='(') { stack[top++] = c; } if(c=='}') { if(top==0 || stack[--top]!='{') { return false; } } if(c==']') { if(top==0 || stack[--top]!='[') { return false; } } if(c==')') { if(top==0 || stack[--top]!='(') { return false; } } } return top==0; } } Generate ParenthesesDescription Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. Example given n = 3, a solution set is: [ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot; ] Solution 方法一：暴力法 方法概述：产生所有可能的字符串，检查每个字符串是不是有效形式。 public class Generate_Parentheses { public List&lt;String&gt; generateParentheses(int n){ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); generateAll(new char[2*n],0,list); return list; } private void generateAll(char[] current,int index,List&lt;String&gt; result) { if(index == current.length) { if(valid(current)) { result.add(new String(current)); } }else { current[index] = '('; generateAll(current,index+1,result); current[index] = ')'; generateAll(current,index+1,result); } } private boolean valid(char[] current) { int flag=0; for(char c:current) { if(c == '(') flag++; else flag--; if(flag&lt;0) return false; } return (flag==0); } } 算法分析 时间复杂度：O(n*2^2n) 空间复杂度：O(n*2^2n) 方法二： 回溯算法 方法概述：回溯算法相当于穷举法(通用解法的美称)，性能一般不太理想，但某些情况和穷举法相比性能也有显著的提升，和穷举法不同的是回溯法设置一些条件过滤了一些不可能的情况，回溯法一般用递归来解决 public class Generate_Parentheses { //回溯法 public List&lt;String&gt; generateParentheses(int n){ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); backtrack(list,"",0,0,n); return list; } private void backtrack(List&lt;String&gt; list,String s,int open,int close,int max) { if(s.length() == 2*max) { list.add(s); return; } if(open&lt;max) { backtrack(list,s+'(',open+1,close,max); } if(close&lt;open) { backtrack(list,s+')',open,close+1,max); } } } 算法分析 时间复杂度：O(4^n/n^1/2) 空间复杂度：O(4^n/n^1/2) Longest Valid Parentheses(32-Hard)Description Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring. Example Example 1: Input: &quot;(()&quot; Output: 2 Explanation: The longest valid parentheses substring is &quot;()&quot; Example 2: Input: &quot;)()())&quot; Output: 4 Explanation: The longest valid parentheses substring is &quot;()()&quot; Solution Approach 1. Dynamic Programming public class Solution { public int longestValidParentheses(String s) { int maxans = 0; int dp[] = new int[s.length()]; for (int i = 1; i &lt; s.length(); i++) { if (s.charAt(i) == ')') { if (s.charAt(i - 1) == '(') { dp[i] = (i &gt;= 2 ? dp[i - 2] : 0) + 2; } else if (i - dp[i - 1] &gt; 0 &amp;&amp; s.charAt(i - dp[i - 1] - 1) == '(') { dp[i] = dp[i - 1] + ((i - dp[i - 1]) &gt;= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2; } maxans = Math.max(maxans, dp[i]); } } return maxans; } } Approach 2. Using Stack public class Solution { public int longestValidParentheses(String s) { int maxans = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(-1); for (int i = 0; i &lt; s.length(); i++) { if (s.charAt(i) == '(') { stack.push(i); } else { stack.pop(); if (stack.empty()) { stack.push(i); } else { maxans = Math.max(maxans, i - stack.peek()); } } } return maxans; } } Approach 3. Without extra space class Solution { public int longestValidParentheses(String s) { int left = 0, right = 0, maxlength = 0; for (int i = 0; i &lt; s.length(); i++) { if (s.charAt(i) == '(') { left++; } else { right++; } if (left == right) { maxlength = Math.max(maxlength, 2 * right); }else if (right &gt;= left) { left = right = 0; } } left = right = 0; for (int i = s.length() - 1; i &gt;= 0; i--) { if (s.charAt(i) == '(') { left++; } else { right++; } if (left == right) { maxlength = Math.max(maxlength, 2 * left); } else if (left &gt;= right) { left = right = 0; } } return maxlength; } } Substring with Concatenation of All WordsDescription You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example Input: s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively. The output order does not matter, returning [9,0] is fine too. Solution Code public class SubstringIndexOfAllWords { public List&lt;Integer&gt; findSubString(String s, String[] words){ List&lt;Integer&gt; indexs = new ArrayList&lt;Integer&gt;(); int n = s.length(); int num = words.length; if(n == 0 || num == 0) return indexs; int len = words[0].length(); //counts用于存储words中字符串的个数和每个字符串的个数 Map&lt;String,Integer&gt; counts = new HashMap(); for(String word : words) { counts.put(word, counts.getOrDefault(word, 0) + 1); } for(int i = 0;i &lt; n - num * len +1; i++) { Map&lt;String,Integer&gt; temp = new HashMap(); int j = 0; while(j &lt; num) { String word = s.substring(i + j * len, i + (j + 1) * len); if(counts.containsKey(word)) { temp.put(word, temp.getOrDefault(word, 0) + 1); if(temp .get(word) &gt; counts.get(word)) { break; } }else { break; } j++; } if(j == num) { indexs.add(i); } } return indexs; } }]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Sort Problem]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-Sort%20Problem%2F</url>
    <content type="text"><![CDATA[Next Permutation(31-Medium)Description Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. Example 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 Solution Code 如果一个数组中的元素从左到右成递减次序，那么就没有一个比它更大的排列，eg.5,4,3,1。 首先从数组的右边起，找到a[i]使其右边的部分不再递减。 public class NextPermutation { public void nextPermutation(int[] nums) { int i = nums.length - 2; while(i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i+1]) { i--; } if(i &gt;= 0) { int j = nums.length - 1; while(j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[i]) { j--; } swap(nums, i, j); } reverse(nums, i + 1); } public void reverse(int[] nums, int i) { int j = nums.length - 1; while(i &lt; j) { swap(nums, i, j); i++; j--; } } public void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } Time Complexity: O(n)Space Complexity: O(1)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Search Problem]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-Search%20problem%2F</url>
    <content type="text"><![CDATA[Search in Rotated Sorted Array（33-Medium）Description Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n). Example Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 Solution 利用二分查找：O(log n) class Solution { public int search(int[] nums, int target) { if(nums.length == 0) return -1; int l =0; int r = nums.length - 1; while(l &lt;= r){ int m = (l + r) / 2; if(target == nums[l]) return l; if(target == nums[m]) return m; if(target == nums[r]) return r; if(target &gt; nums[l] &amp;&amp; target &lt; nums[m]){ r = m - 1; continue; }else if(target &gt; nums[m] &amp;&amp; target &lt; nums[r]){ l = m + 1; continue; }else if(nums[l] &gt; nums[m]){ r = m -1; continue; }else if(nums[m] &gt; nums[r]){ l = m + 1; continue; } } return -1; } } 优化： public int search(int[] nums, int target) { int lo = 0, hi = nums.length - 1; while (lo &lt; hi) { int mid = (lo + hi) / 2; if ((nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid])) lo = mid + 1; else hi = mid; } return lo == hi &amp;&amp; nums[lo] == target ? lo : -1; } Find First and Last Position of Element in Sorted Array（34-Medium）Description Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] Solution 改进基本的二分查找： 在二分查找中基本的条件： 1）if(nums[mid] &gt; target) right = mid -1; 2) if(nums[mid] &lt; target) left = mid + 1; 3) if(nums[mid] = target) right = mid,找到目标值 在本题中查找first和last目标值，将分为两部分查找，先找first，再找 last。 1.Search first first的查找应该使查找范围尽量靠左，尽管数组中可能有多个target，但是应该找到最左面的 [1,3,5,5,5,5,9], target = 5 l = 1; r = 9; mid = 5(2)； mid == 5,这回应该尽量向左找，因为此时的5可能不是first，r = mid l = 1; r = mid = 5; mid = 3; mid &lt; 5,这时时基本的二分查找条件，l = mid + 1 l = r = 5, 循环结束 2. Search last 和first相反，last应该使查找范围尽量靠右 同样的例子，[1,3,5,5,5,5,9], target = 5 l = 1; r = 9; mid = 5(2)； mid == 5,这回应该尽量向右找，因为此时的5可能不是last，l = mid l = mid = 5, r = 9, mid = 5(3) mid = 5, 尽量向右找， l = mid l = mid = 5 , r = 9 , mid = 5(4) mid = 5 , 尽量向右找, l = mid l = mid = 5, r = 9, mid = 5,----? 这时出问题了，最后的范围只剩下[5,9]但是取中值的时候，mid总是等于5，跳不出循环， 我们想让mid更靠右，因为last target 更在乎它右边的值，而first更在乎它左边的值， 但是 mid = (l + r）/ 2 的公式更偏向与左边，索引在找last的时候讲中值公式更改为 mid = (l + r）/ 2 + 1 索引最后一次 mid = 9 mid &gt; 5,也就是说右边从这个值开始不会再有5了，而最后一个5在m - 1，r = m - 1 通过first, last 的差异来进行两次循环 solution 1： class Solution { public int[] searchRange(int[] nums, int target) { int[] index = {-1,-1}; if(nums.length == 0) return index; int l = 0; int r = nums.length - 1; //第一次：找到第一个目标值索引 while(l &lt; r) { int m = (l + r) / 2; if(nums[m] &lt; target) { l = m + 1; }else { r = m; } } if(nums[l] != target) { return index; }else { index[0] = l; } //第二次：找到最后一个目标值的索引 r = nums.length - 1; while(l &lt; r) { int m = (l + r) / 2 + 1; if(nums[m] &gt; target) { r = m - 1; }else { l = m; } } index[1] = r; return index; } } solution 2 class Solution { public int[] searchRange(int[] nums, int target) { int[] index = {-1,-1}; if(nums.length == 0) { return index; } int left_index = Index(nums,target,true); if(left_index == nums.length || nums[left_index] != target) { return index; }else { index[0] = left_index; } index[1] = Index(nums, target,false) - 1; return index; } public int Index(int[] nums, int target,boolean left) { int l = 0; int r = nums.length; while(l &lt; r) { int m = (l + r) / 2; if(nums[m] &gt; target || (left &amp;&amp; nums[m] == target)) { r = m; }else { l = m + 1; } } return l; } } 时间复杂度 O(log n)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Math Problem]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-Math-Problem%2F</url>
    <content type="text"><![CDATA[Palindrome Number 判断一个整数是否是回文的 方法：将这个整数的后半段反转，将它和前半段比较是否相同 特殊情况： x&lt;0 不是回文的 x是以0结尾的整数 不是回文的 public class PalindromeNumber { public boolean isPalindrome(int x) { if(x &lt; 0 || x % 10 == 0 &amp;&amp; x != 0) { return false; } int reverseNumber = 0; while(x &gt; reverseNumber) { reverseNumber = reverseNumber * 10 + x % 10; x = x / 10; } return x == reverseNumber || x== reverseNumber / 10; } }]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Linked List]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-Linked-List%2F</url>
    <content type="text"><![CDATA[Remove Nth Node From End of ListDescription Given a linked list, remove the n-th node from the end of list and return its head. Example Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Solution 方法一：两次扫描第一次扫描确定链表的长度，第二遍扫描删除指定的节点 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ //***********自己实现的方法*****************// class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode t = head; int len=0; int point=1; while(t != null) { len++; t = t.next; } if(len - n == 0) { return head.next; } t=head; while(point &lt; len-n){ t = t.next; point++; } t.next=t.next.next; return head; } } 方法优化提升首先设置一个指向head的“dumpy”结点，设置这个结点是为了简化一些特殊的情况，比如链表只有一个结点点或者要删除的节点是第一个结点。第一次扫描链表得到链表的长度L第二次扫描先指向dumpy，从开始移动到第 L-n 个结点，使第 L-n 个结点指向第 L-n+2 个结点。 public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0); dummy.next = head; int length = 0; ListNode first = head; while (first != null) { length++; first = first.next; } length -= n; first = dummy; while (length &gt; 0) { length--; first = first.next; } first.next = first.next.next; return dummy.next; } 算法分析 时间复杂度：O(L) L为链表的长度 空间复杂度：O(1) 方法二：一次扫描法一次扫描的方法是通过设置两个指针 first 和 second，首先 first 指针从开始移动 n+1 次，second 指针在起始的位置。这样使两个指针始终保持 n 个节点的距离向前移动，当 first 指针指向节点为空的时候，second 指针处在倒数第 n+1 的位置，此时可以删除目标位置的节点。 public ListNode removeNthFormEnd(ListNode head,int n) { ListNode dumpy = new ListNode(0); dumpy.next = head; ListNode first = head; ListNode second = head; for(int i=1;i&lt;n+1;i++) { first=first.next; } while(first != null) { first = first.next; second = second.next; } second.next = second.next.next; return dumpy.next; } 算法分析 时间复杂度：O(L) L为链表的长度 空间复杂度：O(1) Merge Two Sorted ListsDescription Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4 Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 Solution 方法一：迭代法/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode cur = new ListNode(0); ListNode relt = cur; while(l1!=null &amp;&amp; l2!=null) { if(l1.val &lt; l2.val) { cur.next = l1; l1 = l1.next; }else { cur.next = l2; l2 = l2.next; } cur = cur.next; } if(l1==null) cur.next=l2; if(l2==null) cur.next=l1; return relt.next; } } 方法二：递归法/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if(l1==null) return l2; if(l2==null) return l1; if(l1.val &lt; l2.val) { l1.next=mergeTwoLists(l1.next,l2); return l1; }else { l2.next=mergeTwoLists(l1,l2.next); return l2; } } } Merge k Sorted ListsDescription Merge k sorted linked lists and return it as one sorted list. Example Input: [ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6 ] Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 Solution 分而治之方法方法描述：这是一种递归的方法，思想就是将k个链表两两合并，如下图所示。 public class MergeKSortedLists { public ListNode mergeKLists(ListNode[] lists) { return merge(lists,0,lists.length-1); } private ListNode merge(ListNode[] lists,int left,int right) { if(left == right) { return lists[left]; } if(left &lt; right) { int mid = (right + left)/2; ListNode l1 = merge(lists,left,mid); ListNode l2 = merge(lists,mid+1,right); return mergeTwoLists(l1,l2); }else { return null; } } private ListNode mergeTwoLists(ListNode l1,ListNode l2) { if(l1 == null) return l2; if(l2 == null) return l1; if(l1.val &lt; l2.val) { l1.next = mergeTwoLists(l1.next,l2); return l1; }else { l2.next = mergeTwoLists(l1,l2.next); return l2; } } } 算法分析 时间复杂度：O(N*lgk),N是两个链表节点总数，lgk是分治算法递归实现的复杂度. 空间复杂度：O(1) Swap nodes in pairsDescription Given a linked list, swap every two adjacent nodes and return its head. Example Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Soution 迭代法public class SwapNodesInPairs { public ListNode swappairs(ListNode head) { if(head==null || head.next==null) return head; ListNode dumpy = head.next; while(head!=null &amp;&amp; head.next!=null) { ListNode first = head.next; ListNode second = head.next.next; first.next = head; head.next = (second==null || second.next==null) ? second : second.next; head = second; } return dumpy; } } 算法分析 时间复杂度：O(n),n为链表的长度 空间复杂度：O(1) 递归法public class SwapNodesInPairs { public ListNode swapPairs(ListNode head) { if(head==null || head.next==null) return head; ListNode first = head.next; ListNode second = head.next.next; first.next = head; head.next = swapPairs(second); return first; } } Reverse Nodes in k-GroupDescription Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Soluton /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseKGroup(ListNode head, int k) { /* if(head == null) return null; if(k == 1) return head;*/ ListNode dumpy = new ListNode(-1); dumpy.next = head; ListNode temp = head; int count = 0; while(temp!=null &amp;&amp; count!=k) { temp = temp.next; count++; } if(count == k) { temp = reverseKGroup(temp,k); ListNode pre = head; ListNode cur = head.next; while(k &gt; 1) { pre.next = cur.next; cur.next = dumpy.next; dumpy.next = cur; cur = pre.next; k--; } pre.next = temp; } return dumpy.next; } } 算法分析 时间复杂度：O(n) 空间复杂度：O(1) Reverse Linked List实现翻转链表的功能 方法一：原地翻转public class ReverseLinkedList { public ListNode reverseList(ListNode head) { //原地翻转法 if(head == null) return head; ListNode dumpy = head; ListNode pre = head; ListNode cur = head.next; while(cur != null) { pre.next = cur.next; cur.next = dumpy.next; dumpy.next = cur; cur = pre.next; } return dumpy.next; } } 方法二：建立新链表，插入式翻转public class ReverseLinkedList { public ListNode reverseList(ListNode head) { //建立新链表，添加节点翻转法 if(head == null) return head; ListNode dumpy = new ListNode(-1); ListNode cur = head; while(cur != null) { ListNode nex = cur.next; cur.next = dumpy.next; dumpy.next = cur; cur = nex; } return dumpy.next; } } 有序链表转换二叉搜索树题目描述： 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 解题思路 如何找出这样的一个根节点呢？我们可以找出链表元素的中位数作为根节点的值。 这里对于中位数的定义为：如果链表中的元素个数为奇数，那么唯一的中间值为中位数；如果元素个数为偶数，那么唯二的中间值都可以作为中位数，而不是常规定义中二者的平均值。 根据中位数的性质，链表中小于中位数的元素个数与大于中位数的元素个数要么相等，要么相差 11。此时，小于中位数的元素组成了左子树，大于中位数的元素组成了右子树，它们分别对应着有序链表中连续的一段。在这之后，我们使用分治的思想，继续递归地对左右子树进行构造，找出对应的中位数作为根节点，以此类推。 方法一：分治1) 有序链表查找中位数-快慢指针法： 找出链表中位数节点的方法多种多样，其中较为简单的一种是「快慢指针法」。初始时，快指针 fast 和慢指针 slow 均指向链表的左端点 left。我们将快指针 fast 向右移动两次的同时，将慢指针 slow 向右移动一次，直到快指针到达边界（即快指针到达右端点或快指针的下一个节点是右端点）。此时，慢指针对应的元素就是中位数。 2) 在找出了中位数节点之后，我们将其作为当前根节点的元素，并递归地构造其左侧部分的链表对应的左子树，以及右侧部分的链表对应的右子树。]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Dynamic Programming]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-dynamic%20programming%2F</url>
    <content type="text"><![CDATA[Longest Palindromic Substring 回文字符串：正读反读都一样 方法一：暴力法 遍历所有的子字符串，判断它是不是回文字符串 class Solution { public String longestPalindrome(String s) { if(s.length()==1){ return s; } if(s.isEmpty()){ return ""; } int maxn=0; int iMin=0; //遍历每个子字符串并判断是不是回文的 for(int i=0;i&lt;s.length();i++){ for(int j=s.length()-1;j&gt;=i;j--) if(s.charAt(i)==s.charAt(j)){ if(check(s,i,j)){ if(j-i+1&gt;maxn){ maxn=j-i+1; iMin=i; } break; } } } return s.substring(iMin,maxn); } //检测一个字符串是不是回文 public boolean check(String s,int i,int j){ while(i&lt;=j){ if(s.charAt(i)!=s.charAt(j)){ return false; } i++; j--; } return true; } } 算法分析：时间复杂度O(n^3) 方法二：动态规划 暴力法时间复杂度高的原因是去检查每一个子字符串是不是回文的，降低时间复杂度就要减少对子字符串是不是回文的判断 假设一个字符串”ababa”,当我已经确认了”bab”是回文字符串，由于它左右两边的字符都是a，那么这个完整的字符串本身就是回文的，就可以不用对整个字符串再进行完整的判断。 假设一个字符串的长度为n，那么建立一个n*n数组P。在矩阵中P[i][j]=l，若l&gt;0：表示以字符S[i]开始和以S[j]结尾的字符串是回文字符串，字符串的长度为l;若l=0，表示此字符串不是回文字符串 只需要对矩阵中j&gt;=i的部分赋值即可，就j&lt;i部分为0； 1.一个字符的情况：将矩阵的对角线赋值为1，因为每个字符本身是回文的 2.两个字符的情况：j-i=1 P[i][j]=2,if S[i]=S[j] 3.多个字符的情况：j-i&gt;=2 if S[i]!=S[j] P[i][j]=0; if S[i]=S[j] if P[i+1][j-1]&gt;0 P[i][j]=p[i+1][j-1]+2; else P[i][j]=0; 字符串有多个字符组成时，如果两边的字符相等，那么这个字符串可能是回文的，这时将字符串去掉首末字符得到子字符串，如果子字符串回文的，那么这个字符串也是回文的。 public static String longestPalindrome(String s){ if(s.length()==0){ return ""; } if(s.length()==1){ return s; } int[][] p=new int[s.length()][s.length()]; int indexMin=0,maxn=1; //初始化二维数组P for(int i=0;i&lt;s.length();i++){ for(int j=0;j&lt;s.length();j++){ if(i==j) p[i][j]=1; } } for(int j=0;j&lt;s.length();j++){ for(int i=j-1;i&gt;=0;i--){ if(s.charAt(i)==s.charAt(j)){ if(j-i==1){ p[i][j]=2; } if(j-i&gt;=2){ if(p[i+1][j-1]&gt;0){ p[i][j]=p[i+1][j-1]+2; }else{ p[i][j]=0; } } }else{ p[i][j]=0; } if(p[i][j]&gt;maxn){ maxn=p[i][j]; indexMin=i; } } } return s.substring(indexMin, indexMin+maxn); } 算法分析： 时间复杂度：O(n^2) 空间复杂度：O(n^2),需要一个n*n的矩阵来存储数据 方法三：Expand Around Center 对于动态规划算法时间复杂度为O(n^2)，空间复杂度为O(n^2)，可以进一步优化只用O(1)的空间实现O(n^2)的时间复杂度 一个回文字符串它是成中心对称的，比如”baab”,”bab”,但是回文字符串分为两种：奇数字符数，偶数字符数 class Solution { public String longestPalindrome(String s) { if(s.length()==0){ return ""; } if(s.length()==1){ return s; } int indexMin=0,maxn=1; for(int i=0;i&lt;s.length();i++){ int len1=expandAroundCenter(s,i,i); int len2=expandAroundCenter(s,i,i+1); int len=Math.max(len1,len2); if(len&gt;maxn){ indexMin=i-(len-1)/2; maxn=len; } } return s.substring(indexMin,indexMin+maxn); } private int expandAroundCenter(String s,int L,int R){ while(L&gt;=0 &amp;&amp; R&lt;s.length() &amp;&amp; s.charAt(L)==s.charAt(R)){ L--; R++; } return R-L-1; } } 算法分析 时间复杂度：O(n^2) 空间复杂苏：O(1) 方法四：最长公共字符串** 将字符串S翻转为S’,检查S和S’的最长公共字符串就是S的最长回文子字符串此方法中存在一种问题，就是当字符串中某一个子串存在一个镜像子串本身并不是回文的，翻转之后会被检测为回文的。 下面是一种基于动态规划的求解最长公共字符串的方法。 Longest Common Substring 最长公共子字符串 动态规划问题 问题：因为有重叠子问题，当前计算的过程中可能有的问题在之前的计算已经计算过了，现在又要计算一遍，导致大量重复的计算 动态规划的解决方法：动态规划通过找到解决问题的递推关系，将已经完成计算的存储起来，当开始新的计算时如果包含之前计算的子问题时，不需要再次计算，只需要访问已经存储的计算结果就可以 动态规划解决问题的方法一般减少了时间复杂度，增加了存储空间。 动态规划问题的两个特点： 最优子结构 重叠子问题 对于这个问题，假设有两个字符串s[0,...m],t[0,...,n],求两个字符串的最长公共子字符串 定义矩阵mXn的矩阵L,L[i][j]表示以s[i]开始和t[j]结尾的公共子字符串长度的最大值，那么对于L[i+1][j+1]只是比L[i][j]增加了s[i+1]和t[j+1] 因此可以构造出最长公共子字符串的递归式： if s[i]==t[j] L[i][j]=L[i-1][j-1]+1 if s[i]!=t[j] L[i][j]=0 假设有两个字符串：”ABAB”和”BABA” ,构造出了上述的矩阵代码实现 public static String LCS(String s1,String s2){ if(s1.isEmpty() || s2.isEmpty()){ return ""; } int indexMax=0,maxn=0; int[][] L=new int[s1.length()][s2.length()]; for(int i=0;i&lt;s1.length();i++){ for(int j=0;j&lt;s2.length();j++){ if(s1.charAt(i)==s2.charAt(j)){ if(i==0 || j==0){ L[i][j]=1; }else{ L[i][j]=L[i-1][j-1]+1; } } if(L[i][j]&gt;maxn){ maxn=L[i][j]; indexMax=i; } } } return s1.substring(indexMax+1-maxn, indexMax+1); } 算法分析： 时间复杂度：O(mn) 空间复杂度：O(mn) 算法优化从上面动态查找最长公共子字符串的过程中发现，在循环查找的过程中只会用到矩阵L中的两行，即正在计算的一行和完成计算的上一行，之前计算的和带计算的都用不到，所以只需要维护两行数据就足够了，不需要使用mxn的数组 代码实现： public class LCS_improve { public static String LCS_improve(String s1,String s2){ if(s1.isEmpty() || s2.isEmpty()){ return ""; } int indexMax=0,maxn=0; int [][] L=new int[2][s1.length()]; for(int i=0;i&lt;s1.length();i++){ int cur=(i+2)%2; int pre=(i+1)%2; for(int j=0;j&lt;s2.length();j++){ if(s1.charAt(i)==s2.charAt(j)){ if(i==0 || j==0){ L[cur][j]=1; }else{ L[cur][j]=L[pre][j-1]+1; } }else{ L[cur][j]=0; } if(L[cur][j]&gt;maxn){ maxn=L[cur][j]; indexMax=i; } } } return s1.substring(indexMax+1-maxn, indexMax+1); } } 算法分析： 时间复杂度：O(mn) 空间复杂度：O(min(m,n))]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Array Problem]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-Array-Problem%2F</url>
    <content type="text"><![CDATA[Two SumDescription Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Solution 方法一：暴力遍历12345678910111213public int[] twoSum(int[] nums, int target) &#123; int[] res=new int[2]; int n=0; for(int i=0;i&lt;nums.length-1;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums[i]+nums[j]==target)&#123; res[n++]=i; res[n++]=j; &#125; &#125; &#125; return res; &#125; 时间复杂度：O(n^2) 方法二： 利用哈希表12345678910111213public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123; return new int[] &#123; i, map.get(complement) &#125;; &#125; &#125; throw new IllegalArgumentException("No two sum solution");&#125; 时间复杂度：O(n)空间复杂度：O(n) 方法三：对方法二的改进1234567891011public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException("No two sum solution");&#125; 时间复杂度：O(n)空间复杂度：O(n) 3SumDescription Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note The solution set must not contain duplicate triplets Example Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is:[ [-1, 0, 1], [-1, -1, 2]] Solution1234567891011121314151617181920212223242526272829public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums)&#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList(); Arrays.sort(nums); for(int i=0;i&lt;nums.length;i++) &#123; if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) &#123; continue; &#125; int left=i+1; int right=nums.length-1; while(left&lt;right) &#123; if(nums[i]+nums[left]+nums[right]==0) &#123; list.add(Arrays.asList(nums[i],nums[left],nums[right])); left++; right--; while(left&lt;right &amp;&amp; left&gt;0 &amp;&amp; nums[left]==nums[left-1]) &#123; left++; &#125; while(left&lt;right &amp;&amp; right&lt;nums.length-1 &amp;&amp; nums[right]==nums[right+1]) &#123; right--; &#125; &#125;else if(nums[i]+nums[left]+nums[right]&lt;0) &#123; left++; &#125;else &#123; right--; &#125; &#125; &#125; return list;&#125; 时间复杂度：O(n^2) 3Sum ClosestDescription Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Solution解法思路类似于3Sum123456789101112131415161718192021222324252627public int threeSumClosest(int[] nums,int target) &#123; int sum=0,cox=Integer.MAX_VALUE; int[] rest = new int[3]; Arrays.sort(nums); for(int i=0;i&lt;nums.length;i++) &#123; int l=i+1; int r=nums.length-1; while(l&lt;r) &#123; sum=nums[i]+nums[l]+nums[r]; int temp=Math.abs(target-sum); if(temp&lt;cox) &#123; cox=temp; rest[0]=nums[i]; rest[1]=nums[l]; rest[2]=nums[r]; &#125; if(sum==target) &#123; return sum; &#125;else if(sum&lt;target) &#123; l++; &#125;else &#123; r--; &#125; &#125; &#125; return rest[0]+rest[1]+rest[2]; &#125; 时间复杂度O(n^2) 4SumSolution12345678910111213141516171819202122232425262728293031323334353637public class FourSum &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums,int target)&#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList(); Arrays.sort(nums); for(int i=0;i&lt;nums.length;i++) &#123; if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) &#123; continue; &#125; for(int j=i+1;j&lt;nums.length;j++) &#123; if(j&gt;i+1 &amp;&amp; nums[j]==nums[j-1]) &#123; continue; &#125; int l=j+1; int r=nums.length-1; while(l&lt;r) &#123; int sum=nums[i]+nums[j]+nums[l]+nums[r]; if(sum == target) &#123; list.add(Arrays.asList(nums[i],nums[j],nums[l],nums[r])); l++; r--; while(l&lt;r &amp;&amp; l&gt;0 &amp;&amp; nums[l] == nums[l-1]) &#123; l++; &#125; while(l &lt; r &amp;&amp; r &lt; nums.length &amp;&amp; nums[r] == nums[r+1]) &#123; r--; &#125; &#125;else if(sum &gt; target)&#123; r--; &#125;else &#123; l++; &#125; &#125; &#125; &#125; return list; &#125;&#125; 时间复杂度：O(n^3) Median of Two Sorted ArraysDescription There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays.The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty. Example nums1 = [1, 3] nums2 = [2] median is 2.0 Solution class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int m=nums1.length; int n=nums2.length; if(m&gt;n){ int[] temp=nums1;nums1=nums2;nums2=temp; int tmp=m;m=n;n=tmp; } int iMin=0,iMax=m,hl=(m+n+1)/2; while(iMin&lt;=iMax){ int i=(iMin+iMax)/2; int j=hl-i; if(i&lt;iMax &amp;&amp; nums2[j-1]&gt;nums1[i]){ iMin=i+1; }else if(i&gt;iMin &amp;&amp; nums1[i-1]&gt;nums2[j]){ iMax=i-1; }else{ int maxLeft=0; if(i==0){ maxLeft=nums2[j-1]; }else if(j==0){ maxLeft=nums1[i-1]; }else{ maxLeft=Math.max(nums1[i-1],nums2[j-1]); } if((m+n)%2==1){ return maxLeft; } int minRight=0; if(i==m){ minRight=nums2[j]; }else if(j==n){ minRight=nums1[i]; }else{ minRight=Math.min(nums1[i],nums2[j]); } return (maxLeft+minRight)/2.0; } } return 0.0; } }]]></content>
      <categories>
        <category>Leetcode, Algorithms</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想-面向对象（基础）]]></title>
    <url>%2F2019%2F08%2F16%2FJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、关键字this关键字this关键字在方法内部使用，表示对“调用方法的那个对象”的引用，如果在方法内调用同一个类的另一个方法可以不使用this super关键字 this &amp;&amp; super A:this本类的引用，super代表父类存储空间的标识（看成对父类的引用） B:this.变量 ，super.变量 -----引用变量 this(.....) ，uper(.....) -----调用构造方法 this.成员方法 ，super.成员方法 -----调用成员方法 static关键字static的特点：1.类中static关键字修饰的变量（静态变量）被类的所有对象共享 class Static{ static int i=47; } 即使创建多个对象也共享同一个变量i： Static st1=new Static(); Static st2=new Static(); st1.i和st2.i指向同一个存储空间地址，有相同的值，也可以通过Static.i引用变量 2.类中static修饰的方法可以在不创建方法的前提下直接调用static修饰的方法不与包含它的类的任何对象关联在一起，不用创建对象通过类本身调用，这是static方法的主要用途 class Static{ public static void increment(){ Static.i++; } } 定义了一个静态方法，通过类直接调用：Static.increment() 3.静态是随着类的加载而加载,与对象无关 4.static方法没有this关键字 5.static方法不能调用非静态方法，反过来可以 6.所有构造方法都默认被static修饰 final关键字1.修饰数据声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量 final修饰基本类型（整型，浮点，字符等），表示一个常量，赋值后不可以改变 final修饰引用类型（类，接口，数组），final使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的 2.修饰方法 final修饰的方法不能被重写（private方法也不可重写） private方法隐式地被指定为final，如果在子类中定义的方法和基类中的一个private方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法 3.修饰类 final修饰的类不可以被继承 成员变量和局部变量 局部变量：在方法外---在栈内存 （变量没有默认初始值）---随之对象的创建产生，随着对象的消失 成员变量： 在方法内---在堆内存 （变量有默认初始值）--随着方法的调用产生 二、继承 java中继承的特点： A: 只支持单继承，不支持多继承 B: 支持多层继承 class A{} class B extends A{} class C extends B{} 注意事项 A:子类只能继承父类中非私有的成员（成员变量和成员方法） B:子类不能继承父类的构造方法，但可以通过super关键字去访问父类构造方法 1.访问权限包访问权限（friendly） ：默认的访问权限通常是包访问权限，当前包中所有其他类可以访问那个成员，对于这个包之外的所有类是privatepublic：公共的，谁都可以访问protected：继承访问权限private：私有的，除了包含该成员的类之外其他类无法访问！注意：a.类不可以用private，protected修饰，只可以是包访问权限和publicb.如果类的构造方法由private修饰，则无法创建该类的对象，从而禁止拥有该类的访问权限，但是任然可以调用访问该类中static修饰的成员 2.类间的关系组合 class Actor{ public void act() {} } class HappyActor{ public void act(){ print(&quot;HappyActor&quot;); } class SadActor{ public void act(){ print(&quot;SadActor&quot;); } } class Stage{ privat Actor actor=new HappyActor(); public void change(){ actor=new SadActor(); } public void perform(){ actor.act(); } } 继承代理 3.重写和重载 重写（Override） 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。 为了满足里式替换原则，重写有有以下两个限制： 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型。 使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。 重载（Overload） 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。 应该注意的是，返回值不同，其它都相同不算是重载。 三、多态1.多态的前提要有继承关系，要有方法重写，要有父类引用指向子类对象（父类 F = new 子类()) class fu{ public fu(){ } public void show(){ System.out.println(&quot;fu&quot;); } } class zi extends fu{ public void show(){ System.out.println(&quot;show zi&quot;); } public void method(){ Sysltem.out.println(&quot;method zi&quot;); } } class DuotaiDemo{ public static void main(String[] args){ fu f = new zi(); f.show(); } } 2.多态中成员访问特点 A:成员变量—编译看左边，运行看左边 B:构造方法—创建子类对象时，访问父类的构造方法，对父类的数据进行初始化 C:成员方法—编译看左边，运行看右边（因为有成员方法重写，所以调用子类） D:静态方法—编译看左边，运行看左边（静态只和类有关） 多态好处 ：提高了代码的维护性（继承）、扩展性（多态）弊端 ：不能使用子类的特有功能 对象间的转型:向下转型 父-&gt;子 zi z = (zi)f向上转型 子-&gt;父 fu f = new zi() 四、接口1.抽象类和抽象方法抽象类和抽象方法必须用abstract修饰 格式： abstract class 类名 {} public abstract void 方法名(); 特点： 抽样类中不一定有抽样方法，但是有抽样方法的类一定要定义成抽类 抽样类不能实例化，抽象类有构造方法，但不可以实例化，构造方法是给子类调用的 抽象类的子类：如果不想重写抽样方法，子类是一个抽样类，如果想重写抽样方法，子类是一个具体的类 成员特点： 成员变量：既可以是常量，也可以是变量 构造方法：有，用于子类访问父类数据初始化 成员方法：既可以是抽象的，也可以是非抽象的，成员方法是抽象的，子类必须得重写，成员方法是非抽象的，子类继承 2.接口interface产生一个完全抽象的类，此类没有提供任何相应的具体实现，它允许确定方法名、参数列表、和返回类型，但是没有任何方法体。 接口只提供了形式，而未提供任何具体实现 接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected 接口的字段默认都是 static 和 final 的 A.接口成员特点：成员变量：只能是常量，是静态的，默认修饰符 public static final构造方法：没有（所有类都默认继承object类）成员方法：只能是抽象方法，默认修饰符public B.比较 从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 C.使用选择 使用接口：a.需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；b.需要使用多重继承；c.创建不带任何方法定义和成员变量的基类； 使用抽象类：a.需要在几个相关的类中共享代码；b.需要能控制继承来的成员的访问权限，而不是都为 public；c.需要继承非静态和非常量字段； 在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低 D.关系类和类：继承关系，只能单继承，多层继承类和接口：实现关系，可以单实现也可以多实现，可以在继承一个类的同时实现多个接口接口和接口：继承关系，可以单继承，也可多继承 五、内部类匿名内部类内部类的简写前提：存在一个类和接口类名或接口 格式： new名 () { 方法重写; };本质是一个继承了该类或实现了接口的子类匿名对象 六、字符串String主要方法构造方法 public String() 空构造 public String(byte[] bytes) 把字节数组转换成字符串 public String(byte[] bytes,int offset,int length) 把字节数组一部分转换成字符串 public String(char[] value) 把字符数组转换成字符串 public String(char[] value,int offset,int count) 把字符数组一部分转换成字符串 public String(String original) eg. String s = new String(参数) 成员方法 **判断功能** public boolean equals(Object anObject) 比较字符串的内容是否相同 public boolean equalsIgnoreCase(String str) 比较字符串的内容是否相同，忽略大小写 public boolean contens(String str) 大的字符串是否包含小串 public boolean startsWith(String str) 判断字符串是否以某个特定的字符串开头 public boolean endsWith(String str) 判断字符串是否以某个特定的字符串结尾 public boolean isEmpty() 判断字符串是否为空 **获取功能** public int length() 获取字符串长度 public char charAt(int index) 返回索引处的字符 public int indexOf(int ch) 返回指定字符第一次出现的字符串内的索引 public int indexOf(String str) 返回指定子字符串第一次出现的字符串内的索引。 public int indexOf(int ch,int fromIndex) 返回指定字符第一次出现的字符串内的索引，以指定的索引开始搜索 public int indexOf(String str,int fromIndex) 返回指定子串的第一次出现的字符串中的索引，从指定的索引开始 public String substring(int beginIndex) 返回一个字符串，该字符串是此字符串的子字符串。 子字符串以指定索引处的字符开头，并扩展到该字符串的末尾 public String substring(int beginIndex,int endIndex) 返回一个字符串，该字符串是此字符串的子字符串，子串开始于指定beginIndex并延伸到字符索引endIndex - 1 **转换功能** public byte[] getBytes() 把字符串换换为字节数组 public toCharArray() 把字符串转换为字符数组 public static String valueof(char[] chs) 字符数组转化成字符串 public static String valueof(int i) 把int转化成字符串 public String toLowerCase() 字符串变小写 public String toUpperCase() 字符串变小写 public String concat(String str) 字符串拼接 **替换功能** public String replace(char old,char new); public String replace(String old,String new); **去除字符串开头结尾两个空格** public String trim(); **按字典顺序比较两个字符串** public int compareTo(String str); public int compareToIgnorceCase(String str); String, StringBuffer and StringBuilder 可变性String 不可变StringBuffer 和 StringBuilder 可变 线程安全String 不可变，因此是线程安全的StringBuilder 不是线程安全的StringBuffer 是线程安全的，内部使用 synchronized 进行同步 类型转换String和StringBuffer相互转换 String s = new String() A:StringBuffer sb = new StringBuffer(s) B:StringBuffer sd2 = new StringBuffer() sb2.append(s) StringBuffer sb = new Stringbuffer(&quot;java&quot;) A:String str = new String(sb) B:String str2 = sb.toString() String和int int a=100; String s2=String.valueOf(a); System.out.println(s2); String s =&quot;100&quot;; int y=Integer.parseInt(s); System.out.println(y); * 把int转化为String 1. String s=&quot;&quot;+i; 2. String s=Integer.toString(i); 3. String s=String.valueOf(i); * 把String转化为int型 1. int i=Integer.parsenInt(s); 2. int i=Integer.valueOf(s).intValue(); * 把String转化为Integer * Integer integer=Integer.valueOf(i) * 把Integer转化为int * int num=Integer.intValue()；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-Logistic回归]]></title>
    <url>%2F2019%2F02%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Logistic%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[Logistic回归-模型原理及梯度下降算法1. Logistc回归模型回归：用一条直线对给定数据进行拟合(最佳拟合直线) Logistic 回归：根据现有数据对分类边界建立回归方程，以此直线进行分类 给定数据集 \( [(x_{1},y_{1}),(x_{2},y_{2}),…,(x_{m},y_{m})] \) ，每个样本 x 有 d 个属性 \( x=[x_{1},x_{2},…,x_{d}] \) 。 对于给定数据集，该数据集的线性拟合公式为： $$ f(x) = w_{0}x_{0}+w_{1}x_{1}+w_{2}x_{2}+…+w_{d}x_{d} $$ $$ f(x) = w^{T}x $$ 其中 \( w^{T}=[w_{0}，w_{1},w_{2},…,w_{d}] \) 若要进行分类任务(以二分类为例)，需要找到一个单调可微的函数将分类任务的真实标记 y 和线性回归模型的预测值关联起来。 分类输出标记 y = {0 ， 1} ， 回归模型的预测值 \( z = w^{T}x \) ， 因此需要一个函数将 z 转化为 0 / 1 值。 最理想的函数是 “ 单位阶跃函数 ”，但是这个函数是不连续的函数，它的跳跃点从0到1的跳跃过程很难处理。需要一个近似单位阶跃的函数，更容易处理且单调可微，这就是 “ 对几率函数(logistic function) ” 函数 ,它是“Sigmoid函数”的一种 。 $$ y_{w}(x) = \frac{1}{1+z^{-1} }= \frac{1}{1+(w^{T}x)^{-1}} $$ $$ y = \begin{cases}1 &amp; \text{ if } z&gt;0 \0.5 &amp; \text{ if } z=0 \0 &amp; \text{ if } z&lt;0\end{cases} $$ 对下式取对数： $$ y = \frac{1}{ 1 + e^{-(w^{T}x+b)} }$$ $$ ln\frac{y}{1-y}=w^{T}x+b $$ 将上式中y作为样本为正例的可能性，1-y表示样本为负例的可能性，两者的比值 y/1-y 称为“几率”(odds),表示样本是正例的相对可能性，对“几率”取对数得到 ln(y/1-y) 称为“对数几率”(log odds/logit)。由此可见Logistic回归实际是在用线性回归模型的预测结果去逼近真实标记的对数几率。 我们将 ln(y/1-y)中的y视为类后验概率 P( y = 1 | x ）于是将 对几率函数重写为 $$ ln\frac{p(y=1|x)}{p(y=0|x)}=w^{T}x+b $$ 在Logistic回归中，输出y=1的对数几率是输入x的线性函数，于是得到二项Logistic回归模型的条件概率： $$ p(y=1|x)=\frac{e^{w^{T}+b}}{1+e^{w^{T}+b}} $$ $$ p(y=0|x)=\frac{1}{1+e^{w^{T}+b}} $$ 对于任意给定的样本x，按照上两是计算得到 p(y=1|x) 和 P(y=0|x),比较两个条件概率的大小，将x分到概率较大的那一类。 考虑对样本进行分类的线性函数 \( w^{T}+b \)，它的值域为实数域，通过Logistic回归条件概率将线性函数转化成概率，线性函数的值越接近正无穷，概率值就越接近1;线性函数值越接近负无穷，概率值就越接近0，这就是对几率函数的性质，这样的模型就是Logistic回归。 Logistic Regression虽然名字是回归，但它是一种分类学习算法，它的优点是分类时直接对分类可能性直接建模，无需事先假设数据分布，避免了假设分布不准确带来的问题；它不是仅预测出类别，而是类别的近似概率预测，这对很多需要概率辅助的分类任务很有用；对率函数是任意可导的凸函数，有很好的的数学性质，现有的很多数值优化算法都可直接用于求解最优解。 2. 模型参数估计确定了分类器的函数形式，最终的问题就是如何确定最佳回归参数，向量 w 就是回归参数 ，使用极大似然估计来估计参数模型 w 和 b。 给定数据集 \( [(x_{1},y_{1}),(x_{2},y_{2}),…,(x_{m},y_{m})] \)，将权值向量和特征向量扩充，仍记为w，x。 $$ w = (w^{1},w^{2},…,w^{d},b) $$ $$ x = (x^{1},x^{2},…,x^{d},1) $$ 设 ： \( p_{1}(x;w)=p(y=1|x;w) \), \( p_{0}(x;w)=p(y=0|x;w) \) 似然函数为： $$ \prod_{i=0}^{m}p(x_{i};w)^{y_{i}}[1-p(x_{i};w)]^{1-y_{i}} $$ 对数似然函数为： $$ Ln(w) = \sum_{i=0}^{m}[y_{i}log(p(x_{i};w))+(1-y_{i})log(1-p(x_{i};w))]=\sum_{i=0}^{m}[y_{i}log(\frac{p(x_{i};w)}{1-p(x_{i};w)})+log(1-p(x_{i};w))]=\sum_{i=0}^{m}[y_{i}(w^{T}x)-log(1+e^{w^{T}x})] $$ 对Ln(w)求极大值，可以得到w的估计值。问题变成了对似然函数的最优化问题，Logistic回归常用的方法是梯度下降法和拟牛顿法。 3. 误差评估在logistic回归中明确了分类预测函数，其中\( z = w^{T}x \)是分类边界，即决策边界就是划分样本类别的边界，可以是点，可以是线，可以是面，“决策边界是预测分类函数的 \( y_{w}(x) \)的属性，不是训练集的属性，因为能够划分类别界限的是\( y_{w}(x) \)，而训练集是用来训练调节参数” 在前面确定了 logistic regression的分类原理和方法，接下来要要评估分类效果，即评估\( y_{i} \) 和 \( f(x_{i}) \) 之间的误差，通过均方误差来描述误差,误差评估的函数又称为代价函数，均方误差是回归任务中常用的度量标准： $$ J(w)=\frac{1}{2m}\sum_{i=1}^{m}(f(x_{i})-y_{i})^{2} $$ 我们的目标就是通过调节参数 w 使 J(w)能够达到最小， 4. 优化算法-梯度下降法Gradient Descent训练学习的目标就是不断调节参数w来使J(w)达到最小，通常使用梯度下降方法来调节w： $$w_{j}=w_{j}-\alpha \frac{\partial }{\partial w}J(w)$$ 梯度方向是函数值下降最为剧烈的方向。那么，沿着 J(w) 的梯度方向走，我们就能接近其最小值，或者极小值，从而接近更高的预测精度。学习率 α 是个相当玄乎的参数，其标识了沿梯度方向行进的速率，步子大了，很可能这一步就迈过了最小值。而步子小了，又会减缓我们找到最小值的速率。在实际编程中，学习率可以以 3 倍，10 倍这样进行取值尝试：α=0.001,0.003,0.01…0.3,1 4.1 批量梯度下降法(Batch Gradient Descent)对一个大小为m的训练集，w的迭代过程如下，重复迭代直到收敛： $$w_{j}=w_{j}+\alpha \frac{1}{m}\sum_{i=1}^{m}(y_{i}-f(x_{i}))x_{j}^{i}$$ 矩阵表示如下： $$w_{j}=w_{j}+\alpha \frac{1}{m}(y-f(x))^{T}x_{j}$$ 这种方法是批量梯度下降法，每次更新一次系数就要完整遍历一次数据集，如果训练集体积巨大，那么计算的复杂度太高。 4.2 随机梯度下降法(Stochastic Gradient Descent)由于批量梯度下降法计算开销太大，一种改进方法是一次仅用一个样本点来更新回归系数，该方法称为随机梯度下降算法。由于可以在新样本到来时对分类器进行增量式更新，因而随机梯度下降算法是一个在线学习算法。与“在线学习”相对应，一次处理所有数据被称作是“批处理”。 重复迭代直至收敛：for i = 1 to m$$ w_{j}=w_{j}+\alpha \frac{1}{m}(y_{i}-f(x_{i}))x_{j}^{i} $$]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-贝叶斯分类器]]></title>
    <url>%2F2019%2F01%2F24%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一. 概率知识 先验概率：先验概率（prior probability）是指根据以往经验和分析得到的概率 后验概率：后验概率,事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小后验概率就是条件概率 p(c|x) = p(x|c)p(c)/p(x) 贝叶斯概率引入先验知识和逻辑推理来处理不确定的命题 事情还没有发生，要求这件事情发生的可能性的大小，是先验概率。事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小，是后验概率。 先验概率的计算比较简单，没有使用贝叶斯公式；而后验概率的计算，要使用贝叶斯公式，而且在利用样本资料计算逻辑概率时，还要使用理论概率分布，需要更多的数理统计知识 二. 贝叶斯分类器基本原理1. 贝叶斯判定准则假设训练集为 T = {(x1,y1),(x2,y2),....,(xN,yN)}, 有 K 中标记类型，标记集 y = {c1,c1,...,cK} 定义损失函数 L(Y=ck,f(x)) 为将样本 x 分类错误所产生的损失 基于后验概率可以得到将样本 x 分类为 ci 产生的期望损失，即在样本x上的‘条件风险’ 注：期望损失也称为风险 对于分类准则f(x),总体风险为： 我们的任务就是找到一个分类准则使总体风险最小化。如果对于每个样本 x ，若f(x)能最小化条件风险 R(f(x)|x) ,则总体风险 R(f) 也将最小化。 贝叶斯判定准则： 为了最小化总体风险，只需在每个样本上选择那个能使条件风险R(c|x)最小的类别标记 上式为最小分类错误的贝叶斯最优分类器，即对每个样本x，选择能使后验概率 P(c | x)最大的类别标记，所以期望风险最小化准则就是后验概率最大化准则 2. 朴素贝叶斯2.1 朴素贝叶斯的原理经过上面的分析我们得到要想设计最优的贝叶斯判定准则来最小化决策风险，首先要获得的就是后验概率 P(c| x)。 由贝叶斯定理可以得到后验概率的计算公式： P( c ) 是先验该概率，P(x | c)是样本 x 相对于类标记 c 的条件概率，或称为似然概率 先验概率p(c)表示样本空间中各类样本所占的比例 类条件概率p(x | c)是样本x所有属性的联合概率，难以从有限的训练样本中直接估计得到，为了避开这个障碍简化问题，朴素贝叶斯法做了‘ 属性条件独立的 ’的假设，即对已知类别，假设所有属性相互独立。 这就是朴素贝叶斯的由来，朴素贝叶斯分类器中的’ 朴素 ‘的含义是： 所有属性特征相互独立同等重要。如果属性之间不相互独立就是贝叶斯网，一种经典的概率图模型。 有朴素贝叶斯分类器的的属性相互独立的假设条件可以将后验概率公式变为如下： 由于对于所有类别来说 P(x) 相同，因此可以得到贝叶斯判定准则如下，xi 为样本 x 第 i 个属性的值： 这就是朴素贝叶斯分类器的表达式。 所以朴素贝叶斯分类器学习的关键是如何求解 P(c) 和 P(x | c) 2.2 极大似然估计法 初学，目前还没有搞懂，先占个坑吧！ 在朴素贝叶斯算法中，分类器的训练学习意味着估计 P(c) 和 P(xi | c) ,可以使用极大似然估计法估计响应的概率，先验概率和条件概率的极大似然估计如下： 2.3 朴素贝叶斯分类算法朴素贝叶斯分类器的训练过程就是基于训练集来估计类先验概率 P(c) , 和每个属性的条件概率 P(xi | c) 算法实例 注：算法和实例图来自于《统计学方法》 2.5 贝叶斯估计实现算法中可能出现的问题 下溢出问题 训练朴素贝叶斯分类器之后，当有新样本时，会计算样本属于某个类别的概率 P(i) = P(ci) P(w0 | ci) P(w1 | ci) ... P(wk | ci) 在计算概率是由于太多很小的数相乘，程序会下溢出或者得不到正确答案(比如python程序在乘法中得到非常小的输时会四舍五入) 一种解决方法是对上面的乘法计算公式取对数将乘法转化为加法，ln(a*b) = ln(a) + ln(b),通过对数避免下溢出或四舍五入，采用对数进行处理不会有任何损失，不会影响最终结果(因为算法最后是通过比较各个类别概率大小决定样本的类别，而不是返回概率本身) 训练集中特征不存在，概率为零 在计算条件概率时，如果某个属性在训练集中没有和某个类同事出现，那么这个条件概率就为0，这样在最后计算样本属于该类的概率时不管其他属性如何，这个概率都为零，为了避免其他属性携带的信息被训练集中未出现的属性抹去，通常要进行“平滑”，常用拉普拉斯平滑。 贝叶斯估计 用极大似然估计会出现所要计算的概率为0的情况，会影响到后验概率的计算进而影响最终的判定结果，使分类产生偏差。解决这一问题的方法是使用贝叶斯估计代替极大似然估计，下面公式是先验概率和条件概率的贝叶斯估计： λ ≧ 0 ，当 λ = 0 时，就是最大似然估计；当 λ = 1 时， 就是拉普拉斯平滑 2.5 朴素贝叶斯分类器的实现方式 基于高斯分布模型 GuassianNB:高斯朴素贝叶斯算法是基于假设特征服从高斯分布 基于贝努利模型 MultinomialNB:用于实现服从多项式分布数据的朴素贝叶斯算法，常用于文本分类(文本数据经常用词向量来表示) 基于多项式模型 BernoulliNB:用于实现服从多变量贝努利分布数据的朴素贝叶斯算法，这种算法要求样本表示成二进制特征向量]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-模型评估与选择]]></title>
    <url>%2F2019%2F01%2F16%2F%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[模型评估与选择一.误差与过拟合分类器分类错误的样本数占样本总数的比例为错误率(errorate)，E=m/n(m为分类错误的总样本数，n为总样本数），分类的精度(accuracy) P=(1-E)x100% 学习器实际预测值和样本真实值之间的差异为“误差” 训练误差/经验误差：学习器在训练数据上的误差 泛华误差：学习器在新样本上的误差 我们希望得到的是泛化误差尽可能小的学习器，在通过训练数据训练学习器的过程中是在尽可能的最小化训练误差。有时学习器的训练误差非常小，但当遇到新的样本时表现的却不好。因此为了的当泛华能力比较强的学习器，只能让学习器从训练样本中学习到尽可能适应所有样本的普遍规律，要尽可能的学习所有训练样本的共性，这样学习器在遇到引得样本时才会做出正确的判断。通过训练数据训练出的学习器会有两个问题： 过拟合:学习器学习能力过于强大把训练数据学习的太好了，可能把训练样本自身的特点当做了所有样本的一般性质，导致过拟合，是学习器的泛化能力降低。过拟合无法避免，只能尽量减小。 欠拟合：和过拟合相对应，有学习器学习能力过低，对训练样本的一般性质没有学好，欠拟合容易克服，关键的问题是过拟合 二.模型评估和选择方法不同的机器学习算法，同一算法的不同参数配置都是不同的模型，机器学习的模型选择就是对模型的泛化误差进行评估选择泛化误差最小的模型。 通过训练数据得到的学习器，将学习器在在测试数据上的测试误差作为学习器的泛华误差。 训练集与测试集要有如下关系：训练集和测试集都是从样本真实分布中独立同分布采样而得，他们应该尽可能互斥，测试样本尽量不出现在训练样本中。 假设包含m个样例的样本集D={(x1,y1),(x2,y2),...,(xm,ym)},如何划分训练集和测试集的常用方法如下： 留出法直接将样本集D划分为两个互斥的集合D= S U T,S作为训练集，T作为测试集估计分类器的泛化误差。 训练集和测试集的划分要保持数据分布的一致性，避免数据划分引入偏差影响结果。比如在分类任务中要保持两个集合中样本的类别别比例相似。 在使用留出法时不同的划分会得到不同的模型，单次留出法得到的结果往往不够稳定可靠，一般采用若干次留出法随机划分，重复试验评估后取平均值作为留出法的评估结果。并且常将样本集的2/3 ~ 4/5的样本用于训练，剩余的用于测试。 交叉验证法 将样本集D划分为k个大小相似的互斥子集，D=D1 U D2 U…U Dk,每个子集尽可能保持数据分布的一致性， 每次使用k-1个子集的并集作为训练集，剩余的一个子集作为测试集， 这样可以得到k组训练/测试集，进行k次实验，得到的是k次测试结果的均值 交叉验证法评估结果的稳定性很大程度取决于k的取值，因此也称为“k折交叉”验证，k常取10，其他常用值为5，20等。 交叉验证法的特例：留一法(LOO)，k=m 留一法的优点：留一法不受随机样本划分方式的影响，因为m个样本只有唯一的方式划分为m个子集，每个子集一个样本，在多数情况下，留一法中被实际评估的模型和期望评估的用D训练出的模型很相似，评估结果往往被认为很准确。 留一法的缺点：数据集比较大时，计算复杂度高，开销非常大。 自助法自助法采用又放回采样方法，原始样本集D，每次从D中随机挑选一个样本，拷贝到D’中，并放回D中，重复每次，就得到了包含m个样本的数据集D’。通过采样法，初始数据集D中有约36.8%的样本未出现在D’中，D’作为训练集，D/D’作为测试集 总结： 在初始数据集比较充足时，留出法和交叉验证法更常用一些 在数据集比较小，难以有效划分训练/测试集是使用自助法 对于数据集小且可有效划分的时候最好使用留一法来进行划分，因为这种方法最为准确 数据集的分类及作用 训练集 training set： 用于训练模型 验证集 validation set： 用于模型选择 测试集 test set： 用于最终对学习方法的评估 调参机器学习中的两类参数： 算法的参数/超参数 模型的参数 算法的参数往往在实数范围内，因此对每种参数配置都训练出模型是不可能的，现实中往往对每个参数选定一个范围和步长值，这样选定的参数不是最佳的，但这是计算开销和性能估计之间进行这种的结果。调参往往很苦难，工程量大。 三.性能度量衡量模型泛化能力的评价标准就是性能度量，对比不同模型时使用不同的性能度量往往得到不同的评判结果。所以模型好坏是相对的，不仅取决于算法和数据，还决定于任务需求。 1.错误率和精度错误率和精度是分类任务中最常用的两个性能度量 2.查准率，查全率，F1错误率和精度有时不能满足所有的任务度量需求，对于某些问题不光要分类正确，还要求其他更进一步的需求，因此精度不能满足评估需求。比如挑西瓜，我们更关心挑出的西瓜有多少好瓜，或者有多少好瓜被挑选出来了，为了衡量这种指标，引入了查准率和查全率，查准率( precision , 注：分类精度为 accuracy)亦称准确率，查全率(recall)亦称召回率。 对于二分类问题，样本真实类别和分类器预测类别有四种组合： TP 真正例(true positive) FP 假正例(false positive) FN 假反例(false negative) TN 真反例(true negative） TP+FP+FN+TN = 样本总数 查准率：它是相对我们预测结果而言，预测的正例中有多少是真正的正例 查全率：它是相对测试样本而言，样本中的正例有多少被预测出来 查准率和查全率往往是矛盾的，查全率高时，查准率会偏低；二查准率高时，查全率就会偏低。只有在一些简单任务中这两个指标才会都很高 设计了“PR曲线”来综合考虑查全率、查准率的性能度量 在P-R曲线中，如果一个分类器的曲线完全包住另一个分类器的曲线，那么前者的性能优于后者，如果俩个分类器的曲线相交，则很难判断性能的优劣，需要其他指标来衡量。 平衡点(BEP)：曲线查全率等于查准率的点，过于简单 F1：是基于查全率和查准率的调和平均，公式如下： 其中Fβ是F1的更一般形式，因为在实际中不同的应用对查全率和查准率的要求不一样，所有 Fβ 是加权调和平均。β=1 时就是 F1； β&gt;1 时查全率影响更大；0&lt;β&lt;1 时，查准率影响更大些。 3. ROC和AUC3.1 ROCROC是一种度量分类器分类好坏的标准，评估分类器性能的标准有很多，但不同任务不同需求对好坏的标准并不一样。使用最多的标准就是分类精度，但有些现实问题中 accuracy 不能很好地评估分类器的性能。eg. 测试样本中有A类样本90个，B 类样本10个。分类器 C1 把所有的测试样本都分成了A类;分类器 C2 把A类的90个样本分对了70个，B类的10个样本分对了5个;则C1的分类精度为 90%，C2的分类精度为75% 。但是，显然C2更有用些，而且不同问题中分类错误的代价不一样。 很多学习器为测试样本产生一个实值或概率预测，将这个预测值和分类阈值threshol进行比较，大于阈值分为正例，否则分为反例。这个阈值直接决定了分类器的性能即泛化能力。根据分类器对测试样本的预测结果对所有的测试样本进行排序，分类就是在这个排序中选取某个截断点，截断点之前为正例，截断点之后为反例。根据不同的任务需求选取不同的截断点，比如如果更重视查准率，那么就选择的截断点更靠前，如果更重视查全率，选择的截断点更靠后的位置。因此排序质量的好坏，表示综合考虑分类器在不同任务下的“期望泛化性能”的好坏，ROC曲线就是从‘期望性能’的角度评估分类器的性能。 ROC全称是“受试者工作特征”ROC横坐标x为‘真正例率’ TRP，纵坐标y为‘假正利率’ FRP TRP = TP / (TP + FN) 真正例率表示原测试样本中正例被分为正例的比例 FPR = FP /（TN + FP） 假正例率表示原测试样本中反例被分为正例的比例 根据分类器的预测结果对测试样本进行排序，按照此顺序逐个把每个样本作为截断点(阈值)进行预测，每次得到两个指标值，得到ROC曲线，所以ROC体现的是分类器期望性能。 假设在一个二分类中，有正例和反例，那么对于分类结果当然是越多的正例被分出来更好，就是横坐标TRP越大越好，希望误分的反例越少越好，即FPR越小越好。放在具体领域来理解上述两个指标。如在医学诊断中，判断有病的样本。那么尽量把有病的揪出来是主要任务，也就是第一个指标TPR，要越高越好。而把没病的样本误诊为有病的，也就是第二个指标FPR，要越低越好。 类似于将预测结果排序得到分类结果统计图，如下图，左侧为负类分类结果统计图，右侧为正类分类结果统计图，两个图重叠的不跟越少那么分类器的分类性能越好，重叠的越多分类器的性能会越差，当有重叠时选择合适的阈值直接决定了分类器的分类能力。 如下图所示:不同分类性能的分类器对应的ROC曲线，分类能力越好的分类器的ROC曲线越接近左上角 3.2 AUC通过ROC曲线可以对不同分类器进行比较，如果一个分类器完全包住另一个分类器，那么前者的性能一定优于后者，若果曲线之间相交，就要比较ROC曲线下面的面积，即 AUC(Area Under ROC Cure) ，AUC量化了ROC曲线表示的分类器的分类能力。 3.2.1 AUC的含义 The AUC value is equivalent to the probability that a randomly chosen positive example is ranked higher than a randomly chosen negative example. 首先AUC值是一个概率值，当你随机挑选一个正样本以及一个负样本，当前的分类算法根据计算得到的Score值将这个正样本排在负样本前面的概率就是AUC值。当然，AUC值越大，当前的分类算法越有可能将正样本排在负样本前面，即能够更好的分类 AUC值为ROC曲线所覆盖的区域面积，显然，AUC越大，分类器分类效果越好。 AUC = 1，是完美分类器，采用这个预测模型时，不管设定什么阈值都能得出完美预测。 0.5 &lt; AUC &lt; 1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。 AUC = 0.5，随机猜测，模型没有预测价值。 AUC &lt; 0.5，比随机猜测还差；但只要总是反预测而行，就优于随机猜测。 3.2.2 AUC的计算方式4. 代价敏感错误率和代价曲线在现实任务中，不同错误所造成的后果并不一样，代价不相同。例如将健康患者诊断为患病，会增加后续检查的麻烦，而将患病者诊断为健康，后果核能是错失拯救生命的机会，后者误判的代价很明显远大于前者误判。 以二分类为例的代价矩阵如下 假设给定 m+ 个正例和 m- 个负例，D+ 和 D- 分别代表正、反例集合 ，则代价敏感错误率为 在非均等代价下，“代价曲线”可以反映分类器的期望总体代价。x坐标为正例概率代价，如下公式，p为样例为正例的概率。纵轴y为归一化代价FNR为假正例率，FPR为假反例率，FPR=1-FNR 。 代价曲线如下 ，ROC曲线的每个点代表代价平面上的一条线段。 5. 偏差和方差对算法除了通过实验评估学习器的泛化性能，还要分析为神魔有这样的性能，偏差方差分解是解释算法泛化性能的重要工具 5.1 偏差-方差分解那么如何理解方差和偏差呢？ 如下图经典的靶心图，假设红心是最正确的预测值就是样本的真实分类，二蓝色的点为模型对样本的输出值。由图可以观察到左侧两个靶子上的样本蓝点/预测值比较集中方差较小，右侧两个靶子的蓝点相对很分散则方差较大；从横向来看，上面的两个蓝色预测值比较集中的靠近靶心，所以偏差小，二下面的两个靶子中的蓝色点离靶心比较远则偏差比较大。 以回归为例，算法的期望预测为： 方差： 噪声为样本在测试集的实际标记和真实标记的偏差 偏差是期望预测和真实标记的误差 对算法的泛化误差分解 分解结果：泛化误差可以分解为偏差、方差和噪声 注：这个分解形式仅在基于均方误差的回归任务中推导出。 偏差度量了学习算法的期望预测与真实结果的偏离程度，刻画了算法本身的拟合能力 方差度量了同样大小的训练集的变动所导致的的学习性能的变化，刻画了数据扰动所造成的影响 噪声表达了当前任务上任何学习算法所能达到的期望泛化误差的下界。刻画了问题的本身难度 所以泛化性能是由算法的能力、数据的充分性和任务本身难度所共同决定的。 5.2 偏差-方差窘境一般情况下，偏差和方差是有冲突的，这就是偏差方差窘境，如下图所示 对于一个特定的任务，当训练不足时，分类器的拟合能力不足，存在欠拟合，训练数据的扰动不足以使分类器发生显著的变化，这时偏差主导着泛化误差(总体误差)；当加强训练程度时，分类器拟合能力逐渐增强，偏差逐渐变小不再主导误差，训练数据发生的扰动逐渐被学习器学到(即通过不同训练集得到的分类器的拟合能力不相同)，这时方差主导了泛化误差；当训练程度十分充足时，分类器的拟合能力非常的强，训练数据的轻微扰动都会导致分类器发生显著的变化，如果训练数据局部特性、非数据集一般特性被分类器学习到，则发生了过拟合。]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-模型评估与选择]]></title>
    <url>%2F2019%2F01%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%2F</url>
    <content type="text"><![CDATA[模型评估与选择一.误差与过拟合分类器分类错误的样本数占样本总数的比例为错误率(errorate)，E=m/n(m为分类错误的总样本数，n为总样本数），分类的精度(accuracy) P=(1-E)x100% 学习器实际预测值和样本真实值之间的差异为“误差” 训练误差/经验误差：学习器在训练数据上的误差 泛华误差：学习器在新样本上的误差 我们希望得到的是泛化误差尽可能小的学习器，在通过训练数据训练学习器的过程中是在尽可能的最小化训练误差。有时学习器的训练误差非常小，但当遇到新的样本时表现的却不好。因此为了的当泛华能力比较强的学习器，只能让学习器从训练样本中学习到尽可能适应所有样本的普遍规律，要尽可能的学习所有训练样本的共性，这样学习器在遇到引得样本时才会做出正确的判断。通过训练数据训练出的学习器会有两个问题： 过拟合:学习器学习能力过于强大把训练数据学习的太好了，可能把训练样本自身的特点当做了所有样本的一般性质，导致过拟合，是学习器的泛化能力降低。过拟合无法避免，只能尽量减小。 欠拟合：和过拟合相对应，有学习器学习能力过低，对训练样本的一般性质没有学好，欠拟合容易克服，关键的问题是过拟合 二.模型评估和选择方法不同的机器学习算法，同一算法的不同参数配置都是不同的模型，机器学习的模型选择就是对模型的泛化误差进行评估选择泛化误差最小的模型。 通过训练数据得到的学习器，将学习器在在测试数据上的测试误差作为学习器的泛华误差。 训练集与测试集要有如下关系：训练集和测试集都是从样本真实分布中独立同分布采样而得，他们应该尽可能互斥，测试样本尽量不出现在训练样本中。 假设包含m个样例的样本集D={(x1,y1),(x2,y2),...,(xm,ym)},如何划分训练集和测试集的常用方法如下： 留出法直接将样本集D划分为两个互斥的集合D= S U T,S作为训练集，T作为测试集估计分类器的泛化误差。 训练集和测试集的划分要保持数据分布的一致性，避免数据划分引入偏差影响结果。比如在分类任务中要保持两个集合中样本的类别别比例相似。 在使用留出法时不同的划分会得到不同的模型，单次留出法得到的结果往往不够稳定可靠，一般采用若干次留出法随机划分，重复试验评估后取平均值作为留出法的评估结果。并且常将样本集的2/3 ~ 4/5的样本用于训练，剩余的用于测试。 交叉验证法 将样本集D划分为k个大小相似的互斥子集，D=D1 U D2 U…U Dk,每个子集尽可能保持数据分布的一致性， 每次使用k-1个子集的并集作为训练集，剩余的一个子集作为测试集， 这样可以得到k组训练/测试集，进行k次实验，得到的是k次测试结果的均值 交叉验证法评估结果的稳定性很大程度取决于k的取值，因此也称为“k折交叉”验证，k常取10，其他常用值为5，20等。 交叉验证法的特例：留一法(LOO)，k=m 留一法的优点：留一法不受随机样本划分方式的影响，因为m个样本只有唯一的方式划分为m个子集，每个子集一个样本，在多数情况下，留一法中被实际评估的模型和期望评估的用D训练出的模型很相似，评估结果往往被认为很准确。 留一法的缺点：数据集比较大时，计算复杂度高，开销非常大。 自助法自助法采用又放回采样方法，原始样本集D，每次从D中随机挑选一个样本，拷贝到D’中，并放回D中，重复每次，就得到了包含m个样本的数据集D’。通过采样法，初始数据集D中有约36.8%的样本未出现在D’中，D’作为训练集，D/D’作为测试集 总结： 在初始数据集比较充足时，留出法和交叉验证法更常用一些 在数据集比较小，难以有效划分训练/测试集是使用自助法 对于数据集小且可有效划分的时候最好使用留一法来进行划分，因为这种方法最为准确 数据集的分类及作用 训练集 training set： 用于训练模型 验证集 validation set： 用于模型选择 测试集 test set： 用于最终对学习方法的评估 调参机器学习中的两类参数： 算法的参数/超参数 模型的参数 算法的参数往往在实数范围内，因此对每种参数配置都训练出模型是不可能的，现实中往往对每个参数选定一个范围和步长值，这样选定的参数不是最佳的，但这是计算开销和性能估计之间进行这种的结果。调参往往很苦难，工程量大。 三.性能度量衡量模型泛化能力的评价标准就是性能度量，对比不同模型时使用不同的性能度量往往得到不同的评判结果。所以模型好坏是相对的，不仅取决于算法和数据，还决定于任务需求。 1.错误率和精度错误率和精度是分类任务中最常用的两个性能度量 2.查准率，查全率，F1错误率和精度有时不能满足所有的任务度量需求，对于某些问题不光要分类正确，还要求其他更进一步的需求，因此精度不能满足评估需求。比如挑西瓜，我们更关心挑出的西瓜有多少好瓜，或者有多少好瓜被挑选出来了，为了衡量这种指标，引入了查准率和查全率，查准率( precision , 注：分类精度为 accuracy)亦称准确率，查全率(recall)亦称召回率。 对于二分类问题，样本真实类别和分类器预测类别有四种组合： TP 真正例(true positive) FP 假正例(false positive) FN 假反例(false negative) TN 真反例(true negative） TP+FP+FN+TN = 样本总数 查准率：它是相对我们预测结果而言，预测的正例中有多少是真正的正例 查全率：它是相对测试样本而言，样本中的正例有多少被预测出来 查准率和查全率往往是矛盾的，查全率高时，查准率会偏低；二查准率高时，查全率就会偏低。只有在一些简单任务中这两个指标才会都很高 设计了“PR曲线”来综合考虑查全率、查准率的性能度量 在P-R曲线中，如果一个分类器的曲线完全包住另一个分类器的曲线，那么前者的性能优于后者，如果俩个分类器的曲线相交，则很难判断性能的优劣，需要其他指标来衡量。 平衡点(BEP)：曲线查全率等于查准率的点，过于简单 F1：是基于查全率和查准率的调和平均，公式如下： 其中Fβ是F1的更一般形式，因为在实际中不同的应用对查全率和查准率的要求不一样，所有 Fβ 是加权调和平均。β=1 时就是 F1； β&gt;1 时查全率影响更大；0&lt;β&lt;1 时，查准率影响更大些。 3. ROC和AUC3.1 ROCROC是一种度量分类器分类好坏的标准，评估分类器性能的标准有很多，但不同任务不同需求对好坏的标准并不一样。使用最多的标准就是分类精度，但有些现实问题中 accuracy 不能很好地评估分类器的性能。eg. 测试样本中有A类样本90个，B 类样本10个。分类器 C1 把所有的测试样本都分成了A类;分类器 C2 把A类的90个样本分对了70个，B类的10个样本分对了5个;则C1的分类精度为 90%，C2的分类精度为75% 。但是，显然C2更有用些，而且不同问题中分类错误的代价不一样。 很多学习器为测试样本产生一个实值或概率预测，将这个预测值和分类阈值threshol进行比较，大于阈值分为正例，否则分为反例。这个阈值直接决定了分类器的性能即泛化能力。根据分类器对测试样本的预测结果对所有的测试样本进行排序，分类就是在这个排序中选取某个截断点，截断点之前为正例，截断点之后为反例。根据不同的任务需求选取不同的截断点，比如如果更重视查准率，那么就选择的截断点更靠前，如果更重视查全率，选择的截断点更靠后的位置。因此排序质量的好坏，表示综合考虑分类器在不同任务下的“期望泛化性能”的好坏，ROC曲线就是从‘期望性能’的角度评估分类器的性能。 ROC全称是“受试者工作特征”ROC横坐标x为‘真正例率’ TRP，纵坐标y为‘假正利率’ FRP TRP = TP / (TP + FN) 真正例率表示原测试样本中正例被分为正例的比例 FPR = FP /（TN + FP） 假正例率表示原测试样本中反例被分为正例的比例 根据分类器的预测结果对测试样本进行排序，按照此顺序逐个把每个样本作为截断点(阈值)进行预测，每次得到两个指标值，得到ROC曲线，所以ROC体现的是分类器期望性能。 假设在一个二分类中，有正例和反例，那么对于分类结果当然是越多的正例被分出来更好，就是横坐标TRP越大越好，希望误分的反例越少越好，即FPR越小越好。放在具体领域来理解上述两个指标。如在医学诊断中，判断有病的样本。那么尽量把有病的揪出来是主要任务，也就是第一个指标TPR，要越高越好。而把没病的样本误诊为有病的，也就是第二个指标FPR，要越低越好。 类似于将预测结果排序得到分类结果统计图，如下图，左侧为负类分类结果统计图，右侧为正类分类结果统计图，两个图重叠的不跟越少那么分类器的分类性能越好，重叠的越多分类器的性能会越差，当有重叠时选择合适的阈值直接决定了分类器的分类能力。 如下图所示:不同分类性能的分类器对应的ROC曲线，分类能力越好的分类器的ROC曲线越接近左上角 3.2 AUC通过ROC曲线可以对不同分类器进行比较，如果一个分类器完全包住另一个分类器，那么前者的性能一定优于后者，若果曲线之间相交，就要比较ROC曲线下面的面积，即 AUC(Area Under ROC Cure) ，AUC量化了ROC曲线表示的分类器的分类能力。 3.2.1 AUC的含义 The AUC value is equivalent to the probability that a randomly chosen positive example is ranked higher than a randomly chosen negative example. 首先AUC值是一个概率值，当你随机挑选一个正样本以及一个负样本，当前的分类算法根据计算得到的Score值将这个正样本排在负样本前面的概率就是AUC值。当然，AUC值越大，当前的分类算法越有可能将正样本排在负样本前面，即能够更好的分类 AUC值为ROC曲线所覆盖的区域面积，显然，AUC越大，分类器分类效果越好。 AUC = 1，是完美分类器，采用这个预测模型时，不管设定什么阈值都能得出完美预测。 0.5 &lt; AUC &lt; 1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。 AUC = 0.5，随机猜测，模型没有预测价值。 AUC &lt; 0.5，比随机猜测还差；但只要总是反预测而行，就优于随机猜测。 3.2.2 AUC的计算方式4. 代价敏感错误率和代价曲线在现实任务中，不同错误所造成的后果并不一样，代价不相同。例如将健康患者诊断为患病，会增加后续检查的麻烦，而将患病者诊断为健康，后果核能是错失拯救生命的机会，后者误判的代价很明显远大于前者误判。 以二分类为例的代价矩阵如下 假设给定 m+ 个正例和 m- 个负例，D+ 和 D- 分别代表正、反例集合 ，则代价敏感错误率为 在非均等代价下，“代价曲线”可以反映分类器的期望总体代价。x坐标为正例概率代价，如下公式，p为样例为正例的概率。纵轴y为归一化代价FNR为假正例率，FPR为假反例率，FPR=1-FNR 。 代价曲线如下 ，ROC曲线的每个点代表代价平面上的一条线段。 5. 偏差和方差对算法除了通过实验评估学习器的泛化性能，还要分析为神魔有这样的性能，偏差方差分解是解释算法泛化性能的重要工具 5.1 偏差-方差分解那么如何理解方差和偏差呢？ 如下图经典的靶心图，假设红心是最正确的预测值就是样本的真实分类，二蓝色的点为模型对样本的输出值。由图可以观察到左侧两个靶子上的样本蓝点/预测值比较集中方差较小，右侧两个靶子的蓝点相对很分散则方差较大；从横向来看，上面的两个蓝色预测值比较集中的靠近靶心，所以偏差小，二下面的两个靶子中的蓝色点离靶心比较远则偏差比较大。 以回归为例，算法的期望预测为： 方差： 噪声为样本在测试集的实际标记和真实标记的偏差 偏差是期望预测和真实标记的误差 对算法的泛化误差分解 分解结果：泛化误差可以分解为偏差、方差和噪声 注：这个分解形式仅在基于均方误差的回归任务中推导出。 偏差度量了学习算法的期望预测与真实结果的偏离程度，刻画了算法本身的拟合能力 方差度量了同样大小的训练集的变动所导致的的学习性能的变化，刻画了数据扰动所造成的影响 噪声表达了当前任务上任何学习算法所能达到的期望泛化误差的下界。刻画了问题的本身难度 所以泛化性能是由算法的能力、数据的充分性和任务本身难度所共同决定的。 5.2 偏差-方差窘境一般情况下，偏差和方差是有冲突的，这就是偏差方差窘境，如下图所示 对于一个特定的任务，当训练不足时，分类器的拟合能力不足，存在欠拟合，训练数据的扰动不足以使分类器发生显著的变化，这时偏差主导着泛化误差(总体误差)；当加强训练程度时，分类器拟合能力逐渐增强，偏差逐渐变小不再主导误差，训练数据发生的扰动逐渐被学习器学到(即通过不同训练集得到的分类器的拟合能力不相同)，这时方差主导了泛化误差；当训练程度十分充足时，分类器的拟合能力非常的强，训练数据的轻微扰动都会导致分类器发生显著的变化，如果训练数据局部特性、非数据集一般特性被分类器学习到，则发生了过拟合。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-IO概述]]></title>
    <url>%2F2018%2F12%2F13%2FJava-IO%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Java IO概述Java IO是一套提供输入输出（读写数据）功能的API，提供了java.io 包 Java IO的构成概述java.io包中主要包括了五个类和一个接口： File:文件类，用于文件的管理 InputStream:字节输入流类，二进制格式操作，基于字节的输入，是所有字节输入流类的父类 OutputStream:字节输出流类，二进制格式操作，基于字节的输出，是所有字节输出流类的父类 Reader:字符输入流类，文件格式操作，基于字符的输入操作，是所有字符输入流类的父类 Writer:字符输出流类，文件格式操作，基于字符的输出操作，是所有字符输入流类的父类 RandomAccessFile:可以在文件的任意位置进行存取操作 Serializable: 下面是一张通过输入、输出、基于字节或者字符、以及其他比如缓冲、解析之类的特定用途划分的大部分Java IO类的表格 Java IO关注的是从原始数据源读取数据输出原始数据到目标介质 ，主要的数据源和目标介质有 文件 管道 Java中的管道是为运行在同一个JVM中的两个线程提供通信能力 在Java中使用管道时，通信的双方应该是运行在同一进程中的不同线程 网络连接 内存缓存 System.in,System.out,System.error(Java标准的输入输出) 一个程序需要InputStream或者Reader从数据源读取数据，需要OutputStream或者Writer将数据写入到目标媒介中 Java IO的分类根据数据流向： 输入流-读取数据 输出流-写数据 根据处理的数据类型： 字节流：数据流中最小的数据单元是字节 字符流：数据流中最小的数据单元是字符，Java中的字符是Unicode编码，一个字符占用两个字节，因为数据编码的不同，而有了对字符进行高效操作的流对象，本质其实就是基于字节流读取时，去查了指定的码表。 注解： 采用数据流的目的是使输入输出独立于设备，不用关心设备 对于程序来说，输出流是往存储介质或数据通道写入数据，而输入流是从存储介质或数据通道中读取数据 只读或只写，每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流 File类-文件管理File类用于管理文件的类，包括创建文件，删除文件，获取文件路径、文件名等，做判断过滤等功能 构造方法 public File(String pathname) 通过将给定的路径名字符串转换为抽象路径名来创建新的File实例 public File(String parent,String child) 从父路径名字符串和子路径名字符串创建新的File实例 public File(File parent,String child) 从父抽象路径名和子路径名字符串创建新的File实例 成员方法： 创建功能： public boolean createNewFile() throws IOException 当且仅当具有该名称的文件尚不存在时，原子地创建一个由该抽象路径名命名的新的空文件 public boolean mkdir() 创建文件夹 public boolean mkdirs() 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目 删除功能： public boolean delete() 删除由此抽象路径名表示的文件或目录 重命名： public boolean renameTo(File dest) 判断： public boolean isDirectory() 判断是否是目录 public boolean isFile() 判断是否是文件 public boolean exists() 判断是否存在 public boolean canRead() 判断是否可读 public boolean canWrite() 判断是否可写 public boolean isHidden() 判断是否隐藏 获取： public String getAbsolutePath() 获取绝对路径 public String getPath() 获取相对路径 public String getName() 获取名称 public long length() 获取长度，字节数 public long lastModified() 获取最后一次修改时间 public String[] list() 获取指定目录下所有文件夹或文件名称的数组 public File[] listFiles() 获取指定目录下所有文件夹或文件的File的数组 文件名称过滤器FilenameFilter public String[] list(FilenameFilter filter) public File[] listFiles(FilenameFilter filter) 字节流InputStream InputStream FileInputStream BufferedInputStream]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-图(最短路径)]]></title>
    <url>%2F2018%2F11%2F13%2FJava%E7%AE%97%E6%B3%95-%E5%9B%BE-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[最短路径最短路径应用的图是加权有向图加权有向图的数据结构：首先定义的是加权有向边的数据类型：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class DirectEdge &#123; private int v;//边的起点 private int w;//边的终点 private double weight;//边的权重 public DirectEdge(int v,int w,double weight)&#123; this.v=v; this.w=w; this.weight=weight; &#125; public double weight()&#123; return weight; &#125; public int from()&#123; return v; &#125; public int to()&#123; return w; &#125; public String toString()&#123; return String.format("%d-&gt;%d %.2f", v,w,weight); &#125;&#125; ``` 在加权有向边的基础上定义加权有向图 ```javapublic class EdgeWeightDigraph &#123; private int V; private int E; private Bag&lt;DirectEdge&gt;[] adj; public EdgeWeightDigraph(int V)&#123; this.V=V; this.E=0; adj=(Bag&lt;DirectEdge&gt;[])new Bag[V]; for(int v=0;v&lt;V;v++)&#123; adj[v]=new Bag&lt;DirectEdge&gt;(); &#125; &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; public void addEdge(DirectEdge e)&#123; int v=e.from(); adj[v].add(e); E++; &#125; public Iterable&lt;DirectEdge&gt; adj(int v)&#123; return adj[v]; &#125; public Iterable&lt;DirectEdge&gt; edges()&#123; Bag&lt;DirectEdge&gt; bag=new Bag&lt;DirectEdge&gt;(); for(int v=0;v&lt;V;v++)&#123; for(DirectEdge e:adj[v])&#123; bag.add(e); &#125; &#125; return bag; &#125;&#125; 最短路径：从图的一个顶点到达另一个顶点的成本最小(权重和最小)的路径，这里的最短路径是单点最短路径最短路径树： 给定一幅加权有向图和顶点s，可以找到一个以s为起点的最小路径树，他是图的一幅子图，包含了顶点s和所有s可达的顶点。树的根节点是s，树的每一条路径都是有向图中的一条最短路径 最短路径算法原理边的松弛顶点的松弛最短路径的最优条件：一幅有向加权图G,顶点s为起点，distTo[]保存着起点s到任意顶点v的路径长度，若s到v不可达，该值为无穷大。当且仅当对于从v到w的任意一条边e，满足distTo[w]&lt;=distTo[v]+e.weight()条件时，才是最短路径 Dijkstra算法 算法思想1) 首先Dijkstra算法只适用在权值非负的加权有向图 如下图所示，E(v2,v5)为负值，如果想找到v5到v4的最短路径，那么这一条路径：v5-&gt;v4-&gt;v2-&gt;v5-&gt;v4的权值之和为-6，如此一直沿着这条路径循环，那么v5到v4的路径权重之和会越来越小，趋近于负无穷，那么这两个顶点之间的最短路径无法确定。我们称图中这样的循环为负值圈，有向图中出现负值圈时，最短路径的问题就无法确定。 2）Dijkstra算法的思想 首先确定源点s，dist[v]表示的是从s到v的最短路径距离 Dijkstra算法每次从没有确定最短路径的顶点中选择dist[]值最小的顶点v，对v的所有边进行松弛，如此操作直到确定所有顶点的最短路径 算法实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Dijkstra &#123; private DirectEdge[] edgeTo; private double[] distTo; private IndexMinPQ&lt;Double&gt; pq; public Dijkstra(EdgeWeightDigraph G,int s)&#123; edgeTo=new DirectEdge[G.V()]; distTo=new double[G.V()]; pq=new IndexMinPQ&lt;Double&gt;(G.V()); //初始化distTo所有项为正无穷 for(int v=0;v&lt;G.V();v++)&#123; distTo[v]=Double.POSITIVE_INFINITY; &#125; //起始点设置为0 distTo[s]=0.0; //将起始点入队 pq.insert(s, 0.0); while(!pq.isEmpty())&#123; relax(G,pq.deleteMin()); &#125; &#125; private void relax(EdgeWeightDigraph G,int v)&#123; for(DirectEdge e:G.adj(v))&#123; int w=e.to(); if(distTo[w]&gt;distTo[v]+e.weight())&#123; distTo[w]=distTo[v]+e.weight(); edgeTo[w]=e; if(pq.contains(w))&#123; pq.changeKey(w, distTo[w]); &#125;else&#123; pq.insert(w, distTo[w]); &#125; &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return distTo[v]&lt;Double.POSITIVE_INFINITY; &#125; public double distTo(int v)&#123; return distTo[v]; &#125; public Iterable&lt;DirectEdge&gt; pathTo(int v)&#123; Stack&lt;DirectEdge&gt; stack=new Stack&lt;DirectEdge&gt;(); while(edgeTo[v]!=null)&#123; stack.push(edgeTo[v]); v=edgeTo[v].from(); &#125; return stack; &#125;&#125; 算法分析 Dijkstra算法时间复杂度取决于存储顶点的数据结构 上面算法的实现使用的是最小优先队列，每次删除最小距离顶点时间复杂度为logV，整个算法需要对每条边松弛，所以基于最小优先队列的Dijkstra算法的时间复杂度为ElogV 基于拓扑排序的最短路径算法 算法原理 将图按照拓扑排序的顺序放松顶点 这种算法只能应用在无环有向图中，并且它允许图的边的权重是负值，他还能解决相关的问题比如最长路径 算法实现 12345678910111213141516171819202122232425262728293031323334353637383940//利用拓扑排序实现的最短路径算法 public class AcyclicSP &#123; private DirectEdge[] edgeTo; private double[] distTo; public AcyclicSP(EdgeWeightDigraph G,int s)&#123; edgeTo=new DirectEdge[G.V()]; distTo=new double[G.V()]; for(int v=0;v&lt;G.V();v++)&#123; distTo[v]=Double.POSITIVE_INFINITY; &#125; distTo[s]=0.0; TopoEdgeWeight top=new TopoEdgeWeight(G); for(int v:top.order())&#123; relax(G,v); &#125; &#125; private void relax(EdgeWeightDigraph G,int v)&#123; for(DirectEdge e:G.adj(v))&#123; int w=e.to(); if(distTo[w]&gt;distTo[v]+e.weight())&#123; distTo[w]=distTo[v]+e.weight(); edgeTo[w]=e; &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return distTo[v]&lt;Double.POSITIVE_INFINITY; &#125; public double distTo(int v)&#123; return distTo[v]; &#125; public Iterable&lt;DirectEdge&gt; pathTo(int v)&#123; Stack&lt;DirectEdge&gt; stack=new Stack&lt;DirectEdge&gt;(); while(edgeTo[v]!=null)&#123; stack.push(edgeTo[v]); v=edgeTo[v].from(); &#125; return stack; &#125; &#125; 在查找最短路径之前需要对图进行拓扑排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class TopoEdgeWeight &#123; private boolean marked[]; private Stack&lt;Integer&gt; stack; public TopoEdgeWeight(EdgeWeightDigraph G)&#123; marked=new boolean[G.V()]; stack=new Stack&lt;Integer&gt;(); EdgeWeightDigraphCycle cycle=new EdgeWeightDigraphCycle(G); if(!cycle.hasCycle())&#123; TopoSort(G); &#125; &#125; private void TopoSort(EdgeWeightDigraph G)&#123; for(int v=0;v&lt;G.V();v++)&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; private void dfs(EdgeWeightDigraph G,int v)&#123; marked[v]=true; for(DirectEdge e:G.adj(v))&#123; if(!marked[e.to()])&#123; dfs(G,e.to()); &#125; &#125; stack.push(v); &#125; public Iterable&lt;Integer&gt; order()&#123; return stack; &#125;&#125;``` 在拓扑排序之前需要检查图是不是无环图 ```javapublic class EdgeWeightDigraphCycle &#123; private boolean[] marked; private DirectEdge[] edgeTo; private Stack&lt;DirectEdge&gt; cycle; private boolean[] onStack; public EdgeWeightDigraphCycle(EdgeWeightDigraph G)&#123; marked=new boolean[G.V()]; edgeTo=new DirectEdge[G.V()]; onStack=new boolean[G.V()]; for(int v=0;v&lt;G.V();v++)&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; private void dfs(EdgeWeightDigraph G,int v)&#123; marked[v]=true; onStack[v]=true; for(DirectEdge e:G.adj(v))&#123; int w=e.to(); if(hasCycle())&#123; return; &#125;else if(!marked[w])&#123; edgeTo[w]=e; dfs(G,w); &#125;else if(onStack[w])&#123; cycle=new Stack&lt;DirectEdge&gt;(); DirectEdge f=e; while(f.from()!=w)&#123; cycle.push(f); f=edgeTo[f.from()]; &#125; cycle.push(f); return; &#125; &#125; onStack[v]=false; &#125; public boolean hasCycle()&#123; return cycle!=null; &#125; public Iterable&lt;DirectEdge&gt; cycle()&#123; return cycle; &#125;&#125; 算法分析基于拓扑排序的最短路径算法是一种比Dijkstra算法更快更简单的在无环加权有向图中找到最短路径的算法基于拓扑排序的最短路径算法的时间复杂度是O(V+E) Floyd算法 算法原理 从任意节点v到节点w最短路径有两种情况：第一种是直接从v到w；第二种是从v经过若干个节点到达w，对图中的每个节点k，检查dist(v,k)+dist(k,w)&lt;dist(v,w)是否成立，如果成立，那么更新v到w的最短路径为dist(v,k)+dist(k,w)，如此当我们遍历完图中所有的节点之后，v到w的最短路径和最短距离就确定了。 此算法就是一任意的顺序放松图中所有的边，重复V轮。 算法实现三重循环实现 for (int k=0; k&lt;n; ++k) { for (int i=0; i&lt;n; ++i) { for (int j=0; j&lt;n; ++j) { if (dist[i][k] + dist[k][j] &lt; dist[i][j] ) { dist[i][j] = dist[i][k] + dist[k][j]; path[i][j] = path[k][j]; } } } } 算法分析 Floyd算法的时间复杂度为：O(V3) Bellman-Ford算法Bellman-ford算法是求含负权图的单源最短路径算法，效率很低，但代码很容易写 算法原理利用队列 算法实现 public class BellmanFord { private double[] distTo; private DirectEdge[] edgeTo; private boolean[] onQ;//该顶点是否在队列中 private Queue&lt;Integer&gt; queue;//用于存放将被放松的顶点 private int cont;//放松的次数 private Iterable&lt;DirectEdge&gt; cycle; public BellmanFord(EdgeWeightDigraph G,int s){ distTo=new double[G.V()]; edgeTo=new DirectEdge[G.V()]; onQ=new boolean[G.V()]; queue=new Queue&lt;Integer&gt;(); for(int v=0;v&lt;G.V();v++){ distTo[v]=Double.POSITIVE_INFINITY; } queue.enqueue(s); onQ[s]=true; distTo[s]=0.0; while(!queue.isEmpty() &amp;&amp; hasNegativeCycle()){ int v=queue.dequeue(); onQ[v]=false; relax(G,v); } } private void relax(EdgeWeightDigraph G,int v){ for(DirectEdge e:G.adj(v)){ int w=e.to(); if(distTo[w]&gt;distTo[v]+e.weight()){ distTo[w]=distTo[v]+e.weight(); edgeTo[w]=e; if(!onQ[w]){ queue.enqueue(w); onQ[w]=true; } } if(cont++ % G.V() ==0){ findNegativeCycle(); } } } public void findNegativeCycle(){ int V=edgeTo.length; EdgeWeightDigraph bf=new EdgeWeightDigraph(V); for(int v=0;v&lt;V;v++){ if(edgeTo[v]!=null){ bf.addEdge(edgeTo[v]); } } EdgeWeightDigraphCycle cf=new EdgeWeightDigraphCycle(bf); cycle=cf.cycle(); } public boolean hasNegativeCycle(){ return cycle!=null; } public Iterable&lt;DirectEdge&gt; negativeCycle(){ return cycle; } public boolean hasPathTo(int v){ return distTo[v]&lt;Double.POSITIVE_INFINITY; } public double distTo(int v){ return distTo[v]; } public Iterable&lt;DirectEdge&gt; pathTo(int v){ Stack&lt;DirectEdge&gt; stack=new Stack&lt;DirectEdge&gt;(); while(edgeTo[v]!=null){ stack.push(edgeTo[v]); v=edgeTo[v].from(); } return stack; } } 算法分析 BellmanFord算法的时间复杂度一般情况为O(E+V),最坏情况为O(VE)]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorihtms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-图（最小生成树）]]></title>
    <url>%2F2018%2F11%2F04%2FJava%E7%AE%97%E6%B3%95-%E5%9B%BE%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最小生成树定义：加权图：加权图是图中每条边都关联一个权值的图模型(边的权重可以表示距离、时间、费用等不同变量；权中可正可负)带权重边的表示：1234567891011121314151617181920212223242526272829303132333435public class Edge implements Comparable&lt;Edge&gt; &#123; private int v; private int w;//v,w为边连接的两个顶点 private double weight;//边的权重 public Edge(int v,int w,double weight)&#123; this.v=v; this.w=w; this.weight=weight; &#125; public double weight()&#123; return weight; &#125; public int either()&#123; return v; &#125; public int other(int vertex)&#123; if(vertex==v)&#123; return w; &#125;else if(vertex==w)&#123; return v; &#125;else&#123; throw new RuntimeException("Inconsistent edge"); &#125; &#125; @Override public int compareTo(Edge that)&#123; if(this.weight()&lt;that.weight())&#123; return -1; &#125;else if(this.weight()&gt;that.weight())&#123; return 1; &#125;else&#123; return 0; &#125; &#125;&#125;无向加权图的表示：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 public class EdgeWeightGraph &#123; private int V; private int E; private Bag&lt;Edge&gt;[] adj; public EdgeWeightGraph(int V)&#123; this.V=V; this.E=0; adj=(Bag&lt;Edge&gt;[])new Bag[V]; for(int v=0;v&lt;V;v++)&#123; adj[v]=new Bag&lt;Edge&gt;(); &#125; &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; //添加边 public void addEdge(Edge e)&#123; int v=e.either(); int w=e.other(v); adj[v].add(e); adj[w].add(e); E++; &#125; public Iterable&lt;Edge&gt; adj(int v)&#123; return adj[v]; &#125; //返回图中所有的边 public Iterable&lt;Edge&gt; edges()&#123; Bag bag=new Bag&lt;Edge&gt;(); for(int v=0;v&lt;V;v++)&#123; for(Edge e:adj[v])&#123; if(e.other(v)&gt;v)&#123; bag.add(e); &#125; &#125; &#125; return bag; &#125; //显示图表 public String toString()&#123; StringBuilder s=new StringBuilder(); s.append(V+"Vertexs"+E+"Edges\n"); for(int v=0;v&lt;V;v++)&#123; s.append(v+":"); for(Edge e:adj[v])&#123; s.append(e+" "); &#125; s.append("\n"); &#125; return s.toString(); &#125;&#125; 生成树：一幅图的生成树是它的一棵含有其所有顶点的无环连通子图最小生成树(MST)：一幅图的最小生成树是它的一棵所有边权值和最小的生成树(生成树+所有边权值和最小) 切分定理图的切分：将图中所有的顶点分为两个非空且不重叠的两个集合，横切边(crossing edge)是一条连接两个属于不同集合中顶点的边切分定理：一幅加权图中，对于图的任意切分的横切边中的权重最小的边一定属于改图的最小生成树切分定理会把加权图所有的顶点分为两个集合，检查每次切分的横切边并识别属于最小生成树的边最小生成树的贪心算法： 生成最小生成树的基础是切分定理，对于一个V个顶点的加权图，使用切分定理找到最小生成树的一条边，不断重复直到找到最小生成树所有的V-1条边 最小生成树Prim算法prim算法的核心是选取一个顶点，每一次向树中添加一条边，知道添加V-1条边；每次添加的边是连接树中的顶点和不在树中的顶点所连接的边中权重值最小的。注：连接树：最小生成树的一部分横切边:为连接树中的顶点和不在连接树中的顶点之间的所有边失效边:如果一条边的两个顶点都在连接树中，则为失效边不去管它 prim算法延时实现过程： 选取一个起始顶点作为生成树的第一个顶点，将此时所有的横切边加入优先队列（MinPQ） 检查队列while(队列不空)： 取出并删除队列中的权重值最小的边 if(这条边失效) contuine结束此次循环 if(这条边有一个顶点不在连接树上)将这个顶点添加到树中，并将新的横切边添加到优先队列中 算法改进：prim算法即时实现延时实现是一些失效的横切边保存在优先队列中(当向连接树添加一个新的顶点v时，所有和v相关联的横切边都会被加入到优先队列中)，只有要删除的时候才检查它的有效性Prim实时实现是不去保存所有的横切边，它只保存连接树顶点和非树顶点中权重最小的边试想：当我们向连接树中添加了一个新的顶点v，那么非树顶点w可能距离连接树的距离更近了，我们只保存非树顶点w和树顶点距离最近的那条边。可能队列中保存着w到连接树的权重最小的边w-&gt;k,当连接树中加入了v之后，w-&gt;v这条边的权重值比w-&gt;k的权重值要小，那么在优先队列中对于顶点w，它和连接树距离最短的边更新为w-&gt;v。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class PrimMST&#123; private Edge[] edgeTo;//用来存储非树顶点距离树最近的边 private double[] distTo;//用来存储边的权重，distTo[i]=edgeTo[i].weight() private boolean[] marked;//用来标记顶点是否在树中 private IndexMinPQ&lt;Double&gt; pq;//存储有效的横切边 public PrimMST(EdgeWeightGraph G)&#123; edgeTo=new Edge[G.V()]; distTo=new double[G.V()]; marked=new boolean[G.V()]; pq=new IndexMinPQ&lt;Double&gt;(G.V()); for(int i=0;i&lt;G.V();i++)&#123; distTo[i]=Double.POSITIVE_INFINITY; &#125; //从顶点0开始 distTo[0]=0.0; pq.insert(0, 0.0); while(!pq.isEmpty())&#123; visit(G,pq.deleteMin()); &#125; //当向最初的树中添加V-1条边后，最小生成树完成而优先队列变为空 &#125; private void visit(EdgeWeightGraph G,int v)&#123; //将v添加至树中，更新相关数据 marked[v]=true; //遍历和v相连的每一个顶点 for(Edge e:G.adj(v))&#123; int w=e.other(v); if(marked[w])&#123; continue; &#125; //检查distTo中存储的是否是w距树最小的距离 if(e.weight()&lt;distTo[w])&#123; edgeTo[w]=e; distTo[w]=e.weight(); //添加或更新优先队列中的相关顶点的数据 if(pq.contains(w))&#123; pq.changeKey(w, distTo[w]); &#125;else&#123; pq.insert(w, distTo[w]); &#125; &#125; &#125; &#125; //遍历最小生成树中的所有边 public Iterable&lt;Edge&gt; edges()&#123; Queue&lt;Edge&gt; q=new Queue&lt;Edge&gt;(); for(int v=0;v&lt;edgeTo.length;v++)&#123; Edge e=edgeTo[v]; if(e!=null)&#123; q.enqueue(e); &#125; &#125; return q; &#125;&#125; Kruskal算法Kruskal算法的核心是将图中所有的边按权重由小到大的顺序加入最小生成树，新加入的边不能与已经加入的边构成环。12345678910111213141516171819202122232425262728 public class KruskalMST &#123; private Queue&lt;Edge&gt;mst; public KruskalMST(EdgeWeightGraph G)&#123; mst=new Queue&lt;Edge&gt;(); //创建最小优先队列，并存储图中所有的边 MinPQ&lt;Edge&gt; pq=new MinPQ&lt;Edge&gt;(G.E()); for(Edge e:G.edges())&#123; pq.insert(e); &#125; //创建并查集Union_Find中的一个形式Quick_find Quick_find uf=new Quick_find(G.V()); while(!pq.isEmpty() &amp;&amp; mst.size()&lt;G.V()-1)&#123; Edge e=pq.deleteMin(); int v=e.either(); int w=e.other(v); //判断这条边的两个顶点是否连通，如果已经连通那么再加入这条边就会形成一个环 if(uf.connected(v, w))&#123; continue; &#125; uf.union(v, w); mst.enqueue(e); &#125; &#125; public Iterable&lt;Edge&gt; edges()&#123; return mst; &#125;&#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-图]]></title>
    <url>%2F2018%2F10%2F10%2FJava%E7%AE%97%E6%B3%95-%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[无向图图的定义：A graph is a set of vertices and a collections of edges that each connect a pair of vertices.graph = edge + vertex 图的表示邻接矩阵假设图有V个顶点，使用一个V*V的布尔矩阵a来表示图，顶点v和顶点w相连那么a[v,w]和a[w,v]都设置为true，相连设置为false。 邻接矩阵在存储一个较大的图时是不可行的，所需要的巨大的空间无法满足。 邻接表邻接表是一个一顶点vertex为索引的列表数组，每一个索引代表一个顶点，数组在该索引处的元素是和该顶点相连接的顶点列表。使用邻接表实现的图有如下特点： 创建图使用的空间和V+E成正比 添加一条边时间为常数 遍历顶点v相邻的顶点所需时间和v的度数成正比 用邻接表创建的Graph数据结构：12345678910111213141516171819202122232425262728293031323334353637383940414243public class Graph &#123; private int V; //顶点数目 private int E; //边的条数 private Bag&lt;Integer&gt;[] adj; //邻接表 public Graph()&#123;&#125; //初始化顶点为V的邻接表 public Graph(int V)&#123; this.V=V; this.E=0; adj=(Bag&lt;Integer&gt;[]) new Bag[V]; for(int i=0;i&lt;V;i++)&#123; adj[i]=new Bag&lt;Integer&gt;(); &#125; &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; public void addEdg(int v,int w)&#123; adj[v].add(w); adj[w].add(v); E++; &#125; public Iterable&lt;Integer&gt; adj(int v)&#123; return adj[v]; &#125; public int degree(int v)&#123; return adj[v].size(); &#125; public String toString()&#123; String s=V+" vertices"+E+" edges\n"; for(int i=0;i&lt;V;i++)&#123; s+=i+":"; for(int j:this.adj[i])&#123; s+=j+" "; &#125; s+="\n"; &#125; return s; &#125;&#125; 深度优先搜索深度优先搜索类似于走迷宫的Tremaux搜索。从一个没有走过的路口开始，走过的路铺一条绳子；标记走过的路口；当来到标记的路口，一直回退到有没被标记的路口继续走，如果回退时一直无路可走就一直回退到起点。 深度优先搜索类似于走迷宫，一直寻找没有被访问的节点深度优先搜索需要用递归的方法遍历图中所有的顶点 将访问的节点标记 递归的访问它的所有没有被标记的邻居节点深度优先代码如下： 12345678910111213141516171819202122public class DFS&#123; private boolean[] marked; private int count; public DFS(Graph G,int s)&#123; marked=new boolean[G.V()]; dfs(G,s); &#125; private void dfs(Graph G,int s)&#123; marked[s]=true; for(int v:G.adj[s])&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; public boolean marked(int w)&#123; return marked[m]; &#125; public int count()&#123; return count; &#125;&#125; 下面是DFS的搜索轨迹图： 深度优先搜索可以遍历图中所有的顶点和边，利用DFS可以解决图中的一些问题： 连通性问题：给定的两个顶点是否相连 单点问题，路径问题：某一起点与任意联通顶点的路径下面为利用DFS查找图中的路径的算法程序 12345678910111213141516171819202122232425262728293031323334353637 public class DepthFirstPaths &#123; private boolean[] marked;//用于标记顶点是否被访问过 private int[] edgeTo; //记录从起点到一个顶点的路径上的最后一个顶点 private int s; public DepthFirstPaths(Graph G,int s)&#123; this.s=s; marked=new boolean[G.V()]; edgeTo=new int[G.V()]; dfs(G,s); &#125; //深度优先算法DFS private void dfs(Graph G,int v)&#123; marked[v]=true; for(int w:G.adj(v))&#123; if(!marked[w])&#123; edgeTo[w]=v; dfs(G,w); &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return marked[v]; &#125; //返回起点到某个顶点的路径 public Iterable&lt;Integer&gt; pathTo(int v)&#123; if(!hasPathTo(v))&#123; return null; &#125; Stack&lt;Integer&gt; path=new Stack&lt;Integer&gt;(); for(int x=v;x!=s;x=edgeTo[x])&#123; path.push(x); &#125; path.push(s); return path; &#125;&#125; 下图为DFS搜索路径的轨迹实例图 广度优先搜索我们常要解决的问题是图中两个点之间最短的路径问题，DFS可以找出两点间的联通路径，却没办法找到最短的路径，但广度优先搜索可以解决这个问题。 在广度优先搜索中我们是按照与起点的距离的顺序遍历所有结点，这里用到了队列（先进先出，就近遍历）；首先将起点标记并加入队列，重复以下步骤直到队列为空： 将队列中的下一个顶点v出队，并将其标记； 将与v相邻且未被标记的顶点按顺序依次入队；BFS搜索路径算法： 12345678910111213141516171819202122232425262728293031323334353637383940414243 public class BreadthFirstPaths &#123; private boolean[] marked;//用于标记顶点是否被访问过 private int[] edgeTo; //记录从起点到一个顶点的路径上的最后一个顶点 private int s; public BreadthFirstPaths(Graph G,int s)&#123; this.s=s; marked=new boolean[G.V()]; edgeTo=new int[G.V()]; bfs(G,s); &#125; //广度优先算法BFS private void bfs(Graph G,int s)&#123; Queue&lt;Integer&gt; queue=new Queue&lt;Integer&gt;(); marked[s]=true; queue.enqueue(s); while(!queue.isEmpty())&#123; int v=queue.dequeue(); for(int w:G.adj(v))&#123; if(!marked[w])&#123; edgeTo[w]=v; marked[w]=true; queue.enqueue(w); &#125; &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return marked[v]; &#125; //返回起点到某个顶点的路径 public Iterable&lt;Integer&gt; pathTo(int v)&#123; if(!hasPathTo(v))&#123; return null; &#125; Stack&lt;Integer&gt; path=new Stack&lt;Integer&gt;(); for(int x=v;x!=s;x=edgeTo[x])&#123; path.push(x); &#125; path.push(s); return path; &#125;&#125; 下图为BFS实例中搜索轨迹图： 用BFS检测给定的图是无环的吗。用BFS检测是否是二分图（即任意一条边的两个顶点都不属于同一连通集） DFS和BFS具有不同的搜索路径： 深度优先搜索是不断深入图中，探索距离起点越来越远的顶点，只有碰到访问过的顶点或者死胡同时才返回到最近的顶点；广度优先搜索像扇面一样前进，它只有访问了一个顶点附近相邻的所有顶点之后才继续向前探索；DFS的路径通常长而曲折，而BFS路径短而整齐直接。 如下图所示两种搜索方式的路径对比： 连通分量DFS解决连通性问题用深度优先搜索来查找图中所有的连通分量的算法123456789101112131415161718192021222324252627282930313233343536public class CC&#123; private boolean[] marked; //用来标记顶点是否被访问过 private int[] id; //用来标记所属的连通集 private int count; //表示连通集 public CC(Graph G)&#123; marked=new boolean(G.V()); id=new int(G.V()); for(int s=0;s&lt;G.V();s++)&#123; if(!marked[s])&#123; dfs(G,s); count++; &#125; &#125; &#125; public dfs(Graph G,int v)&#123; marked[v]=true; id[v]=count; for(int s:G.adj[v])&#123; if(!marked[s])&#123; dfs(G,s); &#125; &#125; &#125; //判断两个顶点是否属于同一个连通分量 public boolean connect(int v,int w)&#123; return id[v]==id[w]; &#125; //返回顶点所在的连通集 public int id(int v)&#123; return id[v]; &#125; //返回有几个连通分量 public int count()&#123; return count; &#125;&#125;下图为搜索图中所有连通分量的轨迹： 并查集解决连通性问题Union_Find：并查集能解决动态连通性问题，union()会将两个分量合并到同一连通分量，fins()会返回给定点所在的连通分量的标识符，connect()会判断两个点是否在同一连通分量，count()会返回连通分量的数量。123456789101112131415161718192021 //并查集抽象类，关键的是抽象的方法find和union abstract class Union_Find &#123; protected int[] id; protected int count; public Union_Find(int N)&#123; count=N; id=new int[N]; for(int i=0;i&lt;N;i++)&#123; id[i]=i; &#125; &#125; public int count()&#123; return count; &#125; public boolean connected(int p,int q)&#123; return find(p)==find(q); &#125; public abstract int find(int p); public abstract void union(int p,int q); &#125; Quick Find快速查找算法：id[]这个数组标记着结点所在的连通集，将在同一连通集的结点的id[]值设置为同一个值，当将两个连通集合并的时候，将一个连通集内的所有结点的id[]值改为另一个连通集的id[]值。 这种算法不适合处理大型问题，以为find速度很快，但是union速度非常慢，需要将其中一个连通分量中的所有节点 id 值都修改为另一个节点的 id 值 1234567891011121314151617181920212223 //快速查找算法public class Quick_find extends Union_Find &#123; public Quick_find(int N)&#123; super(N); &#125; public int find(int p)&#123; return id[p]; &#125; public void union(int p,int q)&#123; int pID=find(p); int qID=find(q); if(pID==qID)&#123; return; &#125; for(int i=0;i&lt;id.length;i++)&#123; if(id[i]==pID)&#123; id[i]=qID; &#125; &#125; count--; &#125;&#125; Quick Union需要一种快速union的算法，只需要修改一下id[]数组的结构，每个点对应的id[]元素都是同一连通分量的其它点，这叫做链接。一个结点由链接找到指向它的另一个结点，这个节点再继续查找，以此类推知道找到这个连通集的根节点，类似以树结构。 union操作时只需将一个连通集的根节点指向另一个连通集的根节点 这种算法union操作很高效，find操作时间复杂度和树的高度成正比，最坏情况下树的高度为结点个数 quick-union算法123456789101112131415161718192021//快速合并算法public class Quick_Union extends Union_Find &#123; public Quick_Union(int N) &#123; super(N); &#125; public int find(int p)&#123; while(p!=id[p])&#123; p=id[p]; &#125; return p; &#125; public void union(int p,int q)&#123; int pID=find(p); int qID=find(q); if(pID==qID)&#123; return; &#125; id[pID]=qID; count--; &#125;&#125; 加权Quick Union为了防止quick-union最坏情况的发生，改进quick-union为加权quick-union算法 做法是记录被一个连通集的大小，union时将小的连通集指向大的连通集，这样生成的连通集会很平衡 加权的quick-union算法能够实现lgN对数级别的性能 123456789101112131415161718192021222324252627282930313233343536373839404142434445 //加权快速合并算法public class WeightedQuickUnion &#123; private int[] id; private int[] sz; private int count; public WeightedQuickUnion(int N)&#123; count=N; id=new int[N]; for(int i=0;i&lt;N;i++)&#123; id[i]=i; &#125; sz=new int[N]; for(int i=0;i&lt;N;i++)&#123; sz[i]=1; &#125; &#125; public int count()&#123; return count; &#125; public boolean connected(int p,int q)&#123; return find(p)==find(q); &#125; public int find(int p)&#123; while(p!=id[p])&#123; p=id[p]; &#125; return p; &#125; public void union(int p,int q)&#123; int pID=find(p); int qID=find(q); if(pID==qID)&#123; return; &#125; if(sz[pID]&lt;sz[qID])&#123; id[pID]=qID; sz[qID]+=sz[pID]; &#125;else&#123; id[qID]=pID; sz[pID]+=sz[qID]; &#125; count++; &#125;&#125; 有向图有向图：由一组顶点和一组有向的边组成的。 有向图也用邻接表表示，与无向图不同的是无向图制定了a通向b，即a-&gt;b,那么同时就有b-&gt;a;但有向图不一样，当指定了a-&gt;b没有b-&gt;a。 有向图的数据结构只有addEdg()方法不同，去掉注释的语句：12345public void addEdg(int v,int w)&#123; adj[v].add(w); #adj[w].add(v); E++;&#125; 有向图的可达性单点可达性：一个图和一个起点s–&gt;是否存在从s到v的有向路径多点可达性： 一个图和一个顶点集合–&gt;是否存在从集合任意顶点到达给定顶点的有向路径 12345678910111213141516171819202122232425262728293031 public class DirectedDFS &#123; private boolean[] marked; //单点可达判断 public DirectedDFS(Digraph G,int s)&#123; marked=new boolean[G.V()]; dfs(G,s); &#125; //多点可达判断 public DirectedGFS(Digraph G,Iterable&lt;Integer&gt; sources)&#123; marked=new boolean[G.V()]; for(int s:sources)&#123; if(!marked[s])&#123; dfs(G,s); &#125; &#125; &#125; //深度优先搜索 private void dfs(Digraph G,int v)&#123; marked[v]=true; for(int w:G.adj[v])&#123; if(!marked[w])&#123; dfs(G,w); &#125; &#125; &#125; //判断一个点是否可达 public boolean marked(int v)&#123; return marked[v]; &#125;&#125; 图中的环和有向无环图有些问题是不允许图中有有向环的可以用DFS检测一个图是否是有向无环图代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class DirectedCycle &#123; private boolean[] marked; //标记顶点 private int[] edgeTo; //标记指向的顶点 private Stack&lt;Integer&gt; cycle; //存储有向环中的顶点 private boolean[] onStack; //标记递归调用的栈上的所有顶点 public DirectedCycle(Digraph G)&#123; marked=new boolean[G.V()]; edgeTo=new int[G.V()]; onStack=new boolean[G.V()]; for(int v=0;v&lt;G.V();v++)&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; private void dfs(Digraph G,int v)&#123; marked[v]=true; onStack[v]=true; for(int w:G.adj(v))&#123; if(this.hasCycle())&#123; return; &#125;else if(!marked[w])&#123; edgeTo[w]=v; dfs(G,w); &#125;else if(onStack[w])&#123; cycle=new Stack&lt;Integer&gt;(); for(int x=v;v!=w;v++)&#123; cycle.push(x); &#125; cycle.push(w); cycle.push(v); &#125; &#125; onStack[v]=false; &#125; public boolean hasCycle() &#123; // TODO Auto-generated method stub return cycle!=null; &#125; public Iterable&lt;Integer&gt; cycle()&#123; return cycle; &#125;&#125; 拓扑排序对于有向图深度优先搜索只会访问图中每个顶点一次将DFS访问的顶点存储在一个数据结构，遍历这个数据结构就能按一定顺序得到图中所有的顶点根据数据结构的不同和保存节点的时间不同分成三种顺序： 前序：队列-&gt;在递归调用前将点入队 后序：队列-&gt;在递归调用之后将顶点入队 逆后序:栈-&gt;在递归之后将顶点入栈 代码如下：1234567891011121314151617181920212223242526272829303132333435363738 public class DepthFirstOrder &#123; private boolean[] marked; private Queue&lt;Integer&gt; pre; //所有顶点的前序排列 private Queue&lt;Integer&gt; post; //所有顶点的后序排列 private Stack&lt;Integer&gt; reverpost; //所有顶点的逆后排序 public DepthFirstOrder(Digraph G)&#123; pre=new Queue&lt;Integer&gt;(); post=new Queue&lt;Integer&gt;(); reverpost=new Stack&lt;Integer&gt;(); marked=new boolean[G.V()]; for(int v=0;v&lt;G.V();v++)&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; private void dfs(Digraph G,int v)&#123; pre.enqueue(v); //递归之前入队 marked[v]=true; for(int w:G.adj(v))&#123; if(!marked[w])&#123; dfs(G,w); &#125; &#125; post.enqueue(v); //低估后入队 reverpost.push(v); &#125; public Iterable&lt;Integer&gt; pre()&#123; return pre; &#125; public Iterable&lt;Integer&gt; post()&#123; return post; &#125; public Iterable&lt;Integer&gt; reverpost()&#123; return reverpost; &#125;&#125; 拓扑排序：是对有向无环图的排序，给定一幅图，将所有顶点排序，使所有的有向边从排在前面的元素指向排在后面的元素，如果有一条路径从v-&gt;w，那么排序后v就要在w的前面拓扑排序主要用来对有依赖关系的事物排序一个有向无环图的拓扑排序顺序即所有顶点逆后序排列给定的一个图先判断是否无环，然后利用DepthFirstOrder返回逆后序顶点就是拓扑排序的结果1234567891011121314 public class Topological &#123; private Iterable&lt;Integer&gt; order; public Topological(Digraph G)&#123; DirectedCycle dc=new DirectedCycle(G); //判断是否是有向无环图 if(!dc.hasCycle())&#123; DepthFirstOrder dfs=new DepthFirstOrder(G); order=dfs.reverpost(); &#125; &#125; public Iterable&lt;Integer&gt; order()&#123; return order; &#125;&#125; 有向图的强连通性强连通：有向图中如果两个顶点互相可达则这两个点是强连通的强连通分量：有向图中的一个强连通分量是图中的一个最大的顶点集合C，对于C中的每一对顶点u和v，u和v是强连通的 识别计算有向图中的强连通分量：Kosaraju算法 对于一个有向图G，使用DepthFirstOrder来计算它的反向图GR的逆后序排序列 按照的到的GR的逆后序列的顺序在G中进行深度优先搜索 下列代码可以判断两个顶点是否强连通，查找并计算所有的强连通分量1234567891011121314151617181920212223242526272829303132333435363738public class KosarajuSCC &#123; private boolean[] marked; //用来标记顶点是否被访问过 private int[] id;//记录强连通分量的标识 private int count;//记录强连通分量的数量 public KosarajuSCC(Digraph G)&#123; marked=new boolean[G.V()]; id=new int[G.V()]; DepthFirstOrder order=new DepthFirstOrder(G.reverse());//计算GR的逆后序列 for(int s:order.reverpost())&#123; if(!marked[s])&#123; dfs(G,s); count++; &#125; &#125; &#125; private void dfs(Digraph G, int v) &#123; marked[v]=true; id[v]=count; for(int w:G.adj(v))&#123; if(!marked[w])&#123; dfs(G,w); &#125; &#125; &#125; //判断两顶点是否强连通 public boolean stronglyConnected(int v,int w)&#123; return id[v]==id[w]; &#125; //返回顶点所在的强连通分量 public int id(int v)&#123; return id[v]; &#125; //返回强连通分量的数量 public int count()&#123; return count; &#125;&#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-查找（散列表）]]></title>
    <url>%2F2018%2F09%2F29%2FJava%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE%EF%BC%88%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[散列查找在查找算法中如果利用数组将要存储的键作为数组索引下标，将对应的值作为数组的内容，在预先知道所要查找的内容在数组的下标可以实现快速查找，实现时间复杂度为O(1)的算法。由于键值可能是各种类型的，可能是整数、可能是字符串类型不能直接作为数组的索引，所以第一步就是要通过散列函数将键转化为数组的索引值。由于散列函数在转化过程中不同的键可能变成相同的索引值，出现碰撞冲突，所以第二步就要处理碰撞冲突。 散列函数如果保存键值的数组大小为M，那么键值通过散列函数就要转化在[0,M-1]的索引范围内，我们需要的散列函数能够将键值均匀的分布在[0,M-1]内，每个键都有相同的可能与0~M-1红的每个整数对应。 我们所使用的散列函数能够均匀并独立的将所有的键分布于0到M-1之间 由于键值的数据类型不同，所需要的散列函数也不同，每种类型都有与之对应的散列函数 整数类型对于整数类型常用的方法是除留余数法:k%M最好使用不是2的幂的质数 浮点数将键表示为二进制然后使用除留余数法 字符串下面为String类型中计算hash值得算法 1234567891011public int hashCode() &#123; int h = hash; //hash是初始值，一般为0 if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; 组合键下面为自定义类的hashcode算法，它将类中的所有成员变量综合起来计算hash值 默认的hashcode函数返回对象的地址 123456789101112131415public class Person &#123; private String name; private int age; private String sex; private String city; public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((city == null) ? 0 : city.hashCode()); result = prime * result + ((name == null) ? 0 : name.hashCode()); result = prime * result + ((sex == null) ? 0 : sex.hashCode()); return result; &#125;&#125; 将hashcode()的返回值转化为数组索引 1234 public int hash(Key k)&#123; return (k.hashCode() &amp; 0x7fffffff) % M;&#125; &amp;的作用是将计算出的hashCode值得符号位屏蔽 基于拉链法的散列表拉链法：保存数组的大小为M，将数组的每一个元素指向一个链表，每个链表中都存储键值相同的元素。 12345678910111213141516171819202122232425262728293031323334 public class SeparateChainingHashST&lt;Key,Value&gt; &#123; private int N;//键值对总数 private int M;//散列表大小 private SequentialSearchST&lt;Key,Value&gt;[] st;//存储链表的数组 public SeparateChainingHashST(int M) &#123; this.M = M; st=(SequentialSearchST&lt;Key,Value&gt;[]) new SequentialSearchST[M]; for(int i=0;i&lt;M;i++)&#123; st[i]=new SequentialSearchST(); &#125; &#125; private int hash(Key key)&#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; public Value get(Key key)&#123; return st[hash(key)].get(key); &#125; public void put(Key key,Value val)&#123; st[hash(key)].put(key, val); &#125; public void delete(Key key)&#123; st[hash(key)].delete(key); &#125; public Iterable&lt;Key&gt; keys()&#123; Queue&lt;Key&gt; queue=new Queue&lt;Key&gt;(); for(int i=0;i&lt;M;i++)&#123; for(Key key:st[i].keys())&#123; queue.enqueue(key); &#125; &#125; return queue; &#125;&#125; 拉链法的散列表性能分析： 一张含有M个链表和N个键的散列表中，未命中的查找和插入所需要的比较次数大约为N/M 需要选择合适的M：如果M过大会空链表多浪费空间资源，但查找速度快；M过小链表平均长度变长，查找效率低；应该选择足够大的M能够将性能提高M倍。也可以选择动态调整数组大小 基于线性探测法的散列表（开放地址散列表）线性探测法：通过哈希函数将键值k转化成数组索引值n，检查数组索引为n的位置会出现三种情况 该位置键值为空，将键值对插入该位置 该位置的键和被查找的键相同，如果查找操作返回查找内容，如果插入操作将键所对应的值换成新值 该位置的键和被查找的键不同，则增大索引继续检查下一个键值，知道找到该键或者遇到一个空元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class LinearProbingHashST&lt;Key,Value&gt; &#123; private int N; private int M; private Key[] keys; private Value[] vals; public LinearProbingHashST(int M)&#123; this.M=M; keys=(Key[]) new Object[M]; vals=(Value[]) new Object[M]; &#125; private int hash(Key key)&#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; public boolean contains(Key key)&#123; return get(key)!=null; &#125; private void resize(int cap)&#123; LinearProbingHashST&lt;Key,Value&gt; t=new LinearProbingHashST&lt;Key,Value&gt;(cap); for(int i=0;i&lt;M;i++)&#123; if(keys[i]!=null)&#123; t.put(keys[i], vals[i]); &#125; &#125; keys=t.keys; vals=t.vals; M=t.M; &#125; public void put(Key key,Value val)&#123; //N/M&gt;=1/2调整到1/4，使N/M保持在(1/8~1/2) if(N&gt;=M/2)&#123; resize(2*M); &#125; for(int i=hash(key);keys[i]!=null;i=(i+1)%M)&#123; if(key.equals(keys[i]))&#123; vals[i]=val; return; &#125; keys[i]=key; vals[i]=val; N++; &#125; &#125; public Value get(Key key)&#123; for(int i=hash(key);keys[i]!=null;i=(i+1)%M)&#123; if(keys[i].equals(key))&#123; return vals[i]; &#125; &#125; return null; &#125; public void delete(Key key)&#123; if(!contains(key))&#123; return; &#125; int i=hash(key); while(!keys[i].equals(key))&#123; i=(i+1)%M; &#125; keys[i]=null; vals[i]=null; i=(i+1)%M; while(keys[i]!=null)&#123; Key k=keys[i]; Value v=vals[i]; keys[i]=null; vals[i]=null; N--; put(k,v); i=(i+1)%M; &#125; N--; if(N&gt;0 &amp;&amp; N&lt;=M/8)&#123; resize(M/2); &#125; &#125; public Iterable&lt;Key&gt; keys()&#123; Queue&lt;Key&gt; queue=new Queue&lt;Key&gt;(); for(int i=0;i&lt;M;i++)&#123; if(keys[i]!=null)&#123; queue.enqueue(keys[i]); &#125; &#125; return queue; &#125; &#125; 线性探测法的性能分析：开放地址类的散列表的性能依赖于散列表的使用率p=N/M，我们一般会动态调整数组的大小是p保持在1/8~1/2之间。 在一张大小为M并包含有N=pM个键的基于线性探测的散列表中，命中和非命中查找所需要的探测次数为：~1/2(1+1/(1-p))和~1/2(1+1/(1-p)*(1-p)) 当p趋近1时，查找次数趋近于无穷；当p=1/2时，查找次数在[1.5,2.5]的范围呃内；所以动态调整数组大小减小p避免连列表过满，散列表快满时所需要的查找次数非常大。 散列表能够使查找和插入操作在时间复杂度上为常数级，理论上是最优的性能. 但它也有几个问题: 散列函数 :每种数据类型都需要优秀的散列函数，散列函数的计算可能复杂昂贵，一个好的散列函数直接影响着散列表的性能。 散列表不支持有序性操作：散列表中的键是无序的，如果你想快速找到最大最小值或者某个范围的键，散列表不合适因为这些操作都是线性级别的。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-Comparable和Comparator的区别]]></title>
    <url>%2F2018%2F09%2F24%2FJava-Comparable%E5%92%8CComparator%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[ComparableComparable接口是排序接口，实现了这个借口的数据类型或者类可以通过Collection.sort()和Arrays.sort()自动排序，此接口中有一个方法compareTo(). public int compareTo(T p); Comparable是内部比较器，需要在一个类的内部实现,在类中需要重写compareTo方法，在此方法中需要实现所要比较的方式，比如如下代码，比较两个对象的方式是先比较姓名，如果一样在比较年龄。 定义一个实现了Comparable接口的Person类12345678910111213141516171819202122232425262728public class Person implements Comparable&lt;Person&gt; &#123; private String name; private int age; public Person(String name,int age)&#123; this.name=name; this.age=age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int compareTo(Person p)&#123; int rest=this.name.compareTo(p.name); if(rest!=0)&#123; return rest; &#125;else&#123; return this.age-p.age; &#125; &#125;&#125; 测试Person类的排序123456789101112131415161718public class test &#123; public static void main(String[] args)&#123; Person p1=new Person("keluosi",27); Person p2=new Person("nuoyier",30); Person p3=new Person("luoyisi",26); System.out.println(p1.compareTo(p2)); Person[] people=new Person[]&#123;p1,p2,p3&#125;; System.out.println("before sort:"); for(Person p:people)&#123; System.out.println(p.getName()+"---"+p.getAge()); &#125; Arrays.sort(people); System.out.println("after sort:"); for(Person p:people)&#123; System.out.println(p.getName()+"---"+p.getAge()); &#125; &#125;&#125; ComparatorComparator是比较接口，如果一个类没有实现Comparable接口需要对该类排序，则可以设计一个实现Comparator接口的比较器，通过这个类的比较器就可以对该类排序。Comparator是外部比较器，和Comparale不同不需要在类中实现，在对一个类实现比较排序时可以不用修改该类的源代码，只需创建该类的比较器利用这个比较器就可以对该类进行排序。使用Comparator有两种方式：一种是创建实现Compartor接口的比较器，使用时直接创建该比较器的对象；另一种是直接在使用到比较器的地方创建一个匿名内部类。如下代码：实现了Person类的比较器：123456public class PersonComparator implements Comparator&lt;Person&gt; &#123; public int compare(Person p1,Person p2)&#123; int rest=p1.getName().compareTo(p2.getName()); return rest!=0 ? rest:p1.getAge()-p2.getAge(); &#125;&#125;使用测试：1234567891011121314151617181920212223242526public class test &#123; public static void main(String[] args)&#123; Person p1=new Person("keluosi",27); Person p2=new Person("nuoyier",30); Person p3=new Person("luoyisi",26); System.out.println(p1.compareTo(p2)); Person[] people=new Person[]&#123;p1,p2,p3&#125;; System.out.println("before sort:"); for(Person p:people)&#123; System.out.println(p.getName()+"---"+p.getAge()); &#125; //使用比较器，创建比较器的对象 PersonComparator pc=new PersonComparator(); Arrays.sort(people,pc); //创建匿名内部类，直接在使用Comparator的地方创建一个Comparator对象并重写compare方法 Arrays.sort(people,new Comparator&lt;Person&gt;()&#123; public int compare(Person p1,Person p2)&#123; return p1.getAge()-p2.getAge(); &#125; &#125;); System.out.println("after sort:"); for(Person p:people)&#123; System.out.println(p.getName()+"---"+p.getAge()); &#125; &#125;&#125; 对比：Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。 Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。 两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-查找（平衡查找树）]]></title>
    <url>%2F2018%2F09%2F22%2FJava%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE%EF%BC%88%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[2-3查找树https://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html 红黑树https://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-查找（二叉搜索树）]]></title>
    <url>%2F2018%2F09%2F22%2FJava%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE%EF%BC%88%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[二叉查找树是一棵二叉树，每个节点的键都大于左子树的任意节点的键，小于右子树的任意节点的键 二叉树的遍历方式分为先序，中序，后序，如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Traversal&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123; private Node root; public class Node&#123; private Key key; private Value val; private Node left; private Node right; private int N; public Node(Key key,Value val,int N)&#123; this.key=key; this.val=val; this.N=N; &#125; &#125; //先序遍历(根节点-&gt;左子树-&gt;右子树) public void PreOrderTraversal()&#123; PreOrderTraversal(root); &#125; //递归实现 private void PreOrderTraversal(Node x) &#123; if(x!=null)&#123; System.out.println(x.key+"---&gt;"+x.val); PreOrderTraversal(x.left); PreOrderTraversal(x.right); &#125; &#125;/* //非递归实现 private void PreOrderTraversal(Node x)&#123; &#125;*/ //中序遍历(左子树-&gt;根节点-&gt;右子树) //递归实现 private void InOrderTraversal(Node x) &#123; if(x!=null)&#123; PreOrderTraversal(x.left); System.out.println(x.key+"---&gt;"+x.val); PreOrderTraversal(x.right); &#125; &#125; //后序遍历(左子树-&gt;右子树-&gt;根节点 ) //递归实现 private void PostOrderTraversal(Node x) &#123; if(x!=null)&#123; PreOrderTraversal(x.left); PreOrderTraversal(x.right); System.out.println(x.key+"---&gt;"+x.val); &#125; &#125; &#125; 基本操作算法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198public class BST&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123; private Node root; public class Node&#123; private Key key; private Value val; private Node left; private Node right; private int N; public Node(Key key,Value val,int N)&#123; this.key=key; this.val=val; this.N=N; &#125; &#125; public int size(Node x)&#123; if(x==null)&#123; return 0; &#125;else&#123; return x.N; &#125; &#125; public void put(Key key,Value val)&#123; root=put(root,key,val); &#125; private Node put(Node x,Key key,Value val)&#123; if(x==null)&#123; return new Node(key,val,1); &#125; int cmp=key.compareTo(x.key); if(cmp&gt;0)&#123; x.right=put(x.right,key,val); &#125;else if(cmp&lt;0)&#123; x.left=put(x.left,key,val); &#125;else&#123; x.val=val; &#125; x.N=size(x.left)+size(x.right)+1; return x; &#125; public Value get(Key key)&#123; return get(root,key); &#125; private Value get(Node x,Key key)&#123; if(x==null)&#123; return null; &#125; int cmp=key.compareTo(x.key); if(cmp&gt;0)&#123; return get(x.right,key); &#125;else if(cmp&lt;0)&#123; return get(x.left,key); &#125;else&#123; return x.val; &#125; &#125; public Key min()&#123; return min(root).key; &#125; private Node min(Node x)&#123; if(x.left==null)&#123; return x; &#125; return min(x.left); &#125;/* //非递归实现 private Key min(Node x)&#123; if(x!=null)&#123; while(x.left!=null)&#123; x=x.left; &#125; &#125; return x; &#125;*/ //max()同理 public Key floor(Key key)&#123; Node x=floor(root,key); if(x==null)&#123; return null; &#125; return x.key; &#125; private Node floor(Node x,Key key)&#123; if(x==null)&#123; return null; &#125; int cmp=key.compareTo(x.key); if(cmp==0)&#123; return x; &#125;else if(cmp&lt;0)&#123; return floor(x.left,key); &#125;else&#123; //注意在右侧查找时可能找不到，这是应返回根节点，而不是在右侧直接返回 Node t=floor(x.right,key); if(t==null)&#123; return x; &#125;else&#123; return t; &#125; &#125; &#125; //ceiling同理 public Key select(int k)&#123; return select(root,k).key; &#125; private Node select(Node x,int k)&#123; if(x==null)&#123; return null; &#125; int t=size(x.left); if(t==k)&#123; return x; &#125;else if(t&gt;k)&#123; return select(x.left,k); &#125;else&#123; //注意右子树查找的数量 k-t-1 return select(x.right,k-t-1); &#125; &#125; public int rank(Key key)&#123; return rank(root,key); &#125; private int rank(Node x,Key key)&#123; if(x==null)&#123; return 0; &#125; int cmp=key.compareTo(x.key); if(cmp==0)&#123; return size(x.left); &#125;else if(cmp&lt;0)&#123; return rank(x.left,key); &#125;else&#123; //注意在右侧查找后返回的元素包括根节点和左子树元素 return rank(x.right,key)+size(x.left)+1; &#125; &#125; public void deleteMin()&#123; root=deleteMin(root); &#125; private Node deleteMin(Node x)&#123; if(x.left==null)&#123; return x.right; &#125; x.left=deleteMin(x.left); x.N=size(x.left)+size(x.right)+1; return x; &#125; //deleteMax()同理 //删除操作，删除一个元素时用这个节点右子树的最小值或者左子树的最大值代替 public void delete(Key key)&#123; root=delete(root,key); &#125; private Node delete(Node x,Key key)&#123; if(x==null)&#123; return null; &#125; int cmp=key.compareTo(x.key); if(cmp&lt;0)&#123; delete(x.left,key); &#125;else if(cmp&gt;0)&#123; delete(x.right,key); &#125;else&#123; if(x.left==null)&#123; return x.right; &#125; if(x.right==null)&#123; return x.left; &#125; Node t=x; x=min(t.right); x.right=deleteMin(t.right); x.left=t.left; &#125; x.N=size(x.left)+size(x.right)+1; return x; &#125; //范围查找 public Iterable&lt;Key&gt; keys(Key lo,Key hi)&#123; Queue&lt;Key&gt; queue=new Queue&lt;Key&gt;(); keys(root,queue,lo,hi); return queue; &#125; private void keys(Node x,Queue&lt;Key&gt; queue,Key lo,Key hi)&#123; if(x==null)&#123; return; &#125; int cmplo=lo.compareTo(x.key); int cmphi=hi.compareTo(x.key); if(cmplo&lt;=0 &amp;&amp; cmphi&gt;=0)&#123; queue.enqueue(x.key); &#125; if(cmphi&gt;0)&#123; keys(x.right,queue,lo,hi); &#125; if(cmplo&lt;0)&#123; keys(x.left,queue,lo,hi); &#125; &#125;&#125; 二叉查找树实现的符号表的时间复杂度是lgN,最坏情况下为N]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms, Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-查找(符号表)]]></title>
    <url>%2F2018%2F09%2F08%2FJava%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE-%E7%AC%A6%E5%8F%B7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[符号表定义定义：符号表是一种存储键值对的数据结构，支持两种操作：插入(put)，将一组新的键值对存入表中;查找(get),根据给定的键值的到对应的值。 一种有序的泛型符号表的API实现的对字符表的操作 字符表的实现无序链表实现无序字符表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 public class SequentialSearchST&lt;Key, Value&gt; &#123; private int n; // number of key-value pairs private Node first; // the linked list of key-value pairs // a helper linked list data type private class Node &#123; private Key key; private Value val; private Node next; public Node(Key key, Value val, Node next) &#123; this.key = key; this.val = val; this.next = next; &#125; &#125; public SequentialSearchST() &#123;&#125; public int size() &#123; return n; &#125; public boolean isEmpty() &#123; return size() == 0; &#125; public boolean contains(Key key) &#123; if (key == null) throw new IllegalArgumentException("argument to contains() is null"); return get(key) != null; &#125; public Value get(Key key) &#123; if (key == null) throw new IllegalArgumentException("argument to get() is null"); for (Node x = first; x != null; x = x.next) &#123; if (key.equals(x.key)) return x.val; &#125; return null; &#125; public void put(Key key, Value val) &#123; if (key == null) throw new IllegalArgumentException("first argument to put() is null"); if (val == null) &#123; delete(key); return; &#125; for (Node x = first; x != null; x = x.next) &#123; if (key.equals(x.key)) &#123; x.val = val; return; &#125; &#125; first = new Node(key, val, first); n++; &#125; /** * Removes the specified key and its associated value from this symbol table * (if the key is in this symbol table). * * @param key the key * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125; */ public void delete(Key key) &#123; if (key == null) throw new IllegalArgumentException("argument to delete() is null"); first = delete(first, key); &#125; // delete key in linked list beginning at Node x // warning: function call stack too large if table is large private Node delete(Node x, Key key) &#123; if (x == null) return null; if (key.equals(x.key)) &#123; n--; return x.next; &#125; x.next = delete(x.next, key); return x; &#125; /** * Returns all keys in the symbol table as an &#123;@code Iterable&#125;. * To iterate over all of the keys in the symbol table named &#123;@code st&#125;, * use the foreach notation: &#123;@code for (Key key : st.keys())&#125;. * * @return all keys in the symbol table */ public Iterable&lt;Key&gt; keys() &#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); for (Node x = first; x != null; x = x.next) queue.enqueue(x.key); return queue; &#125; 基于链表的实现及顺序查找是非常低效的向一个空表中插入N个不同的键需要~N*N/2次比较 基于有序数组的二分查找实现有序字符表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public class BinarySearchST&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123; private Key[] keys; private Value[] vals; private int N=0; //构造方法，初始化 public BinarySearchST(int capacity)&#123; keys=(Key[]) new Comparable[capacity]; vals=(Value[]) new Object[capacity]; &#125; public int size()&#123; return N; &#125; public boolean isEmpty()&#123; return N==0; &#125; public boolean contains(Key key)&#123; if(key==null)&#123; throw new IllegalArgumentException("argument to contains() is null"); &#125; return get(key)!=null; &#125; //二分查找 //迭代法 private int rank(Key key)&#123; int lo=0; int hi=N-1; while(lo&lt;=hi)&#123; int mid=lo+(hi-lo)/2; int cmp=keys[mid].compareTo(key); if(cmp&gt;0)&#123; hi=mid-1; &#125;else if(cmp&lt;0)&#123; lo=mid+1; &#125;else&#123; return mid; &#125; &#125; return lo; &#125; /* 递归法实现二分查找 public int rank(Key key,int lo,int hi)&#123; if(hi&lt;lo)&#123; return lo; &#125; int mid=lo+(hi-lo)/2; int cmd=keys[mid].compareTo(key); if(cmd&gt;0)&#123; return rank(key,lo,mid-1); &#125;else(cmd&lt;0)&#123; return rank(key,mid+1,hi); &#125;else&#123; return mid; &#125; &#125;*/ public Value get(Key key)&#123; if(key==null)&#123; throw new IllegalArgumentException("argument to get() is null"); &#125; if(isEmpty())&#123; return null; &#125; int i=rank(key); if(i&lt;N &amp;&amp; keys[i].compareTo(key)==0)&#123; return vals[i]; &#125;else&#123; return null; &#125; &#125; public void put(Key key,Value val)&#123; if(key==null)&#123; throw new IllegalArgumentException("argument to put() is null"); &#125; if(val==null)&#123; delete(key); return; &#125; int i=rank(key); if(i&lt;N &amp;&amp; keys[i].compareTo(key)==0)&#123; vals[i]=val; return; &#125; for(int j=N;j&gt;i;j--)&#123; keys[j]=keys[j-1]; vals[j]=vals[j-1]; &#125; keys[i]=key; vals[i]=val; N++; &#125; public void delete(Key key)&#123; if(key==null)&#123; throw new IllegalArgumentException("argument to delete() is null"); &#125; if(isEmpty())&#123; return; &#125; int i=rank(key); if(i==N || keys[i].compareTo(key)!=0)&#123; return; &#125; for(int j=i;j&lt;N-1;j++)&#123; keys[j]=keys[j+1]; vals[j]=vals[j+1]; &#125; N--; keys[N]=null; vals[N]=null; &#125; public Key min()&#123; return keys[0]; &#125; public Key max()&#123; return keys[N-1]; &#125; public Key select(int k)&#123; return keys[k]; &#125; public Key ceiling(Key key)&#123; int i=rank(key); return keys[i]; &#125; public Key floor(Key key)&#123; if (key == null) throw new IllegalArgumentException("argument to floor() is null"); int i = rank(key); if (i &lt; N &amp;&amp; key.compareTo(keys[i]) == 0) &#123; return keys[i]; &#125;else&#123; return keys[i-1]; &#125; &#125; public Iterable&lt;Key&gt; keys(Key lo,Key hi)&#123; Queue&lt;Key&gt; queue=new Queue&lt;Key&gt;(); for(int i=rank(lo);i&lt;rank(hi);i++)&#123; queue.enqueue(keys[i]); &#125; if(contains(keys[rank(hi)]))&#123; queue.enqueue(keys[rank(hi)]); &#125; return queue; &#125;&#125; 算法分析： 有序数组二分查找的各个操作的成本: BinarySearchST的算法实现了最优的查找效率~lgN，但是插入操作很慢~N，无法保证高效的查找和插入操作。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-排序（堆排序）]]></title>
    <url>%2F2018%2F09%2F04%2FJava%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%EF%BC%88%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[堆的定义堆这种数据结构是一种完全二叉树，堆分为最大堆和最小堆 最大堆：二叉树中的任一顶点大于等于它的左右子节点 最小堆：二叉树中的任一顶点小于等于它的左右子节点堆可以用数组来存储表示 优先队列优先队列（Priority Queue）：特殊的队列，取出元素的顺序按照元素的优先权或关键字的大小，不是元素入队的先后顺序。优先队列（堆）的使用场景： 1. 任何时候返回最值元素； 2. 数据太大存不下，要找出一定的最值元素； 3. 合并若干不同来源的已经排序的源（索引优先队列） 优先队列的实现方式： 基于堆的优先队列用堆实现优先队列的方法：注：以下代码存储数据时从数组的下标1开始代码实现：最大堆实现的最大优先队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 public class MaxPQ&lt;T extends Comparable&lt;T&gt;&gt;&#123; private T[] pq; //存队列数据的数组 private int N=0; //最终元素的个数 //构造函数 public MaxPQ(int maxN)&#123; pq=(T[])new Comparable[maxN+1]; &#125; //判断队列是否为空 public boolean isEmpty()&#123; return N==0; &#125; //返回队列元素个数 public int size()&#123; return N; &#125; //插入数据 public void insert(T v)&#123; pq[++N]=v; swim(N); &#125; //删除队列中最大元素并返回最大值 public T delMax()&#123; T max=pq[1]; exch(1,N--); pq[N+1]=null; sink(1); return max; &#125; //上浮 private void swim(int k)&#123; while(k&gt;1 &amp;&amp; less(k/2,k))&#123; exch(k/2,k); k=k/2; &#125; &#125; //下沉 private void sink(int k)&#123; while(2*k&lt;=N)&#123; int t=2*k; if(t&lt;N &amp;&amp; less(t,t+1))&#123; t++; &#125; if(less(k,t))&#123; exch(k,t); &#125;else&#123; break; &#125; k=t; &#125; &#125; private boolean less(int i,int j)&#123; return pq[i].compareTo(pq[j])&lt;0; &#125; private void exch(int i,int j)&#123; T temp=pq[i]; pq[i]=pq[j]; pq[j]=temp; &#125; public static void main(String[] args)&#123; MaxPQ&lt;Integer&gt; p=new MaxPQ&lt;Integer&gt;(10); int n=5; p.insert(88); p.insert(2); p.insert(56); p.insert(3); p.insert(42); while(n&gt;0)&#123; System.out.println(p.delMax()); n--; &#125; &#125;&#125; 代码实现的最主要的功能是实现元素的优先级，快速找到并删除最大元素，插入元素（自动调整）算法分析： 一颗大小为N的完全二叉树的高度为lgN； 含有N个元素的基于堆的优先队列，插入元素需要不超过lgN+1次比较，删除最大元素需要不超过2lgN次比较；最小堆实现的最小优先队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MinPQ&lt;T extends Comparable&lt;T&gt;&gt; &#123; private T[] pq; private int N; public MinPQ(int maxN)&#123; pq=(T[])new Comparable[maxN+1]; &#125; public boolean isEmpty()&#123; return N==0; &#125; public int size()&#123; return N; &#125; public void insert(T v)&#123; pq[++N]=v; swim(N); &#125; private void swim(int k)&#123; while(k&gt;1 &amp;&amp; less(k,k/2))&#123; exch(k,k/2); k=k/2; &#125; &#125; public T deleteMin()&#123; T min=pq[1]; exch(1,N--); sink(1); return min; &#125; private void sink(int k)&#123; while(2*k&lt;N)&#123; int t=2*k; if(t&lt;k &amp;&amp; less(t+1,t))&#123; t++; &#125; if(less(t,k))&#123; exch(t,k); &#125;else&#123; break; &#125; k=t; &#125; &#125; private boolean less(int v,int w)&#123; return pq[v].compareTo(pq[w])&lt;0; &#125; private void exch(int v,int w)&#123; T temp=pq[v]; pq[v]=pq[w]; pq[w]=temp; &#125;&#125; 索引优先队列优先队列的一个缺点是无法直接访问队列中的元素(除了直接找到最大或最小的元素)，对其更新修改。用过建立索引优先队列来实现快速索引。创建两个数组：elements[]用来存储队列中的对象(不需要按连续存储)，pq[]用来存储队列中每个对象在elements[]中的索引。 通过这两个数组建立的映射关系，在构建优先队列的时候，不需要变动elements[]，只需要维护改变pq中的元素即可。当向队列中插入一个新的对象时，在elements中存储该对象，将其索引存储在pq中，并对这个索引值进行上浮操作维护优先队列在操作队列时，如果想更改队列中某个对象，比如像将索引为3的位置改为”b”，那么直接操作elements[3]=”b”，这时需要重新调整维护优先队列，在pq数组中队值为3的元素操作，但是并不知道pq中那个位置的值是3，只能通过顺序遍历查找。为了方便查找pq中的元素，创建一个qp数组，将pq中元素作为索引在qp中存储该元素在pq中的索引。在队列的操作中经常要交换两个元素，交换pq中的两个元素的同事也要交换qp中相应位置的元素。索引最小优先队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class IndexMinPQ&lt;Key extends Comparable&lt;Key&gt;&gt; &#123; private int pq[]; private int qp[]; private Key keys[]; private int maxN; private int N; public IndexMinPQ(int maxN)&#123; this.maxN=maxN; N=0; pq=new int[maxN+1];//这些数组中0索引处不存储值 qp=new int[maxN+1]; keys=(Key[])new Comparable[maxN]; for(int i=0;i&lt;=maxN;i++)&#123; qp[i]=-1; &#125; &#125; public boolean isEmpty()&#123; return N==0; &#125; public int size()&#123; return N; &#125; public boolean contains(int i)&#123; //这里的i检查的是keys在索引i处是否有值 if(i&lt;0 || i&gt;maxN)&#123; throw new IllegalArgumentException(); &#125; return qp[i]!=-1; &#125; public void insert(int k,Key key)&#123; if ( k&lt; 0 || k&gt; maxN) throw new IllegalArgumentException(); if (contains(k)) throw new IllegalArgumentException("index is already in the priority queue"); keys[k]=key; pq[++N]=k; qp[k]=N; swim(N); &#125; //返回队列中的最小值 public Key minKey()&#123; return keys[pq[1]]; &#125; //删除并返回队列中的最小值 public Key deleteMin()&#123; if (N == 0) throw new NoSuchElementException("Priority queue underflow"); Key min=keys[pq[1]]; pq[1]=pq[N--]; sink(1); return min; &#125; //删除并返回队列中的某个值 public void delete(int k)&#123; if (k &lt; 0 || k &gt; maxN) throw new IllegalArgumentException(); if (!contains(k)) throw new NoSuchElementException("index is not in the priority queue"); int index=qp[k]; pq[index]=pq[N--]; swim(index); sink(index); keys[k]=null; qp[k]=-1; &#125; //改变队列中某个对象的值 public void changeKey(int k,Key key)&#123; if (k &lt; 0 || k &gt; maxN) throw new IllegalArgumentException(); if (!contains(k)) throw new NoSuchElementException("index is not in the priority queue"); keys[k]=key; swim(qp[k]); sink(qp[k]); &#125; //上浮调整 private void swim(int k)&#123; while(k&gt;1)&#123; if(less(k,k/2))&#123; exch(k,k/2); &#125; k=k/2; &#125; &#125; //下沉调整 private void sink(int k)&#123; while(2*k&lt;=N)&#123; int t=2*k; if(t&lt;N &amp;&amp; less(t+1,t))&#123; t=t+1; &#125; if(less(k,t))&#123; exch(k,t); &#125;else&#123; break; &#125; k=t; &#125; &#125; private boolean less(int k,int v)&#123; return keys[pq[k]].compareTo(keys[pq[v]])&lt;0; &#125; private void exch(int k,int v)&#123; int temp=pq[k]; pq[k]=pq[v]; pq[v]=temp; qp[pq[k]]=k; qp[pq[v]]=v; &#125;&#125; 堆排序堆排序分为两个阶段，给定一个无序的数组，首先要做的事构造堆。a.将无需序列构建成一个堆，根据升序降序需求选择最大堆或最小堆;b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端，N–将最大的元素固定,再次调整不在去管它;c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。对于给定的无序构造堆的一个高效方法就是从右向左进行sink下沉操作，不需要管叶子结点（叶子结点已经算作一个有堆，无法进行下沉操作），所以只需要扫描一半的数组元素。示意图：堆排序算法实现：123456789101112131415161718192021222324252627282930313233343536373839 public class HeapSort&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; @Override public void sort(T[] a)&#123; //数组a[0]不存储哨兵，a[0]的值一般用作，从a[1]开始 int N=a.length-1; //构建堆 for(int k=N/2;k&gt;=1;k--)&#123; sink(a,k,N); &#125; //堆排序 while(N&gt;1)&#123; exch(a,1,N--); sink(a,1,N); &#125; &#125; private void sink(T[] a,int k,int N)&#123; while(2*k&lt;=N)&#123; int j=2*k; if(j&lt;N &amp;&amp; less(a[j],a[j+1]))&#123; j++; &#125; if(less(a[k],a[j]))&#123; exch(a,k,j); &#125;else&#123; break; &#125; k=j; &#125; &#125; public static void main(String[] args)&#123; HeapSort&lt;String&gt; b=new HeapSort&lt;String&gt;(); String[] str=&#123;"q","sss","aaa","ccc","qqq","bbb"&#125;; b.sort(str); for(int i=1;i&lt;=str.length-1;i++)&#123; System.out.println(str[i]); &#125; &#125;&#125; 算法分析： 用下沉法构建堆（N个元素）只需少于2N次比较和少于N次的交换； 对N个元素的堆排序，需要少于（2NlgN+2N)次比较，一半次数的交换； 多种算法比较快速排序是最快的通用排序方法因为快速排序内循环指令少，他还能利用缓存（因为总是顺序访问数组），时间复杂度都是~cNlgN,使用三向切分后可能将某些时间复杂度变为线性级的。 Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql]]></title>
    <url>%2F2018%2F09%2F04%2FMysql%2F</url>
    <content type="text"><![CDATA[Mysql基本操作登陆数据库： mysql -u root -p 退出数据库： exit; 数据库操作创建数据库 create database 数据库名; create database 数据库名 character set 字符集（utf8) collate 校对规则; 删除数据库 drop database 数据库名; 查看数据库 show databases -查看所有数据库 show create database 数据库名 -查看创建的数据库的信息 修改数据库 alter database 数据库名 选中使用数据库 use 数据库名 表的操作创建表 create table 表名{ 列名1 数据类型（长度）约束； 列名2 数据类型（长度） 约束； ...... } 数据类型：https://www.cnblogs.com/Caveolae/p/7058890.htmlhttps://www.cnblogs.com/-xlp/p/8617760.html 约束：主键：primary key （唯一，一个表只有一个主键） 第一种–单一主键：id int primary key（列级）第二种–复合主键：primary key（id，name）设置多个主键（表级）在主键中设置自增：id int primary key auto_increment 外键：foreign key （一个表可以有多个外键） foreign key(外键） references 另一个表名（要关联的键）给外键起名：constraint dpt_fk foreign key(外键名） conferences 表名（关联的键） 默认值：default 非空：not null age int not null; 唯一约束：unique 第一种：email varchar(32) unique （列级）第二种：unique（id，email） —组合约束 （表级）第三种：constraint 约束名 unique（email） —约束起名字（表级） 操作表表重命名： rename table old to new； 删除表： drop table 表名； 增加列： alter table 表名 add 列名 数据类型 约束 after 列名; 可以指定新增列的位置 删除列： alter table 表名 drop 列名; 修改列： alter table 表名 modify 列名 数据类型 约束 改变表中数据 插入数据 insert into 表名(列1，列2，...) values(值1，值2...) or insert into 表名(列1，2...) values(值1，值2...),(v1,v2..),(v1,v2...)... 修改数据： update 表名 set 列1=值1，列2=值2 where 条件 删除数据： delete from 表名 where 条件 查询select语句 select * from 表名; select 列1，列2，... from 表名; select c1,c2,... from 表名 as 另一名; select c1 as p1,c2 as p2,... from 表名; select distinct c from 表名; ---去掉重复值 运算查询： select *,列的运算 as 名 from 表名; 条件查询： where 条件 select 查询内容 from 表名 where 条件 关系运算符 逻辑运算符 模糊查询 like where c like &apos;条件&apos; -：代表单个字符 %：代表多个字符 范围查询 in where c in (a1,a2,a3...) 排序查询： order by c asc/desc asc:ascend 升序 desc:descend 降序 聚合函数： select sum(number) from 表名; sum() avg() count() max() min() 分组： group by having:在group后，可以接聚合函数 where:在group之前，不可以接聚合函数 select ... from ... where ... group by ... having ... order by ...]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-排序（简单排序）]]></title>
    <url>%2F2018%2F08%2F20%2FJava%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[算法模板Comparable接口 Interface Comparable&lt;T&gt; 该接口对实现它的每个类的对象强加一个整体排序，这个排序被称为类的自然排序，类的compareTo方法被称为其自然比较方法 **int compareTo(T o)** 将此对象与指定的对象进行比较以进行排序 返回一个负整数，零或正整数，因为该对象小于，等于或大于指定对象 compareTo() 必须实现一个完整的比较序列，即： 自反性，对于所有的 v ， v=v ； 反对称性，对于所有的 v&lt;w 都有 v&gt;w ，且 v=w 时 w=v ； 传递性，对于所有的 v 、 w 和 x ，如果 v&lt;=w 且 w&lt;=x ，则 v&lt;=x 。 算法模板： 1234567891011121314151617181920212223242526272829public abstract class Sort&lt;T extends Comparable&lt;T&gt;&gt;&#123; public static void sort(T[] a)&#123; &#125; //比较数据大小 protected static boolean less (Tv,T w)&#123; return v.compareTo(w)&lt;0; &#125; //交换数据 protected static void exch(T[] a,int i,int j)&#123; T temp=a[i]; a[i]=a[j]; a[j]=temp; &#125; //输出显示排序好的数据 protected static void show(T[] a)&#123; for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]+" "); &#125; System.out.println(); &#125; //判断是否排序 public static boolean isSorted(T[] a)&#123; for(int i=1;i&lt;a.length;i++)&#123; if(less(a[i],a[i-1])) return false; &#125; return true; &#125;&#125; 注意：只要是实现了Comparable（自己定义的数据类型要重写compareTo方法）的数据类型都可以用次模板排序 选择排序12345678910111213public class Selection&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; @Override public static void sort(T[] a)&#123; int N=a.length; for(int i=0;i&lt;N;i++)&#123; int min=i; for(int j=i+1;j&lt;N;j++)&#123; if(less(a[j],a[min])) min=j; &#125; exch(a,i,min); &#125; &#125;&#125; 选择排序： 首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。 算法分析： 选择排序的效率取决于交换的次数：对于长度为 N 的数组，选择排序需要大约 N 2 /2 次比较和 N 次交换时间复杂度 T(N)=O(N*N); 运行时间和输入无关:已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间一样长 数据移动是最少的:选择排序用了 N 次交换,交换次数和数组的大小是线性关系 冒泡排序冒泡排序：从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。在一轮循环中，如果没有发生交换，就说明数组已经是有序的，此时可以直接退出。 12345678910111213141516public class Bubble&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; @Override public static void sort(T[] a)&#123; int N=a.length; boolean flag=false; for(int i=N-1;i&gt;0 &amp;&amp; !flag;i--)&#123; flag=true; for(int j=0;j&lt;i;j++)&#123; if(less(a[j+1],a[j]))&#123; exch(a,j,j+1); flag=false; &#125; &#125; &#125; &#125;&#125;``` 插入排序12345678910public class Insertion&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; public static &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] a)&#123; int N=a.length; for(int i=1;i&lt;N;i++)&#123; for(int j=i;j&gt;0 &amp;&amp; less(a[j],a[j-1]);j--)&#123; exch(a,j,j-1); &#125; &#125; &#125;&#125; 算法分析： 对于随机排列的长度为 N 且主键不重复的数组，平均情况下插入排序需要～ N 2 /4 次比较以及～ N 2 /4 次交换。最坏情况下需要～ N 2 /2 次比较和～ N 2 /2 次交换，最好情况下需要 N-1次比较和 0 次交换时间复杂度 T(N)=O(N*N) 插入排序所需的时间取决于输入中元素的初始顺序 插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一 插入排序对于实际应用中常见的某些类型的非随机数组很有效插入排序对于部分有序的数组十分高效，也很适合小规模数组 比较：对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数 希尔排序希尔排序：对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。 1234567891011121314151617public class Shell&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; public static &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] a)&#123; int N=a.length; int h=1; while(h&lt;N/3)&#123; h=h*3+1; &#125; while(h&gt;=1)&#123; for(int i=h;i&lt;N;i++)&#123; for(int j=i;j&gt;0 &amp;&amp; less(a[j],a[j-h]);j-=h)&#123; exch(a,j,j-h); &#125; &#125; h=h/3; &#125; &#125;&#125; 算法的性能不仅取决于 h，还取决于 h 之间的数学性质 目前最重要的结论是希尔排序的运行时间达不到平方级别 希尔排序比插入排序和选择排序要快得多，并且数组越大，优势越大 MergeSort(归并排序)In-place merge(原地归并)1234567891011121314151617181920public class Merge&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; protected T[] aux; protected void merge(T[] a,int lo,int mid,int hi)&#123; int i=lo; //左边数组的起始位置 int j=mid+1; ////右边数组的起始位置 for(int k=lo;k&lt;=hi;k++)&#123; aux[k] =a[k]; &#125; for(int k=lo;k&lt;=hi;k++)&#123; if(i&gt;mid)&#123; a[k]=aux[j++]; //左边的子数组用尽 &#125;else if(j&gt;hi)&#123; a[k]=aux[i++]; //右边的子数组用尽 &#125;else if(less(aux[j],aux[i]))&#123; a[k]=aux[j++]; &#125;else&#123; a[k]=aux[i++]; &#125; &#125; &#125; This method merges by first copying into the auxiliary array aux[] then merging back to a[]. In the merge (the second for loop), there are four conditions: left half exhausted (take from the right), right half exhausted (take from the left), current key on right less than current key on left (take from the right), current key on right greater than or equal to current key on left (take from the left). Top-down mergesort(自顶向下的归并排序)123456789101112131415public class UptoDpwnMergeSort&lt;T extends Comparable&lt;T&gt;&gt; extends Merge&#123; public void sort(T[] a)&#123; aux=(T[]) new Comparable[a.length]; sort(a,0,a.length-1); &#125; private void sort(T[] a,int lo,int hi)&#123; if(hi&lt;=lo)&#123; return; &#125; int mid=lo+(hi-lo)/2; sort(a,0,mid); sort(a,mid+1,hi); merge(a,lo,mid,hi); &#125;&#125; A: The code is a recursive(递归) mergesort implementation based on this abstract inplace merge. B: It is one of the best-known examples of the utility of the divide-and-conquer(分而治之) paradigm for efficient algorithm design C: the sort code simply provides an organized way to sequence the calls to the merge() method 算法分析： A: Top-down mergesort uses between ½ N lg N and N lg N compares to sort any array of length N时间复杂度：T(N)=O(N lg N) B: Top-down mergesort uses at most 6N lg N array accesses to sort an array of length N Bottom-up mergesort(自底向上的排序)1234567891011public class BottomtoUpMergeSort&lt;T extends Comparable&lt;T&gt;&gt; extends Merge&lt;T&gt; &#123; public void sort(T[] a)&#123; int N=a.length; aux = (T[]) new Comparable[a.length]; for(int sz=1;sz&lt;N;sz=sz+sz)&#123; for(int lo=0;lo&lt;N-sz;lo+=sz+sz)&#123; merge(a,lo,lo+sz-1,Math.min(lo+sz+sz-1, N-1)); &#125; &#125; &#125;&#125; 算法分析：Bottom-up mergesort uses between ½ N lg N and N lg N compares and at most 6N lg N array accesses to sort an array of length N. both the number of compares usedby mergesort in the worst case and the minimum number of compares that any compare-basedsorting algorithm can guarantee are ~N lg N 归并排序在最坏的情况下的比较次数和任意基于比较的排序算法所需的最少比较次数都是~ NlgN]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-排序（快速排序）]]></title>
    <url>%2F2018%2F08%2F18%2FJava%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%EF%BC%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[QuickSort（快速排序）The basic algorithm（基本算法）归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Quick&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; public void sort(T[] a)&#123; shuffe(a); //消除对输入的依赖 sort(a,0,a.length-1); &#125; private void sort(T[] a, int lo, int hi) &#123; if(hi&lt;=lo)&#123; return; &#125; int j=partition(a,lo,hi); //切分 sort(a,lo,j-1); //将左半边排序 sort(a,j+1,hi); //将右半边排序 &#125; //切分方法 private int partition(T[] a, int lo, int hi) &#123; int i=lo; int j=hi+1; T v=a[lo]; //选取lo处的元素作为分界元素 while(true)&#123; //从左向右扫描找到比v大的元素 while(less(a[++i],v))&#123; if(i==hi)&#123; break; &#125; &#125; //从右向左扫描找到比v小的元素 while(less(v,a[--j]))&#123; if(j==lo)&#123; break; &#125; &#125; if(i&gt;=j)&#123; break; &#125; exch(a,i,j);y &#125; exch(a,lo,j); return j; &#125; //打乱数组 private void shuffe(T[] a)&#123; List&lt;T&gt; list=Arrays.asList(a); Collections.shuffle(list); list.toArray(a); &#125;&#125; Performance characteristics（性能分析）A: advantagea: it is in-place (uses only a small auxiliary stack) (原地排序)b: it requires time proportional to N log N on the average to sort an array of length N (时间复杂度T(N)=O(NlgN))c: the inner loop of quicksort (in the partitioning method) increments an index and compares an array entry against a fixed value.(内循环短小) B: The best case for quicksort is when each partitioning stage divides the array exactlyin half. This circumstance would make the number of compares used by quicksort satisfy the divide-and-conquer recurrence CN = 2CN/2 + N，this recurrence has the solution CN ~ N lg N C: Quicksort uses ~ 2N ln N compares (and one-sixth that many exchanges)on the average to sort an array of length N with distinct keys. D: Quicksort uses ~ N * N/2 compares in the worst case, but random shuffling protects against this case.(最坏情况) Algorithmic improvements(算法改进)Cutoff to insertion sort (切换到插入排序)对小数组排序时插入排序的效率比快速排序的效率高，以为快速排序递归在小数组中调用自己耗费时间改进方法：将 if(hi&lt;=lo) return; 改为 if(hi&lt;=lo+M){ Insertion(a,lo,hi); return; } The optimum value of the cutoff M is system-dependent, but any value between 5 and 15 is likely to work well in most situations 这种方法主要用于提高对小型数组排序的速度问题 Median-of-three partitioning（三取样切分）Entropy-optimal sorting（三向切分的快速排序）这种算法是为了提高有大量重复元素的数组的排序效率，通过选定特定的切分元素v将数组切分为三个部分，小于v的元素、大于v的元素和小于v的元素123456789101112131415161718192021222324252627282930313233public class Quick3way&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; @Override public void sort(T[] a)&#123; shuffe(a); sort(a,0,a.length-1); &#125; private void sort(T[]a,int lo,int hi)&#123; if(hi&lt;=lo)&#123; return; &#125; int lt=lo; int i=lo+1; int gt=hi; T v=a[lo]; while(i&lt;=gt)&#123; int tep=a[i].compareTo(v); if(tep&lt;0)&#123; exch(a,i++,lt++); &#125;else if(tep&gt;0)&#123; exch(a,i,gt--); &#125;else&#123; i++; &#125; &#125; sort(a,lo,lt-1); sort(a,gt+1,hi); &#125; private void shuffe(T[] a)&#123; List&lt;T&gt; list=Arrays.asList(a); Collections.shuffle(list); list.toArray(a); &#125;&#125; 算法分析： 对于包含大量重复元素的数组，三向切分的快速算法比标准的快速算法效率高的多，排序时间从线性对数级降低到了线性级别。对于一个数组，它的所有主键的香农信息量 H=-(p1lgp1+p2lgp2 +…+pnlgpn) 大小为N的数组，三向切分需要~（2ln2)NH次比较 三向切分最坏的情况是当所有的主键不重复时，H=lgN，时间复杂度为NlgN，是线性对数级别的；一般情况下，三向切分的运行时间和输入的信息量的N倍成正比，是线性级别的。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-基本数据结构]]></title>
    <url>%2F2018%2F08%2F18%2FJava%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基本数据结构数组链表链表的节点表示1234public class Node&lt;Item&gt;&#123; Item item; Node next; &#125; 栈用链表实现栈 public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt;{ //栈顶指针 private Node first; //栈中元素数量 private int N; //定义节点 private class Node{ Item item; Node next; } //判断栈是否为空 public boolean isEmpty(){ return first==null; } //返回栈中元素数量 public int size(){ return N; } //压栈 public void push(Item item){ Node oldfirst=first; first=new Node(); first.item=item; first.next=oldfirst; N++; } //出栈 public Item pop(){ if(isEmpty()){ try { throw new Exception("stack is empty"); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } } Item item=first.item; first=first.next; N--; return item; } public Iterator&lt;Item&gt; iterator(){ return new Iterator&lt;Item&gt;(){ private Node current=first; @Override public boolean hasNext(){ return current!=null; } @Override public Item next(){ Item item=current.item; current=current.next; return item; } public void remove(){} }; } } 队列用链表实现队列 public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt; { private Node first; private Node last; private int N; private class Node{ Item item; Node next; } //判断队列是否为空 public boolean isEmpty(){ return N==0; } //返回队列中元素个数 public int size(){ return N; } //入队 public void enqueue(Item item){ Node oldlast=last; last=new Node(); last.item=item; last.next=null; if(isEmpty()){ first=last; }else{ oldlast.next=last; } N++; } //出队 public Item dequeue(){ if(isEmpty()){ try { throw new Exception("queue is empty"); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } } Item item=first.item; first=first.next; N--; if(isEmpty()){ last=null; } return item; } public Iterator&lt;Item&gt; iterator(){ return new Iterator&lt;Item&gt;(){ private Node current=first; @Override public boolean hasNext(){ return current!=null; } @Override public Item next(){ Item item=current.item; current=current.next; return item; } public void remove(){} }; } }]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-集合（容器）]]></title>
    <url>%2F2018%2F08%2F17%2FJava-%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。 Collection接口的子接口包括：Set接口和List接口 Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等 List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等 Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等 Collection网上博客教程：https://blog.csdn.net/feiyanaffection/article/details/81394745 public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; Collection接口的常用方法 添加功能 boolean add(E e) boolean addAll(Collection&lt;? extends E&gt; c) 添加一个集合的元素 删除功能 void clear() 从此集合中删除所有元素 boolean remove(Object o) boolean removeAll(Collection&lt;?&gt; c) 删除指定集合中包含的所有此集合的元素 判断功能 boolean contains(Object o) 如果此集合包含指定的元素，则返回true boolean containsAll(Collection&lt;?&gt; c) 如果此集合包含指定 集合中的所有元素，则返回true boolean isEmpty() 如果此集合不包含元素，则返回 true 长度功能 int size() 返回此集合中的元素数 交集功能 boolean retainAll(Collection&lt;?&gt; c) 两个集合都有的元素 a.retainAll(b) a和b做交集，结果保存在a中，b不变，返回的boolean值表示a是否发生变化 一、List public interface List&lt;E&gt; extends Collection&lt;E&gt; List-有序集合（存储和取出的元素一致）（也称为序列 ），可以精确控制列表中每个元素的插入位置，通过整数索引（列表中的位置）访问元素，并搜索列表中的元素，列表通常允许重复的元素 1. List的特有方法 void add(int index,E element) 将指定的元素插入此列表中的指定位置 E get(int index) 返回此列表中指定位置的元素 ListIterator&lt;E&gt; listIterator() 返回列表中的列表迭代器（按适当的顺序） E remove(int index) 删除该列表中指定位置的元素 E set(int index, E element) 用指定的元素替换此列表中指定位置的元素 2. List的类型分类各类型特点对比： ArrarList：底层数据结构是数组，支持随机访问，查询快，增删慢 线程不安全，效率高 Vector： 底层数据结构是数组，查询快，增删慢 线程安全，效率低 LinkedList：低层数据结构是双向链表，查询慢（只能顺序访问），但是可以快速地在链表中间插入和删除元素增删快。LinkedList还可以用作栈、队列、双向队列 线程不安全，效率高 3. LinkedListLinkedList的基本方法： public void addFirst(E e) 在列表的头部插入元素 public void addLast(E e) 在列表尾部插入元素 public E getFirst() 返回此列表中的第一个元素。 public E getLast() 返回此列表中的最后一个元素 public E removeFirst() 从此列表中删除并返回第一个元素 public E removeLast() 从此列表中删除并返回最后一个元素 4. ArrayList与LinkedList的区别和适用场景 Arraylist： 优点：ArrayList是实现了基于动态数组的数据结构,因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。 缺点：因为地址连续， ArrayList要移动数据,所以插入和删除操作效率比较低。 LinkedList： 优点：LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinedList比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景 缺点：因为LinkedList要移动指针,所以查询操作性能比较低。 适用场景分析： 当需要对数据进行对此访问的情况下选用ArrayList， 当需要对数据进行多次增加删除修改时采用LinkedList。 5. ArrayList与Vector的区别和适用场景 ArrayList有三个构造方法： public ArrayList(int initialCapacity)//构造一个具有指定初始容量的空列表。 public ArrayList() //默认构造一个初始容量为10的空列表。 public ArrayList(Collection&lt;? extends E&gt; c)//构造一个包含指定 collection 的元素的列表 Vector有四个构造方法： public Vector()//使用指定的初始容量和等于0的容量增量构造一个空向量。 public Vector(int initialCapacity)//构造一个空向量，使其内部数据数组的大小，其标准容量增量为零。 public Vector(Collection&lt;? extends E&gt; c)//构造一个包含指定 collection 中的元素的向量 public Vector(int initialCapacity,int capacityIncrement)//使用指定的初始容量和容量增量构造一个空的向量 ArrayList和Vector都是用数组实现的，主要有这么三个区别： 1）.Vector是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果。而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比； 2）两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。 3）Vector可以设置增长因子，而ArrayList不可以。 4）Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。 使用场景： Vector是线程同步的，所以它也是线程安全的，而ArrayList是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用ArrayList效率比较高。 如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用Vector有一定的优势。 二、迭代器 迭代器是一种对象，它的功能是遍历并选择序列中的对象。 Iterator迭代器Collection 实现了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。 Collection获取迭代器的方法： Iterator&lt;E&gt; iterator() 返回此集合中的元素的迭代器 Iterator接口的常用方法： boolean hasNext() 判断集合里是否有元素 E next() 获取元素并移动到下一个元素 集合的使用步骤： A:创建集合对象 Collection c = new ArrayList(); B:创建元素对象 Object obj=..... C：元素添加到集合 c.add(obj) D：遍历集合元素 a:用过集合获取迭代器对象 Iterator it = c.iterator() b:通过迭代器对象的hasNext()方法判断是否有元素 boolean flag = it.hasNext() c:通过迭代器next()方法获取元素 Object obje = it.next() 集合的遍历（以List类型为例，Set同理）第一种：迭代器遍历 //部分伪代码，E代表某种类型 List&lt;E&gt; list=new List&lt;E&gt;(); list.add(E a); list.add(E b); //假设list里已经添加多个E类型的对象，可以遍历 Iterator it=list.iterator(); while(it.hasNext()){ E e=it.next(); print(e); } 第二种：foreach方法（增强for循环） List&lt;E&gt; list=new List&lt;E&gt;(); list.add(E a); list.add(E b); ....... for(E e:list){ print(e); } ------------------- List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); for (String item : list) { System.out.println(item); } ListIteratorListIterator是Iterator的子类，只用于List类集合，Iterator只能单向移动，而ListIterator可以双向移动主要方法： 继承了Iterator的功能（hasNext(),next()) boolean hasPrevious() 返回true如果遍历反向列表，列表迭代器有多个元素 E previous() 返回列表中的上一个元素，并向后移动光标位置 int nextIndex() 返回由后续调用返回的元素的索引next() int previousIndex() 返回由后续调用previous()返回的元素的索引 三、Set1. Set类型与List集合不同的是，Set集合不保存重复的元素 TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素&gt;的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1),TreeSet 则为 O(logN) HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的 LinkedHashSet：具有 HashSet的查找效率，且内部使用双向链表维护元素的插入顺序 HashSet提供最快的查询速度，TreeSet保持元素处于排序状态，LinkedHashSet以插入顺序保存元素 1）HashSetHashSet保证集合元素唯一性的原理： HashSet线程不安全，效率高，可以存储null元素，元素的唯一性是靠所存储元素类型是否重写hashCode()和equals()方法来保证的，如果没有重写这两个方法，则无法保证元素的唯一性。 具体实现唯一性的比较过程： 存储元素首先会使用hash()算法函数生成一个int类型hashCode散列值，然后已经的所存储的元素的hashCode值比较： 如果hashCode不相等，则所存储的两个对象一定不相等，此时存储当前的新的hashCode值处的元素对象； 如果hashCode相等，存储元素的对象还是不一定相等，此时会调用equals()方法判断两个对象的内容是否相等，如果内容相等，那么就是同一个对象，无需存储；如果比较的内容不相等，那么就是不同的对象，就该存储了，此时就要采用哈希的解决地址冲突算法，在当前hashCode值处类似一个新的链表， 在同一个hashCode值的后面存储存储不同的对象，这样就保证了元素的唯一性。 Set的实现类的集合对象中不能够有重复元素，HashSet也一样他是使用了一种标识来确定元素的不重复，HashSet用一种算法来保证HashSet中的元素是不重复的， HashSet采用哈希算法，底层用数组存储数据。默认初始化容量16，加载因子0.75。 Object类中的hashCode()的方法是所有子类都会继承这个方法，这个方法会用Hash算法算出一个Hash（哈希）码值返回，HashSet会用Hash码值去和数组长度取模， 模（这个模就是对象要存放在数组中的位置）相同时才会判断数组中的元素和要加入的对象的内容是否相同，如果不同才会添加进去。 2）TreeSet TreeSet底层数据结构采用二叉树来实现，元素唯一且已经排好序；唯一性同样需要重写hashCode和equals()方法，二叉树结构保证了元素的有序性。 根据构造方法不同，分为自然排序（无参构造）和比较器排序（有参构造）： 自然排序要求元素必须实现Compareable接口，并重写里面的compareTo()方法，元素通过比较返回的int值来判断排序序列，返回0说明两个对象相同，不需要存储； 比较器排需要在TreeSet初始化是时候传入一个实现Comparator接口的比较器对象，或者采用匿名内部类的方式new一个Comparator对象，重写里面的compare()方法； 基于TreeMap实现，使用元素的自然顺序对元素进行排序，或者使用set提供的comparator方法排序，具体使用时取决于使用的构造方法 A:自然排序：真正依赖于compareTo()方法， 这个方法定义在Comparable中，所以想重写该方法，就要实现Comparable接口，这个接口表示自然排序 例如：定义学生类时实现Comparable接口 public class Student implements Comparable&lt;T&gt;{ @override public int compareTo(T t){ .......... 主要条件 次要条件 } } B:比较器排序:comparator方法, TreeSet的add()方法，是基于TreeMap方法的put()方法 public TreeSet(Comparator&lt;? super E&gt; comparator ) 构造一个新的，空的树集，根据指定的比较器进行排序 TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;(){ public int compare(Student s1,Student s2){ ........... } };) 2. 适用场景分析 TreeSet 是二插树（红黑树的树据结构）实现的,Treeset中的数据是自动排好序的，不允许放入null值 HashSet 是哈希表实现的,HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束 HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hashcode码作为标识的，而具有相同内容的String对象，hashcode是一样，所以放入的内容不能重复。但是同一个类的对象可以放入不同的实例 适用场景分析:HashSet是基于Hash算法实现的，其性能通常都优于TreeSet。为快速查找而设计的Set，我们通常都应该使用HashSet，在我们需要排序的功能时，我们才使用TreeSet。 四、Mappublic interface Map&lt;K,V&gt; Map将键映射到值的对象。 地图不能包含重复的键; 每个键可以映射到最多一个值 1. Map的基本类型 TreeMap：基于红黑树实现，保证唯一性和排序 HashMap：基于哈希表实现 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。 ConcurrentHashMap：现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序 HashMap用来快速访问，TreeMap保持键排序，LinkedHashMap保持元素插入的顺序，也通过散列提供快速访问能力 2. Map基本方法功能 添加 V put(K key,V value) 将指定的值与该映射中的指定键相关联 如果键是第一次存储，直接存储元素，返回null； 如果不是第一次添加键值，就用新的值替换旧的值，并返回旧的值。 删除 void clear() 从该地图中删除所有的映射 V remove(Object key) 删除并返回 删除集合里存在的键，返回建的值，如果不存在返回null 判断 boolean containsKey(Object key) 如果此映射包含指定键的映射，则返回true boolean containsValue(Object value) 如果此映射将一个或多个键映射到指定的值，则返回true boolean isEmpty() 判断集合是否为空 获取 V get(Object key) 返回到指定键所映射的值 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此地图中包含的映射的Set视图 Set&lt;K&gt; keySet() 返回此地图中包含的键的Set视图 Collection&lt;V&gt; values() 返回此地图中包含的值的Collection视图 长度 int size() 返回此地图中键值映射的数量 Map集合的遍历 //创建集合 Map&lt;String,String&gt; map=new Map&lt;String,String&gt;(); //添加数据 map.put(&quot;德国&quot;,&quot;克罗斯&quot;); map.put(&quot;法国&quot;,&quot;格列兹曼&quot;); map.put(&quot;比利时&quot;,&quot;德布劳内&quot;); 方式一： //获取键值集合 Set&lt;String&gt; set=map.keySet(); for(String s:set){ v=map.get(s); System.out.println(s+&quot;---&gt;&quot;+v); } 方式二： //获取映射Set集合 Set&lt;Map.Entry&lt;String,String&gt; set=map.entrySet(); for(Map.Entry&lt;String,String&gt; m:set){ key=m.getKey(); value=m.getValue(); System.out.println(key+&quot;---&gt;&quot;+value); }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-网络编程]]></title>
    <url>%2F2018%2F08%2F11%2FJava-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[网络编程的三要素IP地址 概念：IP地址是网络中计算机的唯一标识 IP的组成：网络号+主机号 java提供了InetAddress类来对IP地址解析和操作 确定主机名称的IP地址public static InetAddress getByName(String host)获取此IP地址的主机名 public String getHostName() 端口 端口是正在运行程序的标识 协议 UDP 将数据源和目的地封装在数据包中，无连接，是不可靠协议，不需要建立连接，速度快 TCP 建立连接，形成传输数据的通道，在连接中进行大数据量的传输，通过三次握手完成连接，是可靠地，效率会低 Socket网络编程Socket包含了IP地址和端口号Socket原理机制：通信的两端都有Socket，网络通信其实是Socket间的通信，数据在两个Socket间通过IO传输 UDP UDP使用DatagramSocket类用于发送和接收数据报数据包 构造方法：public DatagramSocket()—发送数据使用的构造方法public DatagramSocket(int port)—接收数据使用的构造方法主要成员方法：public void close()关闭此数据报套接字public void send(DatagramPacket p)从此套接字发送数据报包public void receive(DatagramPacket p)从此套接字接收数据报包 发送和接收的数据是DatagramPacket类的，该类表示数据报包，send方法中需要传递DatagramPacket对象 构造方法：public DatagramPacket(byte[] buf,int length,InetAddress address,int port)–发送数据使用的构造方法public DatagramPacket(byte[] buf,int length) –接收数据使用的构造方法buf - 分组数据length - 包长度address - 目的地址port - 目的端口号主要成员方法：public byte[] getData()返回数据缓冲区public int getLength()返回要发送的数据的长度或接收到的数据的长度public InetAddress getAddress()返回该数据报发送或接收数据报的计算机的IP地址 UDP协议发送数据 1.创建发送端Socket对象 2.创建数据并打包 3.调用Socket对象的发送方法发送数据 4.释放资源 下面为实现UDP协议发送数据 public class send{ public static void main(String[] args){ //创建发送端Socket DatagramSocket ds=new DatagramSocket(); //创建数据并打包 byte[] bys=&quot;UDP协议发送的数据&quot;.getBytes(); int length=bys.length; //发送数据的目的IP地址 InetAddress address=InetAddress.getByName(&quot;主机名&quot;)； //发送端计算机的端口 int port=10086; DatagramPacket dp=new DatagramPacket(bys,length,address,port); //发送数据 ds.send(dp); //释放资源 ds.close(); } } UDP协议接收数据1.创建接收端Socket2.创建数据包接收数据（接受容器）3.用Socket接受方法接收数据4.解析数据输出5.释放资源 下面为实现UDP协议接收数据 public class Receive { public static void main(String[] args) throws IOException { // TODO Auto-generated method stub //创建接收端Socket DatagramSocket ds=new DatagramSocket(10086); //创建数据包接收 byte[] bys=new byte[1024]; int length=bys.length; DatagramPacket dp=new DatagramPacket(bys,length); //接收数据 ds.receive(dp); //解析数据 InetAddress address=dp.getAddress(); String ip=address.getHostAddress(); byte[] bys2=dp.getData(); int len=dp.getLength(); String s=new String(bys2,0,len); System.out.println(ip+&quot;:&quot;+s); //释放资源 ds.close(); } } TCPTCP协议发送数据 （客户端）1.创建发送端Socket2.获取输出流写数据3.释放资源 TCP发送客户端使用的是Socket类 构造方法：public Socket(InetAddress address,int port)public Socket(String host,int port)主要成员方法：public void close()关闭public OutputStream getOutputStream()返回此套接字的输出流 public class TSend { public static void main(String[] args) throws IOException { //创建Socket Socket s=new Socket(&quot;daw-PC&quot;,10086); //获取输出流写数据 OutputStream os=s.getOutputStream(); os.write(&quot;TCP发送数据&quot;.getBytes()); //释放资源 s.close(); } } TCP协议接收数据（服务器）1.创建接收端Socket2.监听客户端连接，返回对应的Socket对象3.获取输入流读数据4.释放资源 TCP接收客户端使用的是ServeSocket类 构造方法：public ServerSocket(int port)成员方法：public Socket accept()监听 ，返回的是Scoket类，所以需要Socket类的方法Socket类的—public InputStream getInputStream()返回此套接字的输入流 public class TReceive { public static void main(String[] args) throws IOException { //创建接收端Socket ServerSocket ss=new ServerSocket(10086); //监听客户端 Socket s=ss.accept(); //获取输入流写数据 InputStream is=s.getInputStream(); byte[] bys=new byte[1024]; int len=is.read(bys); String str=new String(bys,0,len); System.out.println(str); //释放资源，注意不关闭服务器 s.close(); } }]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chenwang Zheng]]></title>
    <url>%2F2018%2F01%2F21%2FChenwang%20Zheng%2F</url>
    <content type="text"><![CDATA[Welcome to Chenwang Zheng’s Homepage! Personal Information I am currently a graduate student with School of Electronic and Information Engineering, Beijing Jiaotong University, China. My research interests include data mining and recommendation system. Research Chenwang Zheng, Dan Tao. A User Dynamic Preference and Attention Mechanism based POI Recommendation Method [P]. Patent No.201911420233.6]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
</search>
