<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法-排序（简单排序）]]></title>
    <url>%2F2018%2F08%2F20%2F%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[算法模板Comparable接口 Interface Comparable&lt;T&gt; 该接口对实现它的每个类的对象强加一个整体排序，这个排序被称为类的自然排序，类的compareTo方法被称为其自然比较方法 **int compareTo(T o)** 将此对象与指定的对象进行比较以进行排序 返回一个负整数，零或正整数，因为该对象小于，等于或大于指定对象 compareTo() 必须实现一个完整的比较序列，即： 自反性，对于所有的 v ， v=v ； 反对称性，对于所有的 v&lt;w 都有 v&gt;w ，且 v=w 时 w=v ； 传递性，对于所有的 v 、 w 和 x ，如果 v&lt;=w 且 w&lt;=x ，则 v&lt;=x 。 算法模板： 1234567891011121314151617181920212223242526272829public abstract class Sort&lt;T extends Comparable&lt;T&gt;&gt;&#123; public static void sort(T[] a)&#123; &#125; //比较数据大小 protected static boolean less (Tv,T w)&#123; return v.compareTo(w)&lt;0; &#125; //交换数据 protected static void exch(T[] a,int i,int j)&#123; T temp=a[i]; a[i]=a[j]; a[j]=temp; &#125; //输出显示排序好的数据 protected static void show(T[] a)&#123; for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]+" "); &#125; System.out.println(); &#125; //判断是否排序 public static boolean isSorted(T[] a)&#123; for(int i=1;i&lt;a.length;i++)&#123; if(less(a[i],a[i-1])) return false; &#125; return true; &#125;&#125; 注意：只要是实现了Comparable（自己定义的数据类型要重写compareTo方法）的数据类型都可以用次模板排序 选择排序12345678910111213public class Selection&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; @Override public static void sort(T[] a)&#123; int N=a.length; for(int i=0;i&lt;N;i++)&#123; int min=i; for(int j=i+1;j&lt;N;j++)&#123; if(less(a[j],a[min])) min=j; &#125; exch(a,i,min); &#125; &#125;&#125; 选择排序： 首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。 算法分析： 选择排序的效率取决于交换的次数：对于长度为 N 的数组，选择排序需要大约 N 2 /2 次比较和 N 次交换时间复杂度 T(N)=O(N*N); 运行时间和输入无关:已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间一样长 数据移动是最少的:选择排序用了 N 次交换,交换次数和数组的大小是线性关系 冒泡排序冒泡排序：从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。在一轮循环中，如果没有发生交换，就说明数组已经是有序的，此时可以直接退出。 12345678910111213141516public class Bubble&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; @Override public static void sort(T[] a)&#123; int N=a.length; boolean flag=false; for(int i=N-1;i&gt;0 &amp;&amp; !flag;i--)&#123; flag=true; for(int j=0;j&lt;i;j++)&#123; if(less(a[j+1],a[j]))&#123; exch(a,j,j+1); flag=false; &#125; &#125; &#125; &#125;&#125;``` 插入排序12345678910public class Insertion&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; public static &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] a)&#123; int N=a.length; for(int i=1;i&lt;N;i++)&#123; for(int j=i;j&gt;0 &amp;&amp; less(a[j],a[j-1]);j--)&#123; exch(a,j,j-1); &#125; &#125; &#125;&#125; 算法分析： 对于随机排列的长度为 N 且主键不重复的数组，平均情况下插入排序需要～ N 2 /4 次比较以及～ N 2 /4 次交换。最坏情况下需要～ N 2 /2 次比较和～ N 2 /2 次交换，最好情况下需要 N-1次比较和 0 次交换时间复杂度 T(N)=O(N*N) 插入排序所需的时间取决于输入中元素的初始顺序 插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一 插入排序对于实际应用中常见的某些类型的非随机数组很有效插入排序对于部分有序的数组十分高效，也很适合小规模数组 比较：对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数 希尔排序希尔排序：对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。 1234567891011121314151617public class Shell&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; public static &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] a)&#123; int N=a.length; int h=1; while(h&lt;N/3)&#123; h=h*3+1; &#125; while(h&gt;=1)&#123; for(int i=h;i&lt;N;i++)&#123; for(int j=i;j&gt;0 &amp;&amp; less(a[j],a[j-h]);j-=h)&#123; exch(a,j,j-h); &#125; &#125; h=h/3; &#125; &#125;&#125; 算法的性能不仅取决于 h，还取决于 h 之间的数学性质 目前最重要的结论是希尔排序的运行时间达不到平方级别 希尔排序比插入排序和选择排序要快得多，并且数组越大，优势越大 MergeSort(归并排序)In-place merge(原地归并)1234567891011121314151617181920public class Merge&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; protected T[] aux; protected void merge(T[] a,int lo,int mid,int hi)&#123; int i=lo; //左边数组的起始位置 int j=mid+1; ////右边数组的起始位置 for(int k=lo;k&lt;=hi;k++)&#123; aux[k] =a[k]; &#125; for(int k=lo;k&lt;=hi;k++)&#123; if(i&gt;mid)&#123; a[k]=aux[j++]; //左边的子数组用尽 &#125;else if(j&gt;hi)&#123; a[k]=aux[i++]; //右边的子数组用尽 &#125;else if(less(aux[j],aux[i]))&#123; a[k]=aux[j++]; &#125;else&#123; a[k]=aux[i++]; &#125; &#125; &#125; This method merges by first copying into the auxiliary array aux[] then merging back to a[]. In the merge (the second for loop), there are four conditions: left half exhausted (take from the right), right half exhausted (take from the left), current key on right less than current key on left (take from the right), current key on right greater than or equal to current key on left (take from the left). Top-down mergesort(自顶向下的归并排序)123456789101112131415public class UptoDpwnMergeSort&lt;T extends Comparable&lt;T&gt;&gt; extends Merge&#123; public void sort(T[] a)&#123; aux=(T[]) new Comparable[a.length]; sort(a,0,a.length-1); &#125; private void sort(T[] a,int lo,int hi)&#123; if(hi&lt;=lo)&#123; return; &#125; int mid=lo+(hi-lo)/2; sort(a,0,mid); sort(a,mid+1,hi); merge(a,lo,mid,hi); &#125;&#125; A: The code is a recursive(递归) mergesort implementation based on this abstract inplace merge. B: It is one of the best-known examples of the utility of the divide-and-conquer(分而治之) paradigm for efficient algorithm design C: the sort code simply provides an organized way to sequence the calls to the merge() method 算法分析： A: Top-down mergesort uses between ½ N lg N and N lg N compares to sort any array of length N时间复杂度：T(N)=O(N lg N) B: Top-down mergesort uses at most 6N lg N array accesses to sort an array of length N Bottom-up mergesort(自底向上的排序)1234567891011public class BottomtoUpMergeSort&lt;T extends Comparable&lt;T&gt;&gt; extends Merge&lt;T&gt; &#123; public void sort(T[] a)&#123; int N=a.length; aux = (T[]) new Comparable[a.length]; for(int sz=1;sz&lt;N;sz=sz+sz)&#123; for(int lo=0;lo&lt;N-sz;lo+=sz+sz)&#123; merge(a,lo,lo+sz-1,Math.min(lo+sz+sz-1, N-1)); &#125; &#125; &#125;&#125; 算法分析：Bottom-up mergesort uses between ½ N lg N and N lg N compares and at most 6N lg N array accesses to sort an array of length N. both the number of compares usedby mergesort in the worst case and the minimum number of compares that any compare-basedsorting algorithm can guarantee are ~N lg N 归并排序在最坏的情况下的比较次数和任意基于比较的排序算法所需的最少比较次数都是~ NlgN]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-排序（快速排序）]]></title>
    <url>%2F2018%2F08%2F18%2F%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%EF%BC%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[QuickSort（快速排序）The basic algorithm（基本算法）归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Quick&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; public void sort(T[] a)&#123; shuffe(a); //消除对输入的依赖 sort(a,0,a.length-1); &#125; private void sort(T[] a, int lo, int hi) &#123; if(hi&lt;=lo)&#123; return; &#125; int j=partition(a,lo,hi); //切分 sort(a,lo,j-1); //将左半边排序 sort(a,j+1,hi); //将右半边排序 &#125; //切分方法 private int partition(T[] a, int lo, int hi) &#123; int i=lo; int j=hi+1; T v=a[lo]; //选取lo处的元素作为分界元素 while(true)&#123; //从左向右扫描找到比v大的元素 while(less(a[++i],v))&#123; if(i==hi)&#123; break; &#125; &#125; //从右向左扫描找到比v小的元素 while(less(v,a[--j]))&#123; if(j==lo)&#123; break; &#125; &#125; if(i&gt;=j)&#123; break; &#125; exch(a,i,j);y &#125; exch(a,lo,j); return j; &#125; //打乱数组 private void shuffe(T[] a)&#123; List&lt;T&gt; list=Arrays.asList(a); Collections.shuffle(list); list.toArray(a); &#125;&#125; Performance characteristics（性能分析）A: advantagea: it is in-place (uses only a small auxiliary stack) (原地排序)b: it requires time proportional to N log N on the average to sort an array of length N (时间复杂度T(N)=O(NlgN))c: the inner loop of quicksort (in the partitioning method) increments an index and compares an array entry against a fixed value.(内循环短小) B: The best case for quicksort is when each partitioning stage divides the array exactlyin half. This circumstance would make the number of compares used by quicksort satisfy the divide-and-conquer recurrence CN = 2CN/2 + N，this recurrence has the solution CN ~ N lg N C: Quicksort uses ~ 2N ln N compares (and one-sixth that many exchanges)on the average to sort an array of length N with distinct keys. D: Quicksort uses ~ N * N/2 compares in the worst case, but random shuffling protects against this case.(最坏情况) Algorithmic improvements(算法改进)Cutoff to insertion sort (切换到插入排序)对小数组排序时插入排序的效率比快速排序的效率高，以为快速排序递归在小数组中调用自己耗费时间改进方法：将 if(hi&lt;=lo) return; 改为 if(hi&lt;=lo+M){ Insertion(a,lo,hi); return; } The optimum value of the cutoff M is system-dependent, but any value between 5 and 15 is likely to work well in most situations 这种方法主要用于提高对小型数组排序的速度问题 Median-of-three partitioning（三取样切分）Entropy-optimal sorting（三向切分的快速排序）这种算法是为了提高有大量重复元素的数组的排序效率，通过选定特定的切分元素v将数组切分为三个部分，小于v的元素、大于v的元素和小于v的元素 public class Quick3way&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; { @Override public void sort(T[] a){ shuffe(a); sort(a,0,a.length-1); } private void sort(T[]a,int lo,int hi){ if(hi&lt;=lo){ return; } int lt=lo; int i=lo+1; int gt=hi; T v=a[lo]; while(i&lt;=gt){ int tep=a[i].compareTo(v); if(tep&lt;0){ exch(a,i++,lt++); }else if(tep&gt;0){ exch(a,i,gt--); }else{ i++; } } sort(a,lo,lt-1); sort(a,gt+1,hi); } private void shuffe(T[] a){ List&lt;T&gt; list=Arrays.asList(a); Collections.shuffle(list); list.toArray(a); } } 算法分析： 对于包含大量重复元素的数组，三向切分的快速算法比标准的快速算法效率高的多，排序时间从线性对数级降低到了线性级别。对于一个数组，它的所有主键的香农信息量 H=-(p1lgp1+p2lgp2 +…+pnlgpn) 大小为N的数组，三向切分需要~（2ln2)NH次比较 三向切分最坏的情况是当所有的主键不重复时，H=lgN，时间复杂度为NlgN，是线性对数级别的；一般情况下，三向切分的运行时间和输入的信息量的N倍成正比，是线性级别的。]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-基本数据结构]]></title>
    <url>%2F2018%2F08%2F18%2F%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基本数据结构数组链表链表的节点表示1234public class Node&lt;Item&gt;&#123; Item item; Node next; &#125; 栈用链表实现栈 public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt;{ //栈顶指针 private Node first; //栈中元素数量 private int N; //定义节点 private class Node{ Item item; Node next; } //判断栈是否为空 public boolean isEmpty(){ return first==null; } //返回栈中元素数量 public int size(){ return N; } //压栈 public void push(Item item){ Node oldfirst=first; first=new Node(); first.item=item; first.next=oldfirst; N++; } //出栈 public Item pop(){ if(isEmpty()){ try { throw new Exception("stack is empty"); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } } Item item=first.item; first=first.next; N--; return item; } public Iterator&lt;Item&gt; iterator(){ return new Iterator&lt;Item&gt;(){ private Node current=first; @Override public boolean hasNext(){ return current!=null; } @Override public Item next(){ Item item=current.item; current=current.next; return item; } public void remove(){} }; } } 队列用链表实现队列 public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt; { private Node first; private Node last; private int N; private class Node{ Item item; Node next; } //判断队列是否为空 public boolean isEmpty(){ return N==0; } //返回队列中元素个数 public int size(){ return N; } //入队 public void enqueue(Item item){ Node oldlast=last; last=new Node(); last.item=item; last.next=null; if(isEmpty()){ first=last; }else{ oldlast.next=last; } N++; } //出队 public Item dequeue(){ if(isEmpty()){ try { throw new Exception("queue is empty"); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } } Item item=first.item; first=first.next; N--; if(isEmpty()){ last=null; } return item; } public Iterator&lt;Item&gt; iterator(){ return new Iterator&lt;Item&gt;(){ private Node current=first; @Override public boolean hasNext(){ return current!=null; } @Override public Item next(){ Item item=current.item; current=current.next; return item; } public void remove(){} }; } }]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-集合（容器）]]></title>
    <url>%2F2018%2F08%2F17%2FJava-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Collection public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; Collection接口的常用方法 添加功能 boolean add(E e) boolean addAll(Collection&lt;? extends E&gt; c) 添加一个集合的元素 删除功能 void clear() 从此集合中删除所有元素 boolean remove(Object o) boolean removeAll(Collection&lt;?&gt; c) 删除指定集合中包含的所有此集合的元素 判断功能 boolean contains(Object o) 如果此集合包含指定的元素，则返回true boolean containsAll(Collection&lt;?&gt; c) 如果此集合包含指定 集合中的所有元素，则返回true boolean isEmpty() 如果此集合不包含元素，则返回 true 长度功能 int size() 返回此集合中的元素数 交集功能 boolean retainAll(Collection&lt;?&gt; c) 两个集合都有的元素 a.retainAll(b) a和b做交集，结果保存在a中，b不变，返回的boolean值表示a是否发生变化 一、List public interface List&lt;E&gt; extends Collection&lt;E&gt; List-有序集合（存储和取出的元素一致）（也称为序列 ），可以精确控制列表中每个元素的插入位置，通过整数索引（列表中的位置）访问元素，并搜索列表中的元素，列表通常允许重复的元素 List的特有方法 void add(int index,E element) 将指定的元素插入此列表中的指定位置 E get(int index) 返回此列表中指定位置的元素 ListIterator&lt;E&gt; listIterator() 返回列表中的列表迭代器（按适当的顺序） E remove(int index) 删除该列表中指定位置的元素 E set(int index, E element) 用指定的元素替换此列表中指定位置的元素 List的类型分类各类型特点对比： ArrarList：底层数据结构是数组，查询快，增删慢 线程不安全，效率高 Vector： 底层数据结构是数组，查询快，增删慢 线程安全，效率低 LinkedList：低层数据结构是链表，查询慢（只能顺序访问），增删快 线程不安全，效率高 LinkedList还可以用作栈、队列、双向队列 LinkedListLinkedList的基本方法： public void addFirst(E e) 在列表的头部插入元素 public void addLast(E e) 在列表尾部插入元素 public E getFirst() 返回此列表中的第一个元素。 public E getLast() 返回此列表中的最后一个元素 public E removeFirst() 从此列表中删除并返回第一个元素 public E removeLast() 从此列表中删除并返回最后一个元素 二、迭代器 迭代器是一种对象，它的功能是遍历并选择序列中的对象。 Iterator迭代器Collection 实现了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。 Collection获取迭代器的方法： Iterator&lt;E&gt; iterator() 返回此集合中的元素的迭代器 Iterator接口的常用方法： boolean hasNext() 判断集合里是否有元素 E next() 获取元素并移动到下一个元素 集合的使用步骤： A:创建集合对象 Collection c = new ArrayList(); B:创建元素对象 Object obj=..... C：元素添加到集合 c.add(obj) D：遍历集合元素 a:用过集合获取迭代器对象 Iterator it = c.iterator() b:通过迭代器对象的hasNext()方法判断是否有元素 boolean flag = it.hasNext() c:通过迭代器next()方法获取元素 Object obje = it.next() 集合的遍历（以List类型为例，Set同理）第一种：迭代器遍历 //部分伪代码，E代表某种类型 List&lt;E&gt; list=new List&lt;E&gt;(); list.add(E a); list.add(E b); //假设list里已经添加多个E类型的对象，可以遍历 Iterator it=list.iterator(); while(it.hasNext()){ E e=it.next(); print(e); } 第二种：foreach方法（增强for循环） List&lt;E&gt; list=new List&lt;E&gt;(); list.add(E a); list.add(E b); ....... for(E e:list){ print(e); } ------------------- List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); for (String item : list) { System.out.println(item); } ListIteratorListIterator是Iterator的子类，只用于List类集合，Iterator只能单向移动，而ListIterator可以双向移动主要方法： 继承了Iterator的功能（hasNext(),next()) boolean hasPrevious() 返回true如果遍历反向列表，列表迭代器有多个元素 E previous() 返回列表中的上一个元素，并向后移动光标位置 int nextIndex() 返回由后续调用返回的元素的索引next() int previousIndex() 返回由后续调用previous()返回的元素的索引 三、Set与List集合不同的是，Set集合不保存重复的元素 TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素&gt;的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1),TreeSet 则为 O(logN) HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的 LinkedHashSet：具有 HashSet的查找效率，且内部使用双向链表维护元素的插入顺序 HashSet提供最快的查询速度，TreeSet保持元素处于排序状态，LinkedHashSet以插入顺序保存元素 HashSet保证集合元素唯一性的原理： 主要取决于HashSet的add()方法， add()方法中主要依赖于String.hashCode()和String.equals()方法, 定义类时应该重写这两个方法 TreeSet（排序，唯一不重复）: 基于TreeMap实现，使用元素的自然顺序对元素进行排序，或者使用set提供的comparator方法排序， 具体使用时取决于使用的构造方法 A:自然排序：真正依赖于compareTo()方法， 这个方法定义在Comparable中，所以想重写该方法，就要实现Comparable接口，这个接口表示自然排序 例如：定义学生类时实现Comparable接口 public class Student implements Comparable&lt;T&gt;{ @override public int compareTo(T t){ .......... 主要条件 次要条件 } } B:比较器排序:comparator方法, TreeSet的add()方法，是基于TreeMap方法的put()方法 public TreeSet(Comparator&lt;? super E&gt; comparator ) 构造一个新的，空的树集，根据指定的比较器进行排序 TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;(){ public int compare(Student s1,Student s2){ ........... } };) Mappublic interface Map&lt;K,V&gt; Map将键映射到值的对象。 地图不能包含重复的键; 每个键可以映射到最多一个值 Map的基本类型 TreeMap：基于红黑树实现，保证唯一性和排序 HashMap：基于哈希表实现 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。ConcurrentHashMap：现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序HashMap用来快速访问，TreeMap保持键排序，LinkedHashMap保持元素插入的顺序，也通过散列提供快速访问能力 Map基本方法功能 添加 V put(K key,V value) 将指定的值与该映射中的指定键相关联 如果键是第一次存储，直接存储元素，返回null； 如果不是第一次添加键值，就用新的值替换旧的值，并返回旧的值。 删除 void clear() 从该地图中删除所有的映射 V remove(Object key) 删除并返回 删除集合里存在的键，返回建的值，如果不存在返回null 判断 boolean containsKey(Object key) 如果此映射包含指定键的映射，则返回true boolean containsValue(Object value) 如果此映射将一个或多个键映射到指定的值，则返回true boolean isEmpty() 判断集合是否为空 获取 V get(Object key) 返回到指定键所映射的值 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此地图中包含的映射的Set视图 Set&lt;K&gt; keySet() 返回此地图中包含的键的Set视图 Collection&lt;V&gt; values() 返回此地图中包含的值的Collection视图 长度 int size() 返回此地图中键值映射的数量 Map集合的遍历 //创建集合 Map&lt;String,String&gt; map=new Map&lt;String,String&gt;(); //添加数据 map.put(&quot;德国&quot;,&quot;克罗斯&quot;); map.put(&quot;法国&quot;,&quot;格列兹曼&quot;); map.put(&quot;比利时&quot;,&quot;德布劳内&quot;); 方式一： //获取键值集合 Set&lt;String&gt; set=map.keySet(); for(String s:set){ v=map.get(s); System.out.println(s+&quot;---&gt;&quot;+v); } 方式二： //获取映射Set集合 Set&lt;Map.Entry&lt;String,String&gt; set=map.entrySet(); for(Map.Entry&lt;String,String&gt; m:set){ key=m.getKey(); value=m.getValue(); System.out.println(key+&quot;---&gt;&quot;+value); }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想-面向对象（基础）]]></title>
    <url>%2F2018%2F08%2F16%2FJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、关键字this关键字this关键字在方法内部使用，表示对“调用方法的那个对象”的引用，如果在方法内调用同一个类的另一个方法可以不使用this super关键字 this &amp;&amp; super A:this本类的引用，super代表父类存储空间的标识（看成对父类的引用） B:this.变量 ，super.变量 -----引用变量 this(.....) ，uper(.....) -----调用构造方法 this.成员方法 ，super.成员方法 -----调用成员方法 static关键字static的特点：1.类中static关键字修饰的变量（静态变量）被类的所有对象共享 class Static{ static int i=47; } 即使创建多个对象也共享同一个变量i： Static st1=new Static(); Static st2=new Static(); st1.i和st2.i指向同一个存储空间地址，有相同的值，也可以通过Static.i引用变量 2.类中static修饰的方法可以在不创建方法的前提下直接调用static修饰的方法不与包含它的类的任何对象关联在一起，不用创建对象通过类本身调用，这是static方法的主要用途 class Static{ public static void increment(){ Static.i++; } } 定义了一个静态方法，通过类直接调用：Static.increment() 3.静态是随着类的加载而加载,与对象无关 4.static方法没有this关键字 5.static方法不能调用非静态方法，反过来可以 6.所有构造方法都默认被static修饰 final关键字1.修饰数据声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量 final修饰基本类型（整型，浮点，字符等），表示一个常量，赋值后不可以改变 final修饰引用类型（类，接口，数组），final使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的 2.修饰方法 final修饰的方法不能被重写（private方法也不可重写） private方法隐式地被指定为final，如果在子类中定义的方法和基类中的一个private方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法 3.修饰类 final修饰的类不可以被继承 成员变量和局部变量 局部变量：在方法外---在栈内存 （变量没有默认初始值）---随之对象的创建产生，随着对象的消失 成员变量： 在方法内---在堆内存 （变量有默认初始值）--随着方法的调用产生 二、继承 java中继承的特点： A: 只支持单继承，不支持多继承 B: 支持多层继承 class A{} class B extends A{} class C extends B{} 注意事项 A:子类只能继承父类中非私有的成员（成员变量和成员方法） B:子类不能继承父类的构造方法，但可以通过super关键字去访问父类构造方法 1.访问权限包访问权限（friendly） ：默认的访问权限通常是包访问权限，当前包中所有其他类可以访问那个成员，对于这个包之外的所有类是privatepublic：公共的，谁都可以访问protected：继承访问权限private：私有的，除了包含该成员的类之外其他类无法访问！注意：a.类不可以用private，protected修饰，只可以是包访问权限和publicb.如果类的构造方法由private修饰，则无法创建该类的对象，从而禁止拥有该类的访问权限，但是任然可以调用访问该类中static修饰的成员 2.类间的关系组合 class Actor{ public void act() {} } class HappyActor{ public void act(){ print(&quot;HappyActor&quot;); } class SadActor{ public void act(){ print(&quot;SadActor&quot;); } } class Stage{ privat Actor actor=new HappyActor(); public void change(){ actor=new SadActor(); } public void perform(){ actor.act(); } } 继承代理 3.重写和重载 重写（Override） 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。 为了满足里式替换原则，重写有有以下两个限制： 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型。 使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。 重载（Overload） 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。 应该注意的是，返回值不同，其它都相同不算是重载。 三、多态1.多态的前提要有继承关系，要有方法重写，要有父类引用指向子类对象（父类 F = new 子类()) class fu{ public fu(){ } public void show(){ System.out.println(&quot;fu&quot;); } } class zi extends fu{ public void show(){ System.out.println(&quot;show zi&quot;); } public void method(){ Sysltem.out.println(&quot;method zi&quot;); } } class DuotaiDemo{ public static void main(String[] args){ fu f = new zi(); f.show(); } } 2.多态中成员访问特点 A:成员变量—编译看左边，运行看左边 B:构造方法—创建子类对象时，访问父类的构造方法，对父类的数据进行初始化 C:成员方法—编译看左边，运行看右边（因为有成员方法重写，所以调用子类） D:静态方法—编译看左边，运行看左边（静态只和类有关） 多态好处 ：提高了代码的维护性（继承）、扩展性（多态）弊端 ：不能使用子类的特有功能 对象间的转型:向下转型 父-&gt;子 zi z = (zi)f向上转型 子-&gt;父 fu f = new zi() 四、接口1.抽象类和抽象方法抽象类和抽象方法必须用abstract修饰 格式： abstract class 类名 {} public abstract void 方法名(); 特点： 抽样类中不一定有抽样方法，但是有抽样方法的类一定要定义成抽类 抽样类不能实例化，抽象类有构造方法，但不可以实例化，构造方法是给子类调用的 抽象类的子类：如果不想重写抽样方法，子类是一个抽样类，如果想重写抽样方法，子类是一个具体的类 成员特点： 成员变量：既可以是常量，也可以是变量 构造方法：有，用于子类访问父类数据初始化 成员方法：既可以是抽象的，也可以是非抽象的，成员方法是抽象的，子类必须得重写，成员方法是非抽象的，子类继承 2.接口interface产生一个完全抽象的类，此类没有提供任何相应的具体实现，它允许确定方法名、参数列表、和返回类型，但是没有任何方法体。 接口只提供了形式，而未提供任何具体实现 接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected 接口的字段默认都是 static 和 final 的 A.接口成员特点：成员变量：只能是常量，是静态的，默认修饰符 public static final构造方法：没有（所有类都默认继承object类）成员方法：只能是抽象方法，默认修饰符public B.比较 从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 C.使用选择 使用接口：a.需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；b.需要使用多重继承；c.创建不带任何方法定义和成员变量的基类； 使用抽象类：a.需要在几个相关的类中共享代码；b.需要能控制继承来的成员的访问权限，而不是都为 public；c.需要继承非静态和非常量字段； 在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低 D.关系类和类：继承关系，只能单继承，多层继承类和接口：实现关系，可以单实现也可以多实现，可以在继承一个类的同时实现多个接口接口和接口：继承关系，可以单继承，也可多继承 五、内部类匿名内部类内部类的简写前提：存在一个类和接口类名或接口 格式： new名 () { 方法重写; };本质是一个继承了该类或实现了接口的子类匿名对象 六、字符串String主要方法构造方法 public String() 空构造 public String(byte[] bytes) 把字节数组转换成字符串 public String(byte[] bytes,int offset,int length) 把字节数组一部分转换成字符串 public String(char[] value) 把字符数组转换成字符串 public String(char[] value,int offset,int count) 把字符数组一部分转换成字符串 public String(String original) eg. String s = new String(参数) 成员方法 **判断功能** public boolean equals(Object anObject) 比较字符串的内容是否相同 public boolean equalsIgnoreCase(String str) 比较字符串的内容是否相同，忽略大小写 public boolean contens(String str) 大的字符串是否包含小串 public boolean startsWith(String str) 判断字符串是否以某个特定的字符串开头 public boolean endsWith(String str) 判断字符串是否以某个特定的字符串结尾 public boolean isEmpty() 判断字符串是否为空 **获取功能** public int length() 获取字符串长度 public char charAt(int index) 返回索引处的字符 public int indexOf(int ch) 返回指定字符第一次出现的字符串内的索引 public int indexOf(String str) 返回指定子字符串第一次出现的字符串内的索引。 public int indexOf(int ch,int fromIndex) 返回指定字符第一次出现的字符串内的索引，以指定的索引开始搜索 public int indexOf(String str,int fromIndex) 返回指定子串的第一次出现的字符串中的索引，从指定的索引开始 public String substring(int beginIndex) 返回一个字符串，该字符串是此字符串的子字符串。 子字符串以指定索引处的字符开头，并扩展到该字符串的末尾 public String substring(int beginIndex,int endIndex) 返回一个字符串，该字符串是此字符串的子字符串，子串开始于指定beginIndex并延伸到字符索引endIndex - 1 **转换功能** public byte[] getBytes() 把字符串换换为字节数组 public toCharArray() 把字符串转换为字符数组 public static String valueof(char[] chs) 字符数组转化成字符串 public static String valueof(int i) 把int转化成字符串 public String toLowerCase() 字符串变小写 public String toUpperCase() 字符串变小写 public String concat(String str) 字符串拼接 **替换功能** public String replace(char old,char new); public String replace(String old,String new); **去除字符串开头结尾两个空格** public String trim(); **按字典顺序比较两个字符串** public int compareTo(String str); public int compareToIgnorceCase(String str); String, StringBuffer and StringBuilder 可变性String 不可变StringBuffer 和 StringBuilder 可变 线程安全String 不可变，因此是线程安全的StringBuilder 不是线程安全的StringBuffer 是线程安全的，内部使用 synchronized 进行同步 类型转换String和StringBuffer相互转换 String s = new String() A:StringBuffer sb = new StringBuffer(s) B:StringBuffer sd2 = new StringBuffer() sb2.append(s) StringBuffer sb = new Stringbuffer(&quot;java&quot;) A:String str = new String(sb) B:String str2 = sb.toString() String和int int a=100; String s2=String.valueOf(a); System.out.println(s2); String s =&quot;100&quot;; int y=Integer.parseInt(s); System.out.println(y);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-网络编程]]></title>
    <url>%2F2018%2F08%2F11%2FJava-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[网络编程的三要素IP地址 概念：IP地址是网络中计算机的唯一标识 IP的组成：网络号+主机号 java提供了InetAddress类来对IP地址解析和操作 确定主机名称的IP地址public static InetAddress getByName(String host)获取此IP地址的主机名 public String getHostName() 端口 端口是正在运行程序的标识 协议 UDP 将数据源和目的地封装在数据包中，无连接，是不可靠协议，不需要建立连接，速度快 TCP 建立连接，形成传输数据的通道，在连接中进行大数据量的传输，通过三次握手完成连接，是可靠地，效率会低 Socket网络编程Socket包含了IP地址和端口号Socket原理机制：通信的两端都有Socket，网络通信其实是Socket间的通信，数据在两个Socket间通过IO传输 UDP UDP使用DatagramSocket类用于发送和接收数据报数据包 构造方法：public DatagramSocket()—发送数据使用的构造方法public DatagramSocket(int port)—接收数据使用的构造方法主要成员方法：public void close()关闭此数据报套接字public void send(DatagramPacket p)从此套接字发送数据报包public void receive(DatagramPacket p)从此套接字接收数据报包 发送和接收的数据是DatagramPacket类的，该类表示数据报包，send方法中需要传递DatagramPacket对象 构造方法：public DatagramPacket(byte[] buf,int length,InetAddress address,int port)–发送数据使用的构造方法public DatagramPacket(byte[] buf,int length) –接收数据使用的构造方法buf - 分组数据length - 包长度address - 目的地址port - 目的端口号主要成员方法：public byte[] getData()返回数据缓冲区public int getLength()返回要发送的数据的长度或接收到的数据的长度public InetAddress getAddress()返回该数据报发送或接收数据报的计算机的IP地址 UDP协议发送数据 1.创建发送端Socket对象 2.创建数据并打包 3.调用Socket对象的发送方法发送数据 4.释放资源 下面为实现UDP协议发送数据 public class send{ public static void main(String[] args){ //创建发送端Socket DatagramSocket ds=new DatagramSocket(); //创建数据并打包 byte[] bys=&quot;UDP协议发送的数据&quot;.getBytes(); int length=bys.length; //发送数据的目的IP地址 InetAddress address=InetAddress.getByName(&quot;主机名&quot;)； //发送端计算机的端口 int port=10086; DatagramPacket dp=new DatagramPacket(bys,length,address,port); //发送数据 ds.send(dp); //释放资源 ds.close(); } } UDP协议接收数据1.创建接收端Socket2.创建数据包接收数据（接受容器）3.用Socket接受方法接收数据4.解析数据输出5.释放资源 下面为实现UDP协议接收数据 public class Receive { public static void main(String[] args) throws IOException { // TODO Auto-generated method stub //创建接收端Socket DatagramSocket ds=new DatagramSocket(10086); //创建数据包接收 byte[] bys=new byte[1024]; int length=bys.length; DatagramPacket dp=new DatagramPacket(bys,length); //接收数据 ds.receive(dp); //解析数据 InetAddress address=dp.getAddress(); String ip=address.getHostAddress(); byte[] bys2=dp.getData(); int len=dp.getLength(); String s=new String(bys2,0,len); System.out.println(ip+&quot;:&quot;+s); //释放资源 ds.close(); } } TCPTCP协议发送数据 （客户端）1.创建发送端Socket2.获取输出流写数据3.释放资源 TCP发送客户端使用的是Socket类 构造方法：public Socket(InetAddress address,int port)public Socket(String host,int port)主要成员方法：public void close()关闭public OutputStream getOutputStream()返回此套接字的输出流 public class TSend { public static void main(String[] args) throws IOException { //创建Socket Socket s=new Socket(&quot;daw-PC&quot;,10086); //获取输出流写数据 OutputStream os=s.getOutputStream(); os.write(&quot;TCP发送数据&quot;.getBytes()); //释放资源 s.close(); } } TCP协议接收数据（服务器）1.创建接收端Socket2.监听客户端连接，返回对应的Socket对象3.获取输入流读数据4.释放资源 TCP接收客户端使用的是ServeSocket类 构造方法：public ServerSocket(int port)成员方法：public Socket accept()监听 ，返回的是Scoket类，所以需要Socket类的方法Socket类的—public InputStream getInputStream()返回此套接字的输入流 public class TReceive { public static void main(String[] args) throws IOException { //创建接收端Socket ServerSocket ss=new ServerSocket(10086); //监听客户端 Socket s=ss.accept(); //获取输入流写数据 InputStream is=s.getInputStream(); byte[] bys=new byte[1024]; int len=is.read(bys); String str=new String(bys,0,len); System.out.println(str); //释放资源，注意不关闭服务器 s.close(); } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo部署到github后，github无法访问或缓慢的问题]]></title>
    <url>%2F2018%2F08%2F11%2Fhexo%E9%83%A8%E7%BD%B2%E5%88%B0github%E5%90%8E%EF%BC%8Cgithub%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E6%88%96%E7%BC%93%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题（problem）在将搭建好的博客部署到github上后，出现了无法访问和github有关的一切网址，包括github本身和博客页面，有时知识访问缓慢甚至链接超时。 解决方法通过修改电脑中的hosts文件，加速对网站域名的解析，加快链接的加载速度 通过如下路径找到hosts文件 C:\Windows\System32\drivers\etc 将下面的内容复制到hosts文件里，保存即可 192.30.253.112 github.com192.30.253.119 gist.github.com151.101.100.133 assets-cdn.github.com151.101.100.133 raw.githubusercontent.com151.101.100.133 gist.githubusercontent.com151.101.100.133 cloud.githubusercontent.com151.101.100.133 camo.githubusercontent.com151.101.100.133 avatars0.githubusercontent.com151.101.100.133 avatars1.githubusercontent.com151.101.100.133 avatars2.githubusercontent.com151.101.100.133 avatars3.githubusercontent.com151.101.100.133 avatars4.githubusercontent.com151.101.100.133 avatars5.githubusercontent.com151.101.100.133 avatars6.githubusercontent.com151.101.100.133 avatars7.githubusercontent.com151.101.100.133 avatars8.githubusercontent.com]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>issue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2F2018%2F08%2F10%2FMarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.标题设置 在一句或一段文字前加入#就可以将其设置为标题，标题分为六级 # 一级标题## 二级标题 ......###### 六级标题 2.引用 &gt; 为引用标志 3.图片和连接 图片： ![]() 链接： []() 方括号内为图片或链接的名字，圆括号里为图片和链接的地址 插入的图片地址需要图床，推荐SM.MS的服务生成URL地址，SM.MS 4.粗体和斜体 两个*包括的为粗体，一个*包括的为斜体这是粗体这是斜体 5.表格 例子如下 | country | name | age | | …….. |:…….:| …:| | Germery | keluosi | 27 | | Franch | pawaer | 24 | 6.代码框 用两个`把代码框起来 class Test{ public static void main(String[] args){ System.out.println(&quot;Hello World&quot;); } } 7.分割线 通过三个***来表示分割线 8.列表 列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格 9.特殊换行 每一行最后添加两个空格表示回车换行，一个简单的回车不是换行，两次回车键使前后两行彻底分开 一个特殊的符号]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
