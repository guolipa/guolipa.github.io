<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构与算法-排序算法总结]]></title>
    <url>%2F2020%2F08%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[排序算法总结： 术语说明： 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度： 一个算法执行所耗费的时间； 空间复杂度：运行完一个程序所需内存的大小。 Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序 1. 冒泡排序（Bubble Sort）冒泡排序：是一种简单的排序算法，它从左到右不断交换相邻逆序的元素，在一轮遍历后，可以让未排序部分中最大的元素浮到右侧。不多的从左到右调整，直至数组有序。12345678910111213141516 public int[] bubbleSort(int [] input)&#123; if(input.length == 0)&#123; return input; &#125; for(int i=input.length-1; i&gt;0; i--)&#123; for(int j=0; j&lt;i; j++)&#123; if(input[j] &gt; input[j+1])&#123; int temp = input[j]; input[j] = input[j+1]; input[j+1] = temp; &#125; &#125; &#125; return input;&#125; 算法分析 时间复杂度： O(n^2) 空间复杂度： O(1) 2. 选择排序（Selection Sort）选择排序：首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。选择排序是表现最稳定的排序算法之一 ，因为无论什么数据进去都是O(n2)的时间复杂度 ，所以用到它的时候，数据规模越小越好。123456789101112131415161718 public int[] selectSort(int [] input)&#123; if(input.length == 0)&#123; return input; &#125; for(int i=0; i&lt;input.length; i++)&#123; int minIndex = i; for(int j=i+1; j&lt;input.length; j++)&#123; if(input[j] &lt; input[minIndex])&#123; minIndex = j; &#125; &#125; int temp = input[i]; input[i] = input[minIndex]; input[minIndex] = temp; &#125; return input;&#125; 算法分析 时间复杂度： O(n^2) 空间复杂度： O(1) 3.插入排序（Insertion Sort）插入排序： 直接插入排序是将无序序列中的数据插入到有序的序列中，在遍历无序序列时，首先拿无序序列中的首元素去与有序序列中的每一个元素比较并插入到合适的位置，一直到无序序列中的所有元素插完为止。对于一个无序序列arr{4，6，8，5，9}来说，我们首先先确定首元素4是有序的，然后在无序序列中向右遍历，6大于4则它插入到4的后面，再继续遍历到8，8大于6则插入到6的后面，这样继续直到得到有序序列{4，5，6，8，9}。插入排序所需的时间取决于输入中元素的初始顺序。插入排序对于实际应用中常见的某些类型的非随机数组很有效。插入排序对于部分有序的数组十分高效，也很适合小规模数组。 12345678910111213141516 public int[] insertSort(int [] input)&#123; if(input.length == 0)&#123; return input; &#125; for(int i=1; i&lt;input.length; i++)&#123; int preIndex = i - 1; int current = input[i]; while(preIndex&gt;=0 &amp;&amp; input[preIndex]&gt;current)&#123; input[preIndex+1] = input[preIndex]; preIndex --; &#125; input[preIndex+1] = current; &#125; return input;&#125; 算法分析 时间复杂度: O(n^2) 空间复杂度: O(1) 4. 希尔排序（Shell Sort）希尔排序：对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。希尔排序又叫缩小增量排序。 1234567891011121314151617181920 public int[] shellSort(int [] input)&#123; if(input.length == 0)&#123; return input; &#125; int h = input.length / 2; while(h &gt; 0)&#123; for(int i=h; i&lt;input.length; i++)&#123; int preIndex = i - h; int temp = input[i]; while(preIndex&gt;=0 &amp;&amp; input[preIndex]&gt;temp)&#123; input[preIndex+h] = input[preIndex]; preIndex -= h; &#125; input[preIndex + h] = temp; &#125; h /= 2; &#125; return input;&#125; 算法分析希尔排序的运行时间达不到平方级别， 希尔排序比插入排序和选择排序要快得多，并且数组越大，优势越大。 5. 归并排序（Merge Sort）归并排序： 是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 算法描述 步骤1：把长度为n的输入序列分成两个长度为n/2的子序列； 步骤2：对这两个子序列分别采用归并排序； 步骤3：将两个排序好的子序列合并成一个最终的排序序列。 12345678910111213141516171819202122232425262728293031323334353637 public int[] mergeSort(int [] input)&#123; if(input.length == 0)&#123; return input; &#125; sort(input, 0, input.length-1) return input;&#125; public void sort(int[] input, int lo, int hi)&#123; if(hi &lt;= lo)&#123; return; &#125; int mid = lo + (hi - lo)/2; sort(input, lo, mid); sort(input, mid+1, hi); merge(input, lo, mid, hi);&#125; // 将子序列合并 public void merge(int[] input, int lo, int mid, int hi)&#123; int i = lo; // 左边数组的起始位置 int j = mid + 1; // 右边数组的起始位置 int[] ret = new int[input.length]; for(int k=0; k&lt;input.length; k++)&#123; ret[k] = input[k]; &#125; for(int k=lo; k&lt;hi; k++)&#123; if(i &gt; mid)&#123; input[k] = ret[j++]; // 左边数组用尽 &#125;else if(j &gt; hi)&#123; input[k] = ret[i++]; // 右边数组用尽 &#125;else if(ret[j] &lt; ret[i])&#123; input[k] = ret[j++]; // 右边的数小 &#125;else&#123; input[k] = ret[i++]; // 左边的数小 &#125; &#125;&#125; 算法分析归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn 的时间复杂度。代价是需要额外的内存空间。 时间复杂度：O(nlogn) 空间复杂度：O(n) 6. 快速排序（Quick Sort）快速排序：通过分割元素将待排序的序列分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 快速排序是最快的通用排序方法, 因为快速排序内循环指令少，他还能利用缓存（因为总是顺序访问数组），时间复杂度都是~cNlgN. 算法描述： 从数列中挑出一个元素，称为 “基准” (pivot)； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 12345678910111213141516171819 public int[] sort(int [] input)&#123; if(input.length == 0)&#123; return input; &#125; sort(input, 0, input.length-1) return input;&#125; public void quickSort(int[] input, int lo, int hi)&#123; if(lo &gt;= hi)&#123; return; &#125; int pivot = partition(input, lo, hi); // 基准值 sort(input, lo, pivot-1); sort(input, pivot+1, hi);&#125;public int partition(int[] input, int lo, int hi)&#123; ......;&#125; 将待排序的序列分为两个部分的方法有多种： 方法一： 定义两个指针，begin和end分别指向第一个元素和最后一个元素，基准值key=arr[end]; begin从前向后移动，当遇到大于key的时候停下来，end从后向前移动，当遇到小于key的时候停下，交换begin和end对应的元素； 重复上一步，直至begin与end相遇，begin对应的元素与key值进行交换。 123456789101112131415161718public int partition(int[] input, int lo, int hi)&#123; int v = input[lo]; while(lo &lt; hi)&#123; while(lo &lt; hi &amp;&amp; input[hi] &gt;= v)&#123; hi--; &#125; while(lo &lt; hi &amp;&amp; input[lo] &lt;= v)&#123; lo++; &#125; &#125; input[lo] = v; return lo;&#125; public void swap(int[] input, int i, int j)&#123; int temp = input[i]; input[i] = input[j]; input[j] = temp;&#125; 方法二：挖坑法 定义两个指针，begin和end分别指向第一个元素和最后一个元素，基准值key=arr[end]; begin从前向后移动，当遇到大于key的时候停下来，将begin位置的数据放置end处，begin变为坑； end从后开始向前移动，当遇到小于key的时候停下来，将end处的数据放置坑（begin）处，end变为坑，begin开始移动； 重复2、3两步，直至begin与end相遇，最后的一个坑放key。 123456789101112131415public int partition(int[] input, int lo, int hi)&#123; int v = input[lo]; while(lo &lt; hi)&#123; while(lo &lt; hi &amp;&amp; input[hi] &gt;= v)&#123; hi--; &#125; input[lo] = input[hi]; while(lo &lt; hi &amp;&amp; input[lo] &lt;= v)&#123; lo++; &#125; input[hi] = input[lo]; &#125; input[lo] = v; return lo;&#125; 算法分析 时间复杂度： 平均-O(nlogn)， 最坏-O(n^2) 空间复杂度： O(logn) https://blog.csdn.net/wei_cheng18/article/details/80302818 7. 堆排序堆排序：是指利用堆这种数据结构所设计的一种排序算法。堆这种数据结构是一种完全二叉树，堆分为最大堆和最小堆。 最大堆：二叉树中的任一顶点大于等于它的左右子节点 最小堆：二叉树中的任一顶点小于等于它的左右子节点堆可以用数组来存储表示 7.1 算法描述堆排序分为两个阶段，给定一个无序的数组，首先要做的事构造堆。a.将无序输入数组构建成一个堆，根据升序降序需求选择最大堆或最小堆;b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端，N–，将最大的元素固定,再次调整剩余的部分，不再去管它;c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。对于给定的无序构造堆的一个高效方法就是从右向左进行sink下沉操作，不需要管叶子结点（叶子结点已经算作一个有堆，无法进行下沉操作），所以只需要扫描一半的数组元素。 算法的示意动图可参考下文：https://blog.csdn.net/weixin_41190227/article/details/86600821 7.2 代码实现1234567891011121314151617181920212223242526272829303132333435363738 public class HeapSort&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; @Override public void sort(T[] a)&#123; int N=a.length-1; //构建堆 for(int k=N/2;k&gt;=0;k--)&#123; sink(a,k,N); &#125; //堆排序 while(N&gt;0)&#123; exch(a,1,N--); sink(a,1,N); &#125; &#125; private void sink(T[] a,int k,int N)&#123; while(2*k&lt;=N)&#123; int j=2*k; if(j&lt;N &amp;&amp; less(a[j],a[j+1]))&#123; j++; &#125; if(less(a[k],a[j]))&#123; exch(a,k,j); &#125;else&#123; break; &#125; k=j; &#125; &#125; public static void main(String[] args)&#123; HeapSort&lt;String&gt; b=new HeapSort&lt;String&gt;(); String[] str=&#123;"q","sss","aaa","ccc","qqq","bbb"&#125;; b.sort(str); for(int i=1;i&lt;=str.length-1;i++)&#123; System.out.println(str[i]); &#125; &#125;&#125; 算法分析： 时间复杂度： O(nlogn) 空间复杂度： 1 算 算]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb-Spring框架（1）]]></title>
    <url>%2F2020%2F07%2F28%2FJavaWeb-Spring%E6%A1%86%E6%9E%B6%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Spring框架概述 Spring框架是什么？ Spring是分层的Java SE/EE应用 full-stack轻量级开源框架，以IoC（Inverse Of Control：反转控制）和AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。 Spring的优势 方便解耦，简化开发: 通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 AOP编程的支持: 通过Spring的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。 声明式事务的支持: 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。 方便程序的测试: 可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情 方便集成各种优秀框架: Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的直接支持。 降低JavaEE API的使用难度: Spring对JavaEE API（如JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。 Spring体系结构 IoC的概念和作用程序的耦合与工程模式解耦 程序的耦合 耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差( 降低耦合性，可以提高其独立性)。耦合性存在于各个领域，而非软件设计中独有的，但是我们只讨论软件工程中的耦合。 工厂模式解耦 在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。 那么，这个读取配置文件，创建和获取三层对象的类就是工厂。 创建service和dao对象 1）.需要一个配置文件配置service和dao2）.通过读取配置文件中的配置内容，反射创建对象 IoC的概念 IoC的概念： IoC（Inverse Of Control：控制反转）：把创建对象的权利交给框架，是框架的重要特征，并非面向对象编程的术语。他包括依赖注入（Dependency Injection，DI）和依赖查找（Dependency Lookup） IoC的作用： 消减计算机程序的耦合（解除代码间的依赖关系） 使用Spring Ioc解决程序耦合这里使用的案例是，账户的业务层和持久层的依赖关系解决。创建如下程序： 创建持久层接口和实现类 123456789101112131415161718 /** * 账户的持久层接口 */public interface IAccountDao &#123; /** * 模拟保存账户 */ void saveAccount();&#125;/** * 账户的持久层实现类 */public class AccountDaoImpl implements IAccountDao &#123; public void saveAccount()&#123; System.out.println("保存了账户"); &#125;&#125; 创建业务层接口和实现类 12345678910111213141516171819202122 /** * 账户业务层的接口 */public interface IAccountService &#123; /** * 模拟保存账户 */ void saveAccount();&#125; /** * 账户的业务层实现类 */public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao ; public AccountServiceImpl()&#123; System.out.println("对象创建了"); &#125; public void saveAccount()&#123; accountDao.saveAccount(); &#125; &#125; 基于XML的配置 导入Spring jar包 在resources目录下创建任意.xml文件 123456789101112 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--把对象的创建交给spring来管理--&gt; &lt;bean id="accountService" class="bjtu.service.impl.AccountServiceImpl"&gt;&lt;/bean&gt; &lt;bean id="accountDao" class="bjtu.dao.impl.AccountDaoImpl"&gt;&lt;/bean&gt; &lt;/beans&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb-Mybatis框架(2)]]></title>
    <url>%2F2020%2F07%2F25%2FJavaWeb-Mybatis%E6%A1%86%E6%9E%B6-2%2F</url>
    <content type="text"><![CDATA[Mybatis对数据库的单表CUDA操作1. 配置Mybatis的主配置文件SqlMapConfig，配置数据库的基本信息以及操作的映射配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;!-- mybatis的主配置文件 --&gt; &lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;!-- 配置mysql的环境--&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;!-- 配置事务的类型--&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db_mybatis?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;bjtu/dao/UserDao.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 2. 实现User类，定义类属性，和数据库表user中的列值对应 3. 实现操作接口UserDao，定义每个操作数据库的方法 public interface UserDao { /* 查询所有操作 */ //@Select(&quot;select * from user&quot;) List&lt;user&gt; findAll(); /** * 保存user * @param u */ void saveUser(user u); /** * 更新信息 * @param u */ void updateUser(user u); /** * 删除用户 * @param userID */ void deleteUser(Integer userID); /** * 按ID查询用户信息 * @param userID */ user findById(Integer userID); /** * 按名称模糊查询用户信息 */ List&lt;user&gt; findByName(String username); /** * 聚合函数：查询总记录条数 */ int findTotal(); } 4. 将UserDao中的每个方法在映射配置文件UserDao.xml中进行配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;bjtu.dao.UserDao&quot;&gt; &lt;!--配置查询结果的列名与实体类的属性名的对应关系--&gt; &lt;resultMap id=&quot;userMap&quot; type=&quot;bjtu.domain.user&quot;&gt; &lt;!-- 主键字段的对应--&gt; &lt;id property=&quot;userId&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;!-- 非主键字段的对应--&gt; &lt;result property=&quot;userName&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userBirthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userSex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userAddress&quot; column=&quot;address&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--配置查询所有--&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt; select * from user &lt;/select&gt; &lt;!--插入保存用户--&gt; &lt;insert id=&quot;saveUser&quot; parameterType=&quot;bjtu.domain.user&quot;&gt; &lt;!--配置插入数据后，获取新增数据的id--&gt; &lt;selectKey keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt; select last_insert_id() &lt;/selectKey&gt; insert into user(username,address,sex,birthday) values(#{username},#{address},#{sex},#{birthday}) &lt;/insert&gt; &lt;!--更新用户信息--&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;bjtu.domain.user&quot;&gt; update user set username=#{username},address=#{address},sex=#{sex},birthday=#{birthday} where id=#{id} &lt;/update&gt; &lt;!--删除用户--&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from user where id=#{uid} &lt;/delete&gt; &lt;!--按ID查询一个用户的信息--&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultMap=&quot;userMap&quot;&gt; select * from user where id=#{uid} &lt;/select&gt; &lt;!--按名称模糊查询用户信息--&gt; &lt;select id=&quot;findByName&quot; parameterType=&quot;string&quot; resultMap=&quot;userMap&quot;&gt; select * from user where username like #{name} &lt;/select&gt; &lt;!--利用聚合函数查询总记录条数--&gt; &lt;select id=&quot;findTotal&quot; resultType=&quot;int&quot;&gt; select count(id) from user &lt;/select&gt; &lt;/mapper&gt; 其中 resultMap 是用来将User类中的属性名和mysql中user表中的类名对应： &lt;resultMap id=&quot;userMap&quot; type=&quot;bjtu.domain.user&quot;&gt; &lt;!-- 主键字段的对应--&gt; &lt;id property=&quot;userId&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;!-- 非主键字段的对应--&gt; &lt;result property=&quot;userName&quot; column=&quot;username&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userBirthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userSex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;userAddress&quot; column=&quot;address&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; 5. 在test目录下写测试程序 MybatisTest.java public class MybatisTest { private InputStream in; private SqlSession sqlSession; private UserDao userDao; @Before public void init() throws Exception{ //1. 读取配置文件 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //2. 获取SqlFactorySession SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3. 获取SqlSession对象 sqlSession = factory.openSession(); //4. 获取dao的代理对象 userDao = sqlSession.getMapper(UserDao.class); } @After public void destory() throws Exception{ sqlSession.commit(); //释放资源 sqlSession.close(); in.close(); } /* 测试查询所有数据功能 */ @Test public void testFindAll() throws Exception{ List&lt;user&gt; users = userDao.findAll(); for(user u: users){ System.out.println(u); } } /* 测试保存功能 */ @Test public void testSave() throws Exception{ user u = new user(); u.setUserName(&quot;李明&quot;); u.setUserAddress(&quot;北京海淀&quot;); u.setUserSex(&quot;男&quot;); u.setUserBirthday(new Date()); System.out.println(&quot;Before saving:&quot;+u); userDao.saveUser(u); System.out.println(&quot;After saving:&quot;+u); } /** * 测试更新信息功能 */ @Test public void testUpdate(){ user u = new user(); u.setUserId(49); u.setUserName(&quot;Mybatis&quot;); u.setUserAddress(&quot;bjtu&quot;); u.setUserSex(&quot;m&quot;); u.setUserBirthday(new Date()); userDao.updateUser(u); } /** * 测试删除功能 */ @Test public void testDelete(){ userDao.deleteUser(57); } /** * 按ID查询一个用户的信息 */ @Test public void testFindOne(){ user u = userDao.findById(48); System.out.println(u); } /** * 按名称模糊查询用户的信息 */ @Test public void testFindByName(){ List&lt;user&gt; users = userDao.findByName(&quot;%王%&quot;); for(user u: users){ System.out.println(u); } } /** * 利用聚合函数查询总记录的条数 */ @Test public void testFindTotal(){ int s = userDao.findTotal(); System.out.println(&quot;总记录条数:&quot;+s); } } Mybatis连接池和事务 事务 在Mybatis的SqlMapConfig.xml配置文件中，通过来实现Mybatis中连接池的配置。 type属性的三种取值： UNPOOLED 不使用连接池的数据源 POOLED 使用连接池的数据源 JNDI 使用JNDI实现的数据源 MyBatis内部分别定义了实现了java.sql.DataSource接口的UnpooledDataSource，PooledDataSource类来表示UNPOOLED、POOLED类型的数据源。 事务 什么是事务？ 事务的四大特性：ACID 不考虑隔离就产生的三个问题 解决方法：四种隔离级别 Mybatis多表查询1. 数据库创建表在数据库中创建user、account和role两个表，并设置外键关联。 1）创建user表 DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` int(11) NOT NULL auto_increment, `username` varchar(32) NOT NULL COMMENT &apos;用户名称&apos;, `birthday` datetime default NULL COMMENT &apos;生日&apos;, `sex` char(1) default NULL COMMENT &apos;性别&apos;, `address` varchar(256) default NULL COMMENT &apos;地址&apos;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; insert into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (41,&apos;老王&apos;,&apos;2018-02-27 17:47:08&apos;,&apos;男&apos;,&apos;北京&apos;),(42,&apos;小二王&apos;,&apos;2018-03-02 15:09:37&apos;,&apos;女&apos;,&apos;北京金燕龙&apos;),(43,&apos;小二王&apos;,&apos;2018-03-04 11:34:34&apos;,&apos;女&apos;,&apos;北京金燕龙&apos;),(45,&apos;传智播客&apos;,&apos;2018-03-04 12:04:06&apos;,&apos;男&apos;,&apos;北京金燕龙&apos;),(46,&apos;老王&apos;,&apos;2018-03-07 17:37:26&apos;,&apos;男&apos;,&apos;北京&apos;),(48,&apos;小马宝莉&apos;,&apos;2018-03-08 11:44:00&apos;,&apos;女&apos;,&apos;北京修正&apos;); 2） 创建account表 DROP TABLE IF EXISTS `account`; CREATE TABLE `account` ( `ID` int(11) NOT NULL COMMENT &apos;编号&apos;, `UID` int(11) default NULL COMMENT &apos;用户编号&apos;, `MONEY` double default NULL COMMENT &apos;金额&apos;, PRIMARY KEY (`ID`), KEY `FK_Reference_8` (`UID`), CONSTRAINT `FK_Reference_8` FOREIGN KEY (`UID`) REFERENCES `user` (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; insert into `account`(`ID`,`UID`,`MONEY`) values (1,46,1000),(2,45,1000),(3,46,2000); 3）创建role表 DROP TABLE IF EXISTS `role`; CREATE TABLE `role` ( `ID` int(11) NOT NULL COMMENT &apos;编号&apos;, `ROLE_NAME` varchar(30) default NULL COMMENT &apos;角色名称&apos;, `ROLE_DESC` varchar(60) default NULL COMMENT &apos;角色描述&apos;, PRIMARY KEY (`ID`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; insert into `role`(`ID`,`ROLE_NAME`,`ROLE_DESC`) values (1,&apos;院长&apos;,&apos;管理整个学院&apos;),(2,&apos;总裁&apos;,&apos;管理整个公司&apos;),(3,&apos;校长&apos;,&apos;管理整个学校&apos;); DROP TABLE IF EXISTS `user_role`; CREATE TABLE `user_role` ( `UID` int(11) NOT NULL COMMENT &apos;用户编号&apos;, `RID` int(11) NOT NULL COMMENT &apos;角色编号&apos;, PRIMARY KEY (`UID`,`RID`), KEY `FK_Reference_10` (`RID`), CONSTRAINT `FK_Reference_10` FOREIGN KEY (`RID`) REFERENCES `role` (`ID`), CONSTRAINT `FK_Reference_9` FOREIGN KEY (`UID`) REFERENCES `user` (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; insert into `user_role`(`UID`,`RID`) values (41,1),(45,1),(41,2);DROP TABLE IF EXISTS `role`; 2. 一对一和一对多查询本次案例主要以最为简单的用户和账户的模型来分析Mybatis 多表关系。 用户为User 表，账户为Account表。一个用户（User）可以有多个账户（Account）。 准备： 1. 建立两张表：用户表（User）和账户表（Account） 让用户和账户表之间具有一对多的关系，需要外键在账户表中添加 2. 简历两个实体类：用户实体类和账户实体类 让用户和账户实体类中体现一对多的关系 3. 建立两个配置文件： 用户配置文件 账户配置文件 4. 实现配置 当查询用户时，可以同时得到用户下所包含的账户信息 当查询账户时，可以同时得到账户所属的用户信息 账户一对一对应用户，AccountDao.xml查询配置文件 用户一对多用户1）首先要在User类中增加user与account一对多关系，即一个用户下有多个accounts，用集合封装。2）其次修改UserDao.xml查询配置文件 3. 多对多查询 示例描述 示例：用户和角色 一个用户可以有多个角色 一个角色可以赋予多个用户 步骤： 1、建立两张表：用户表，角色表 让用户表和角色表具有多对多的关系。需要使用中间表，中间表中包含各自的主键，在中间表中是外键。 2、建立两个实体类：用户实体类和角色实体类 让用户和角色的实体类能体现出来多对多的关系 各自包含对方一个集合引用 3、建立两个配置文件 用户的配置文件 角色的配置文件 4、实现配置： 当我们查询用户时，可以同时得到用户所包含的角色信息 当我们查询角色时，可以同时得到角色的所赋予的用户信息 这个多对多的搜索主要是修改SQL语句，映射文件.xml的配置和一对多查询操作类似 * UserDao.xml配置文件，RoleDao.xml文件配置类似 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;bjtu.dao.RoleDao&quot;&gt; &lt;!--定义User的resultMap--&gt; &lt;resultMap id=&quot;roleMap&quot; type=&quot;bjtu.domain.Role&quot;&gt; &lt;id property=&quot;roleId&quot; column=&quot;rid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;roleDesc&quot; column=&quot;role_desc&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;users&quot; ofType=&quot;bjtu.domain.User&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--配置查询所有--&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;roleMap&quot;&gt; select u.*, r.id as rid, r.role_name, r.role_desc from role r left outer join user_role ur on r.id = ur.rid left outer join user u on u.id = ur.uid &lt;/select&gt; &lt;/mapper&gt; Mybatis的缓存 Mybatis中的延迟加载 问题：在一对多中，当我们有一个用户，它有100个账户。 在查询用户的时候，要不要把关联的账户查出来？ 在查询账户的时候，要不要把关联的用户查出来？ 在查询用户时，用户下的账户信息应该是，什么时候使用，什么时候查询的。 在查询账户时，账户的所属用户信息应该是随着账户查询时一起查询出来。 什么是延迟加载? 在真正使用数据时才发起查询，不用的时候不查询。按需加载（懒加载） 什么是立即加载? 不管用不用，只要一调用方法，马上发起查询。 在对应的四种表关系中：一对多，多对一，一对一，多对多。 一对多，多对多：通常情况下我们都是采用延迟加载； 多对一，一对一：通常情况下我们都是采用立即加载。 Mybatis中的缓存 什么是缓存 存在于内存中的临时数据。 为什么使用缓存 减少和数据库的交互次数，提高执行效率。 什么样的数据能使用缓存，什么样的数据不能使用 适用于缓存： 经常查询并且不经常改变的。 数据的正确与否对最终结果影响不大的。 不适用于缓存： 经常改变的数据 数据的正确与否对最终结果影响很大的。 例如：商品的库存，银行的汇率，股市的牌价。 Mybatis中的一级缓存和二级缓存 一级缓存： * 它指的是Mybatis中SqlSession对象的缓存。 * 当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供一块区域中。该区域的结构是一个Map。当我们再次查询同样的数据，mybatis会先去sqlsession中查询是否有，有的话直接拿出来用。 * 当SqlSession对象消失时，mybatis的一级缓存也就消失了。 * 如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 二级缓存: * 它指的是Mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。 * 二级缓存的使用步骤： * 第一步：让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置） * 第二步：让当前的映射文件支持二级缓存（在IUserDao.xml中配置） * 第三步：让当前的操作支持二级缓存（在select标签中配置） Mybatis中的注解开发这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper(即UserDap.xml、AccountDao.xml等配置文件)映射文件了。在Mybatis中只能使用映射配置文件和注解配置一种方式，所以使用注解配置时，应将映射配置文件移除。 1. 单表的CUDA操作首先针对单表的CUDA操作，只需要在UserDao接口文件的相关方法上添加配置即可。Mybatis中有四种SQL相关的语句配置： @Insert: 实现新增 @Update: 实现更新 @Delete: 实现删除 @Select: 实现查询 以User类的接口UserDao为例，程序改写如下： public interface UserDao { /* 查询所有用户，同时获取用户下所有的账户信息 */ @Select(&quot;select * from user&quot;) @Results(id = &quot;userMap&quot;, value={ @Result(id = true, column = &quot;id&quot;, property = &quot;id&quot;), @Result(column = &quot;username&quot;, property = &quot;username&quot;), @Result(column = &quot;address&quot;, property = &quot;address&quot;), @Result(column = &quot;sex&quot;, property = &quot;sex&quot;), @Result(column = &quot;birthday&quot;, property = &quot;birthday&quot;), }) List&lt;User&gt; findAll(); /** * 按ID查询用户信息 * @param userID */ @Select(&quot;select * from user where id = #{uid}&quot;) @ResultMap(value = {&quot;userMap&quot;}) User findById(Integer userID); /** * 插入保存user * @param u */ @Insert(&quot;insert into user(username,address,sex,birthday) values(#{username},#{address},#{sex},#{birthday})&quot;) @ResultMap(value = {&quot;userMap&quot;}) void saveUser(User u); /** * 更新信息 * @param u */ @Update(&quot;update user set username=#{username},address=#{address},sex=#{sex},birthday=#{birthday} where id=#{id}&quot;) @ResultMap(value = {&quot;userMap&quot;}) void updateUser(User u); /** * 删除用户 * @param userID */ @Delete(&quot;delete from user where id = #{id}&quot;) @ResultMap(value = {&quot;userMap&quot;}) void deleteUser(Integer userID); /** * 按名称模糊查询用户信息 */ @Select(&quot;select * from user where username like #{username}&quot; ) @ResultMap(value = {&quot;userMap&quot;}) //@Select(&quot;select * from user where username like &apos;%${value}%&apos;&quot; ) List&lt;User&gt; findByName(String username); /** * 聚合函数：查询总记录条数 */ @Select(&quot;select count(id) from user&quot;) @ResultMap(value = {&quot;userMap&quot;}) int findTotal(); } 只需要在方法之上添加 @Select(“SQL语句”)，@Insert(“SQL语句”)，@Update(“SQL语句”)，@Delect(“SQL语句”)。 另外，若User类中的属性与数据库中user表的列名不一致，需要增加 @Results() 注解配置，类似于UserDao.xml中的配置。 2. 多表操作配置 一对一配置 一对多配置]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb-Mybatis框架(1)]]></title>
    <url>%2F2020%2F07%2F18%2FJavaWeb-Mybatis%E6%A1%86%E6%9E%B6-1%2F</url>
    <content type="text"><![CDATA[MVC模式 Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。 通常模型对象负责在数据库中存取数据。 View（视图）是应用程序中处理数据显示的部分。 通常视图是依据模型数据创建的。 Controller（控制器）是应用程序中处理用户交互的部分。 通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。 三层架构概述： 表现层UL：主要是指与用户交互的界面。用于接收用户输入的数据和显示处理后用户需要的数据。 业务层BLL：UI层和DAL层之间的桥梁。实现业务逻辑，处理业务需求。 持久层DAL：与数据库交互，主要实现对数据的增、删、改、查。（mybatis） MyBatis框架概述 mybatis是一个基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。 采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。 Mybatis简单入门搭建Mybatis开发环境： 1.创建Maven工程并在pom.xml文件中添加Mybatis的坐标 2.创建实体类和dao接口 首先在数据库中创建爱你user表，信息如下： 创建User类和UserDao(也可叫UserMapper)接口 // User类 public class user implements Serializable { private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return &quot;user{&quot; + &quot;id=&quot; + id + &quot;, username=&apos;&quot; + username + &apos;\&apos;&apos; + &quot;, birthday=&quot; + birthday + &quot;, sex=&apos;&quot; + sex + &apos;\&apos;&apos; + &quot;, address=&apos;&quot; + address + &apos;\&apos;&apos; + &apos;}&apos;; } } // UserDao 接口 public interface UserDao { /* 查询所有操作 */ List&lt;user&gt; findAll(); } 3.创建Mybatis的主配置文件：SqlMapconfig.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;!-- mybatis的主配置文件 --&gt; &lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;!-- 配置mysql的环境--&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;!-- 配置事务的类型--&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db_mybatis&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;bjtu/dao/UserDao.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 4.创建映射配置文件：UserDao.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;bjtu.dao.UserDao&quot;&gt; &lt;!--配置查询所有--&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;bjtu.domain.User&quot;&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; 注：1）Mybatis的映射配置文件结构必须和dao接口的文件结构相同；2）映射配置文件的mapper标签namespace必须是dao接口的全限定类名；3）映射配置文件的操作配置，id属性的取值必须是dao接口的方法名；满足以上几个配置，在开发中无需再写dao的实现类。 5.创建测试代码 public class MybatisTest { public static void main(String[] args) throws IOException { //1.读取配置文件 InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); //3.使用工厂生产SqlSession对象 SqlSession session = factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 UserDao userDao = session.getMapper(UserDao.class); //5.使用代理对象执行方法 List&lt;user&gt; users = userDao.findAll(); for(user u : users){ System.out.println(u); } //6.释放资源 session.close(); in.close(); } } 使用配置注解的方式 删除UserDao.xml文件，在UserDao接口文件的方法上添加 @Select(“SQL语句”) // UserDao 接口 public interface UserDao { /* 查询所有操作 */ @Select(&quot;select * from user&quot;) List&lt;user&gt; findAll(); } 并改变SqlMapconfig.xml中 mappers配置 &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;!--&lt;mappers&gt;--&gt; &lt;!--&lt;mapper resource=&quot;bjtu/dao/UserDao.xml&quot;/&gt;--&gt; &lt;!--&lt;/mappers&gt;--&gt; &lt;!--如果使用注解的方式配置，此处应使用class属性指定被注解的dao的全限定类名--&gt; &lt;mappers&gt; &lt;mapper class=&quot;bjtu.dao.UserDao&quot;/&gt; &lt;/mappers&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis知识概述]]></title>
    <url>%2F2020%2F07%2F16%2FRedis%E7%9F%A5%E8%AF%86%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Redis 概念： redis是一款高性能的NOSQL系列的非关系型数据库 1.1.什么是NOSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1.NOSQL和关系型数据库比较 优点： 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 3）不提供关系型数据库对事务的处理。 1.1.2.非关系型数据库的优势： 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 1.1.3.关系型数据库的优势： 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 1.1.4.总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 1.2.主流的NOSQL产品 • 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 • 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 • 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 • 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 1.3 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset 1.3.1 redis的应用场景 • 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒 • 分布式集群架构中的session分离 下载安装 1). 官网：https://redis.io 2). 中文网：http://www.redis.net.cn/ 3). 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端 命令操作 1). redis的数据结构： - redis存储的是：key,value格式的数据，其中**key都是字符串，value有5种不同的数据结构** - value的数据结构： * 字符串类型 string * 哈希类型 hash ： map格式 * 列表类型 list ： linkedlist格式。支持重复元素 * 集合类型 set ： 不允许重复元素 * 有序集合类型 sortedset：不允许重复元素，且元素有顺序 2). 字符串类型 string 1. 存储： set key value 127.0.0.1:6379&gt; set username zhangsan OK 2. 获取： get key 127.0.0.1:6379&gt; get username &quot;zhangsan&quot; 3. 删除： del key 127.0.0.1:6379&gt; del age (integer) 1 3). 哈希类型 hash 1. 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 2. 获取： * hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; * hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; 3. 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 4). 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： - lpush key value: 将元素加入列表左表 - rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： * lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： * lpop key： 删除列表最左边的元素，并将元素返回 * rpop key： 删除列表最右边的元素，并将元素返回 5). 集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 1 6). 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 1. 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500&quot; 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 7). 通用命令 - keys * : 查询所有的键 - type key ： 获取键对应的value的类型 - del key：删除指定的key value Redis持久化 redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 redis持久化机制： 1) RDB：默认方式，不需要进行配置，默认就使用这种机制 * 在一定的间隔时间中，检测key的变化情况，然后持久化数据 - 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 - 重新启动redis服务器，并指定配置文件名称 D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf 2) AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 - 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化 Java客户端 Jedis Jedis: 一款java操作redis数据库的工具. 使用步骤： 1). 下载jedis的jar包 2). 使用 //1. 获取连接 Jedis jedis = new Jedis(&quot;localhost&quot;,6379); //2. 操作 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //3. 关闭连接 jedis.close(); * Jedis操作各种redis中的数据结构 1) 字符串类型 string set get //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 //存储 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //获取 String username = jedis.get(&quot;username&quot;); System.out.println(username); //可以使用setex()方法存储可以指定过期时间的 key value jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对 //3. 关闭连接 jedis.close(); 2) 哈希类型 hash ： map格式 hset hget hgetAll //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // 存储hash jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;); jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;); jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;); // 获取hash String name = jedis.hget(&quot;user&quot;, &quot;name&quot;); System.out.println(name); // 获取hash的所有map中的数据 Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;); // keyset Set&lt;String&gt; keySet = user.keySet(); for (String key : keySet) { //获取value String value = user.get(key); System.out.println(key + &quot;:&quot; + value); } //3. 关闭连接 jedis.close(); 3) 列表类型 list ： linkedlist格式。支持重复元素 lpush / rpush lpop / rpop lrange start end : 范围获取 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // list 存储 jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存 jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存 // list 范围获取 List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop(&quot;mylist&quot;);//c System.out.println(element1); String element2 = jedis.rpop(&quot;mylist&quot;);//c System.out.println(element2); // list 范围获取 List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 4) 集合类型 set ： 不允许重复元素 sadd smembers:获取所有元素 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // set 存储 jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;); // set 获取 Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;); System.out.println(myset); //3. 关闭连接 jedis.close(); 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 zadd zrange //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // sortedset 存储 jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;); jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;); jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;); // sortedset 获取 Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1); System.out.println(mysortedset); //3. 关闭连接 jedis.close(); * jedis连接池： JedisPool * 使用： 1. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(&quot;hehe&quot;,&quot;heihei&quot;); //4. 关闭 归还到连接池中 jedis.close(); * 连接池工具类 public class JedisPoolUtils { private static JedisPool jedisPool; static{ //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); //创建Properties对象 Properties pro = new Properties(); //关联文件 try { pro.load(is); } catch (IOException e) { e.printStackTrace(); } //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); } /** * 获取连接方法 */ public static Jedis getJedis(){ return jedisPool.getResource(); } } 案例：案例需求： 1. 提供index.html页面，页面中有一个省份 下拉列表 2. 当 页面加载完成后 发送ajax请求，加载所有省份 注意：使用redis缓存一些不经常发生变化的数据。 数据库的数据一旦发生改变，则需要更新缓存。 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入 在service对应的增删改方法中，将redis数据删除。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb-Cookie & Session]]></title>
    <url>%2F2020%2F07%2F15%2FJavaWeb-Cookie-Session%2F</url>
    <content type="text"><![CDATA[会话技术 会话：一次会话中包含多次请求和响应。 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围内的多次请求间，共享数据 方式： 1). 客户端会话技术：Cookie 2). 服务器端会话技术：Session Cookie： 概念：客户端会话技术，将数据保存到客户端 快速入门： 1). 创建Cookie对象，绑定数据 * new Cookie(String name, String value) 2). 发送Cookie对象 * response.addCookie(Cookie cookie) 3). 获取Cookie，拿到数据 * Cookie[] request.getCookies() 实现原理: 基于响应头set-cookie和请求头cookie实现 cookie的细节 1). 一次可不可以发送多个cookie? * 可以 * 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 2). cookie在浏览器中保存多长时间？ 1. 默认情况下，当浏览器关闭后，Cookie数据被销毁 2. 持久化存储： * setMaxAge(int seconds) 1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 2. 负数：默认值 3. 零：删除cookie信息 3). cookie能不能存中文？ * 在tomcat 8 之前 cookie中不能直接存储中文数据。 * 需要将中文数据转码---一般采用URL编码(%E3) * 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 4). cookie共享问题？ 1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ * 默认情况下cookie不能共享 * setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录 * 如果要共享，则可以将path设置为&quot;/&quot; 2. 不同的tomcat服务器间cookie共享问题？ * setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 * setDomain(&quot;.baidu.com&quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享 Cookie的特点和作用 1). cookie存储数据在客户端浏览器 2). 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) * 作用： 1). cookie一般用于存出少量的不太敏感的数据 2). 在不登录的情况下，完成服务器对客户端的身份识别 案例：记住上一次访问时间 1. 需求： 1. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。 2. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串 2. 分析： 1. 可以采用Cookie来完成 2. 在服务器中的Servlet判断是否有一个名为lastTime的cookie 1. 有：不是第一次访问 1. 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20 2. 写回Cookie：lastTime=2018年6月10日11:50:01 2. 没有：是第一次访问 1. 响应数据：您好，欢迎您首次访问 2. 写回Cookie：lastTime=2018年6月10日11:50:01 3. 代码实现： package cn.itcast.cookie; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.net.URLDecoder; import java.net.URLEncoder; import java.text.SimpleDateFormat; import java.util.Date; @WebServlet(&quot;/cookieTest&quot;) public class CookieTest extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //设置响应的消息体的数据格式以及编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //1.获取所有Cookie Cookie[] cookies = request.getCookies(); boolean flag = false;//没有cookie为lastTime //2.遍历cookie数组 if(cookies != null &amp;&amp; cookies.length &gt; 0){ for (Cookie cookie : cookies) { //3.获取cookie的名称 String name = cookie.getName(); //4.判断名称是否是：lastTime if(&quot;lastTime&quot;.equals(name)){ //有该Cookie，不是第一次访问 flag = true;//有lastTime的cookie //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String str_date = sdf.format(date); System.out.println(&quot;编码前：&quot;+str_date); //URL编码 str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;); System.out.println(&quot;编码后：&quot;+str_date); cookie.setValue(str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); //响应数据 //获取Cookie的value，时间 String value = cookie.getValue(); System.out.println(&quot;解码前：&quot;+value); //URL解码： value = URLDecoder.decode(value,&quot;utf-8&quot;); System.out.println(&quot;解码后：&quot;+value); response.getWriter().write(&quot;&lt;h1&gt;欢迎回来，您上次访问时间为:&quot;+value+&quot;&lt;/h1&gt;&quot;); break; } } } if(cookies == null || cookies.length == 0 || flag == false){ //没有，第一次访问 //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String str_date = sdf.format(date); System.out.println(&quot;编码前：&quot;+str_date); //URL编码 str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;); System.out.println(&quot;编码后：&quot;+str_date); Cookie cookie = new Cookie(&quot;lastTime&quot;,str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); response.getWriter().write(&quot;&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;&quot;); } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } } JSP：入门学习 概念：Java Server Pages, java服务器端页面 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 用于简化书写！！！ 原理:JSP本质上就是一个Servlet JSP的脚本：JSP定义Java代码的方式 1). &lt;% 代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。 2). &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。 3). &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。 JSP的内置对象： 在jsp页面中不需要获取和创建，可以直接使用的对象 jsp一共有9个内置对象。 今天学习3个： request response out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似 response.getWriter()和out.write()的区别： 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 response.getWriter()数据输出永远在out.write()之前 案例:改造Cookie案例 Session：主菜 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession 快速入门： 1). 获取HttpSession对象： HttpSession session = request.getSession(); 2). 使用HttpSession对象： Object getAttribute(String name) void setAttribute(String name, Object value) void removeAttribute(String name) 原理 Session的实现是依赖于Cookie的。 细节： 1). 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？ * 默认情况下。不是。 * 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 Cookie c = new Cookie(&quot;JSESSIONID&quot;,session.getId()); c.setMaxAge(60*60); response.addCookie(c); 2). 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ * 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 * session的钝化： * 在服务器正常关闭之前，将session对象系列化到硬盘上 * session的活化： * 在服务器启动后，将session文件转化为内存中的session对象即可。 3). session什么时候被销毁？ 1. 服务器关闭 2. session对象调用invalidate() 。 3. session默认失效时间 30分钟 选择性配置修改 &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; session的特点 1). session用于存储一次会话的多次请求的数据，存在服务器端 2). session可以存储任意类型，任意大小的数据 session与Cookie的区别： 1). session存储数据在服务器端，Cookie在客户端 2). session没有数据大小限制，Cookie有 3). session数据安全，Cookie相对于不安全 案例：验证码1. 案例需求： 1. 访问带有验证码的登录页面login.jsp 2. 用户输入用户名，密码以及验证码。 * 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误 * 如果验证码输入有误，跳转登录页面，提示：验证码错误 * 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您 2. 分析：]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java Web-Servlet & HTTP]]></title>
    <url>%2F2020%2F07%2F13%2FJava-Web-Servlet-HTTP%2F</url>
    <content type="text"><![CDATA[web相关概念回顾1. 软件架构 1. C/S：客户端/服务器端 2. B/S：浏览器/服务器端 2. 资源分类 1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析 * 如： html,css,JavaScript 2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器 * 如：servlet/jsp,php,asp.... 3. 网络通信三要素 1. IP：电子设备(计算机)在网络中的唯一标识。 2. 端口：应用程序在计算机中的唯一标识。 0~65536 3. 传输协议：规定了数据传输的规则 1. 基础协议： 1. tcp:安全协议，三次握手。 速度稍慢 2. udp：不安全协议。 速度快 web服务器软件：* 服务器：安装了服务器软件的计算机 * 服务器软件：接收用户的请求，处理请求，做出响应 * web服务器软件：接收用户的请求，处理请求，做出响应。 * 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目 * web容器 * 常见的java相关的web服务器软件： * webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 * webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 * JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 * Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。 * JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 * Tomcat：web服务器软件 1. 下载：http://tomcat.apache.org/ 2. 安装：解压压缩包即可。 * 注意：安装目录建议不要有中文和空格 3. 卸载：删除目录就行了 4. 启动： * bin/startup.bat ,双击运行该文件即可 * 访问：浏览器输入：http://localhost:8080 回车访问自己 http://别人的ip:8080 访问别人 * 可能遇到的问题： 1. 黑窗口一闪而过： * 原因： 没有正确配置JAVA_HOME环境变量 * 解决方案：正确配置JAVA_HOME环境变量 2. 启动报错： 1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程 * netstat -ano 2. 温柔：修改自身的端口号 * conf/server.xml * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8445&quot; /&gt; * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。 * 好处：在访问时，就不用输入端口号 5. 关闭： 1. 正常关闭： * bin/shutdown.bat * ctrl+c 2. 强制关闭： * 点击启动窗口的× 6. 配置: * 部署项目的方式： 1. 直接将项目放到webapps目录下即可。 * /hello：项目的访问路径--&gt;虚拟目录 * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。 * war包会自动解压缩 2. 配置conf/server.xml文件 在&lt;Host&gt;标签体中配置 &lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt; * docBase:项目存放的路径 * path：虚拟目录 3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写 &lt;Context docBase=&quot;D:\hello&quot; /&gt; * 虚拟目录：xml文件的名称 * 静态项目和动态项目： * 目录结构 * java动态项目的目录结构： -- 项目的根目录 -- WEB-INF目录： -- web.xml：web项目的核心配置文件 -- classes目录：放置字节码文件的目录 -- lib目录：放置依赖的jar包 * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。 Servlet： server applet* 概念：运行在服务器端的Java小程序 * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。 * 将来我们自定义一个类，实现Servlet接口，复写方法。 * 快速入门： 1. 创建JavaEE项目 2. 定义一个类，实现Servlet接口 * public class ServletDemo1 implements Servlet 3. 实现接口中的抽象方法 4. 配置Servlet 在web.xml中配置： &lt;!--配置Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; * 执行原理： 1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径； 2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容； 3. 如果有，则在找到对应的&lt;servlet-class&gt;全类名； 4. tomcat会将字节码文件加载进内存，并且创建其对象； 5. 调用其方法。 public class tomcat_demo1 implements Servlet{ /** * 在Servlet被创建时执行，只会执行一次。 * @param servletConfig * @throws ServletException */ @Override public void init(ServletConfig servletConfig) throws ServletException { } /** * 获取ServletConfig对象 * ServletConfig: Servlet的配置对象 * @return */ @Override public ServletConfig getServletConfig() { return null; } /** * 提供服务方法 * 每一次Servlet被访问时执行，执行多次。 * @param servletRequest * @param servletResponse * @throws ServletException * @throws IOException */ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(&quot;Hello, Tomcat!&quot;); } @Override public String getServletInfo() { return null; } /** * 销毁方法 * 在服务器正常关闭时执行，执行一次 */ @Override public void destroy() { } } * Servlet中的生命周期方法： 1. 被创建：执行init方法，只执行一次 * Servlet什么时候被创建？ * 默认情况下，第一次被访问时，Servlet被创建 * 可以配置执行Servlet的创建时机。 * 在&lt;servlet&gt;标签下配置 1. 第一次被访问时，创建 * &lt;load-on-startup&gt;的值为负数 2. 在服务器启动时，创建 * &lt;load-on-startup&gt;的值为0或正整数 * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的 * 多个用户同时访问时，可能存在线程安全问题。 * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值 2. 提供服务：执行service方法，执行多次 * 每次访问Servlet时，Service方法都会被调用一次。 3. 被销毁：执行destroy方法，只执行一次 * Servlet被销毁时执行。服务器关闭时，Servlet被销毁 * 只有服务器正常关闭时，才会执行destroy方法。 * destroy方法在Servlet被销毁之前执行，一般用于释放资源 * Servlet3.0： * 好处： * 支持注解配置。可以不需要web.xml了。 * 步骤： 1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml 2. 定义一个类，实现Servlet接口 3. 复写方法 4. 在类上使用@WebServlet注解，进行配置 * @WebServlet(&quot;资源路径&quot;) @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface WebServlet { String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt; String[] value() default {};//代表urlPatterns()属性配置 String[] urlPatterns() default {};//相当于&lt;url-pattern&gt; int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt; WebInitParam[] initParams() default {}; boolean asyncSupported() default false; String smallIcon() default &quot;&quot;; String largeIcon() default &quot;&quot;; String description() default &quot;&quot;; String displayName() default &quot;&quot;; } IDEA与tomcat的相关配置1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件 * 查看控制台的log：Using CATALINA_BASE: &quot;C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast&quot; 2. 工作空间项目和tomcat部署的web项目 * tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot; 的web目录下的所有资源 * WEB-INF目录下的资源不能被浏览器直接访问。 3. 断点调试：使用&quot;小虫子&quot;启动 dubug 启动 Servlet：1. 概念 2. 步骤 3. 执行原理 4. 生命周期 5. Servlet3.0 注解配置 6. Servlet的体系结构 Servlet -- 接口 | GenericServlet -- 抽象类 | HttpServlet -- 抽象类 * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象 * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可 * HttpServlet：对http协议的一种封装，简化操作 1. 定义类继承HttpServlet 2. 复写doGet/doPost方法 7. Servlet相关配置 1. urlpartten:Servlet访问路径 1. 一个Servlet可以定义多个访问路径 ： @WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;}) 2. 路径定义规则： 1. /xxx：路径匹配 2. /xxx/xxx:多层路径，目录结构 3. *.do：扩展名匹配 HTTP：* 概念：Hyper Text Transfer Protocol 超文本传输协议 * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式 * 特点： 1. 基于TCP/IP的高级协议 2. 默认端口号:80 3. 基于请求/响应模型的:一次请求对应一次响应 4. 无状态的：每次请求之间相互独立，不能交互数据 * 历史版本： * 1.0：每一次请求响应都会建立新的连接 * 1.1：复用连接 * 1. 请求消息数据格式 1. 请求行 请求方式 请求url 请求协议/版本 GET /login.html HTTP/1.1 * 请求方式： * HTTP协议有7中请求方式，常用的有2种 * GET： 1. 请求参数在请求行中，在url后。 2. 请求的url长度有限制的 3. 不太安全 * POST： 1. 请求参数在请求体中 2. 请求的url长度没有限制的 3. 相对安全 2. 请求头：客户端浏览器告诉服务器一些信息 请求头名称: 请求头值 * 常见的请求头： 1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 2. Referer：http://localhost/login.html * 告诉服务器，我(当前请求)从哪里来？ * 作用： 1. 防盗链： 2. 统计工作： 3. 请求空行 空行，就是用于分割POST请求的请求头，和请求体的。 4. 请求体(正文)： * 封装POST请求消息的请求参数的 * 字符串格式： POST /login.html HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 username=zhangsan *2. 响应消息：服务器端发送给客户端的数据 * 数据格式： 1. 响应行 1. 组成：协议/版本 响应状态码 状态码描述 2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态 1. 状态码都是3位数字 2. 分类： 1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2. 2xx：成功。代表：200 3. 3xx：重定向。代表：302(重定向)，304(访问缓存) 4. 4xx：客户端错误 * 代表： * 404（请求路径没有对应的资源） * 405：请求方式没有对应的doXxx方法 5. 5xx：服务器端错误。代表：500(服务器内部出现异常) 2. 响应头： 1. 格式：头名称： 值 2. 常见的响应头： 1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据 * 值： * in-line:默认值,在当前页面内打开 * attachment;filename=xxx：以附件形式打开响应体。文件下载 3. 响应空行 4. 响应体:传输的数据 * 响应字符串格式 HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt; Request：1. request对象和response对象的原理 1. request和response对象是由服务器创建的。我们来使用它们 2. request对象是来获取请求消息，response对象是来设置响应消息 2. request对象继承体系结构： ServletRequest -- 接口 | 继承 HttpServletRequest -- 接口 | 实现 org.apache.catalina.connector.RequestFacade 类(tomcat) 3. request功能： 1. 获取请求消息数据 1. 获取请求行数据 * GET /day14/demo1?name=zhangsan HTTP/1.1 * 方法： 1. 获取请求方式 ：GET * String getMethod() 2. (*)获取虚拟目录：/day14 * String getContextPath() 3. 获取Servlet路径: /demo1 * String getServletPath() 4. 获取get方式请求参数：name=zhangsan * String getQueryString() 5. (*)获取请求URI：/day14/demo1 * String getRequestURI(): /day14/demo1 * StringBuffer getRequestURL(): http://localhost/day14/demo1 * URL:统一资源定位符 ： http://localhost/day14/demo1 * URI：统一资源标识符 : /day14/demo1 6. 获取协议及版本：HTTP/1.1 * String getProtocol() 7. 获取客户机的IP地址： * String getRemoteAddr() 2. 获取请求头数据 * 方法： * (*)String getHeader(String name):通过请求头的名称获取请求头的值 * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称 3. 获取请求体数据: * 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 * 步骤： 1. 获取流对象 * BufferedReader getReader()：获取字符输入流，只能操作字符数据 * ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 * 在文件上传知识点后讲解 2. 再从流对象中拿数据 2. 其他功能： 1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数 1. String getParameter(String name):根据参数名称获取参数值 username=zs&amp;password=123 2. String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game 3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称 4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合 * 中文乱码问题： * get方式：tomcat 8 已经将get方式乱码问题解决了 * post方式：会乱码 * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;); 2. 请求转发：一种在服务器内部的资源跳转方式 1. 步骤： 1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 2. 特点： 1. 浏览器地址栏路径不发生变化 2. 只能转发到当前服务器内部资源中。 3. 转发是一次请求 3. 共享数据： * 域对象：一个有作用范围的对象，可以在范围内共享数据 * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 * 方法： 1. void setAttribute(String name,Object obj):存储数据 2. Object getAttitude(String name):通过键获取值 3. void removeAttribute(String name):通过键移除键值对 4. 获取ServletContext： * ServletContext getServletContext() Response对象* 功能：设置响应消息 1. 设置响应行 1. 格式：HTTP/1.1 200 ok 2. 设置状态码：setStatus(int sc) 2. 设置响应头：setHeader(String name, String value) 3. 设置响应体： * 使用步骤： 1. 获取输出流 * 字符输出流：PrintWriter getWriter() * 字节输出流：ServletOutputStream getOutputStream() 2. 使用输出流，将数据输出到客户端浏览器 * 案例： 1. 完成重定向 * 重定向：资源跳转的方式 * 代码实现： //1. 设置状态码为302 response.setStatus(302); //2.设置响应头location response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;); //简单的重定向方法 response.sendRedirect(&quot;/day15/responseDemo2&quot;); * 重定向的特点:redirect 1. 地址栏发生变化 2. 重定向可以访问其他站点(服务器)的资源 3. 重定向是两次请求。不能使用request对象来共享数据 * 转发的特点：forward 1. 转发地址栏路径不变 2. 转发只能访问当前服务器下的资源 3. 转发是一次请求，可以使用request对象来共享数据 * forward 和 redirect 区别 * 路径写法： 1. 路径分类 1. 相对路径：通过相对路径不可以确定唯一资源 * 如：./index.html * 不以/开头，以.开头路径 * 规则：找到当前资源和目标资源之间的相对位置关系 * ./：当前目录 * ../:后退一级目录 2. 绝对路径：通过绝对路径可以确定唯一资源 * 如：http://localhost/day15/responseDemo2 /day15/responseDemo2 * 以/开头的路径 * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出 * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) * 建议虚拟目录动态获取：request.getContextPath() * &lt;a&gt; , &lt;form&gt; 重定向... * 给服务器使用：不需要加虚拟目录 * 转发路径 2. 服务器输出字符数据到浏览器 * 步骤： 1. 获取字符输出流 2. 输出数据 * 注意： * 乱码问题： 1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 2. 设置该流的默认编码 3. 告诉浏览器响应体使用的编码 //简单的形式，设置编码，是在获取流之前设置 response.setContentType(&quot;text/html;charset=utf-8&quot;); 3. 服务器输出字节数据到浏览器 * 步骤： 1. 获取字节输出流 2. 输出数据 4. 验证码 1. 本质：图片 2. 目的：防止恶意表单注册 ServletContext对象：1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信 2. 获取： 1. 通过request对象获取 request.getServletContext(); 2. 通过HttpServlet获取 this.getServletContext(); 3. 功能： 1. 获取MIME类型： * MIME类型:在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型/小类型 text/html image/jpeg * 获取：String getMimeType(String file) 2. 域对象：共享数据 1. setAttribute(String name,Object value) 2. getAttribute(String name) 3. removeAttribute(String name) * ServletContext对象范围：所有用户所有请求的数据 3. 获取文件的真实(服务器)路径 1. 方法：String getRealPath(String path) String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问 System.out.println(b); String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问 System.out.println(c); String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问 System.out.println(a); 案例：* 文件下载需求： 1. 页面显示超链接 2. 点击超链接后弹出下载提示框 3. 完成图片文件下载 * 分析： 1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求 2. 任何资源都必须弹出下载提示框 3. 使用响应头设置资源的打开方式： * content-disposition:attachment;filename=xxx * 步骤： 1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename 2. 定义Servlet 1. 获取文件名称 2. 使用字节输入流加载文件进内存 3. 指定response的响应头： content-disposition:attachment;filename=xxx 4. 将数据写出到response输出流 * 问题： * 中文文件问题 * 解决思路： 1. 获取客户端使用的浏览器版本信息 2. 根据不同的版本信息，设置filename的编码方式不同 案例：用户登录* 用户登录案例需求： 1.编写login.html登录页面 username &amp; password 两个输入框 2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表 3.使用JdbcTemplate技术封装JDBC 4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您 5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误 * 分析 * 开发步骤 1. 创建项目，导入html页面，配置文件，jar包 2. 创建数据库环境 CREATE DATABASE day14; USE day14; CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) UNIQUE NOT NULL, PASSWORD VARCHAR(32) NOT NULL ); 3. 创建包cn.itcast.domain,创建类User package cn.itcast.domain; /** * 用户的实体类 */ public class User { private int id; private String username; private String password; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, username=&apos;&quot; + username + &apos;\&apos;&apos; + &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; + &apos;}&apos;; } } 4. 创建包cn.itcast.util,编写工具类JDBCUtils package cn.itcast.util; import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.DataSource; import javax.xml.crypto.Data; import java.io.IOException; import java.io.InputStream; import java.sql.Connection; import java.sql.SQLException; import java.util.Properties; /** * JDBC工具类 使用Durid连接池 */ public class JDBCUtils { private static DataSource ds ; static { try { //1.加载配置文件 Properties pro = new Properties(); //使用ClassLoader加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //2.初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接池对象 */ public static DataSource getDataSource(){ return ds; } /** * 获取连接Connection对象 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } } 5. 创建包cn.itcast.dao,创建类UserDao,提供login方法 package cn.itcast.dao; import cn.itcast.domain.User; import cn.itcast.util.JDBCUtils; import org.springframework.dao.DataAccessException; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; /** * 操作数据库中User表的类 */ public class UserDao { //声明JDBCTemplate对象共用 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 登录方法 * @param loginUser 只有用户名和密码 * @return user包含用户全部数据,没有查询到，返回null */ public User login(User loginUser){ try { //1.编写sql String sql = &quot;select * from user where username = ? and password = ?&quot;; //2.调用query方法 User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getUsername(), loginUser.getPassword()); return user; } catch (DataAccessException e) { e.printStackTrace();//记录日志 return null; } } } 6. 编写cn.itcast.web.servlet.LoginServlet类 package cn.itcast.web.servlet; import cn.itcast.dao.UserDao; import cn.itcast.domain.User; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/loginServlet&quot;) public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.设置编码 req.setCharacterEncoding(&quot;utf-8&quot;); //2.获取请求参数 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password); //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //5.判断user if(user == null){ //登录失败 req.getRequestDispatcher(&quot;/failServlet&quot;).forward(req,resp); }else{ //登录成功 //存储数据 req.setAttribute(&quot;user&quot;,user); //转发 req.getRequestDispatcher(&quot;/successServlet&quot;).forward(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } 7. 编写FailServlet和SuccessServlet类 @WebServlet(&quot;/successServlet&quot;) public class SuccessServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取request域中共享的user对象 User user = (User) request.getAttribute(&quot;user&quot;); if(user != null){ //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录成功！&quot;+user.getUsername()+&quot;,欢迎您&quot;); } } @WebServlet(&quot;/failServlet&quot;) public class FailServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录失败，用户名或密码错误&quot;); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 8. login.html中form表单的action路径的写法 * 虚拟目录+Servlet的资源路径 9. BeanUtils工具类，简化数据封装 * 用于封装JavaBean的 1. JavaBean：标准的Java类 1. 要求： 1. 类必须被public修饰 2. 必须提供空参的构造器 3. 成员变量必须使用private修饰 4. 提供公共setter和getter方法 2. 功能：封装数据 2. 概念： 成员变量： 属性：setter和getter方法截取后的产物 例如：getUsername() --&gt; Username--&gt; username 3. 方法： 1. setProperty() 2. getProperty() 3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb-Http与Servlet概述]]></title>
    <url>%2F2020%2F07%2F13%2FHttp%E4%B8%8EServlet%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Servlet Servlet的概述 Servlet的定义及其作用：Servlet是运行在Web服务器(eg.Tomcat)上的java程序，通过HTTP协议接收好响应来自Web客户端的请求。 Servlet的实现 Servlet接口定义了初始化servlet的方法、为请求提供服务的方法和从服务器移除servlet的方法,这些方法成为生命周期方法 Servlet实现方法：定义一个类implements Servlet 或者 Extends GenericServlet/HttpServlet(最常用) Servlet中的生命周期方法是按以下顺序调用的： 构造Servlet，使用init方法初始化 创建Servlet实例的时候回执行init方法 一个Servlet只会初始化一次，init方法只会被执行一次 处理客户端的请求对service方法的调用 当客户端有请求的时候回调用service方法 一次请求对应着service的执行，所以它可以被多次执行 从服务器中一处Servlet，并用destroy销毁它，最后垃圾回收终止它 Servlet销毁时会执行： 当Servlet从服务器移除时执行； 当关闭服务器时执行 下面是实现了Servlet的代码： 12345678public class Sever_servlet extends HttpServlet&#123; @Override public void init(ServletConfig arg0) throws ServletException &#123;&#125; @Override public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException &#123;&#125; @Override public void destroy() &#123;&#125;&#125; Servlet的配置 在一个Web工程中当我们实现了一个Servlet的时候，我们应该在Web工程中将这的Servlet加入到配置文件Web。xml文件中，配置Servlet。 下面是在web.xml天剑一个Servlet的写法 获取Servlet配置信息 //1. 得到servlet配置对象 专门用于在配置servlet的信息 ServletConfig config = getServletConfig(); //获取到的是配置servlet里面servlet-name 的文本内容 String servletName = config.getServletName(); System.out.println(&quot;servletName=&quot;+servletName); //2. 可以获取具体的某一个参数。 String address = config.getInitParameter(&quot;address&quot;); System.out.println(&quot;address=&quot;+address); //3. 获取所有的参数名称 Enumeration&lt;String&gt; names = config.getInitParameterNames(); //遍历取出所有的参数名称 while (names.hasMoreElements()) { String key = (String) names.nextElement(); String value = config.getInitParameter(key); System.out.println(&quot;key===&quot;+key + &quot; value=&quot;+value); } ServletContext 每个web工程都只有一个ServletContext对象。 在同一个Web工程中不管是哪个servlet，获取到的这个类的对象都是同一个 ServletContext主要有三个作用： 获取Web工程的全局配置参数 获得Web工程中的资源（properities） 存取数据，Servlet间共享数据，即域对象 获取全局配置参数在web.xml文件中有定义全局参数，每个Servlet都可以访问，而Servlet内部的参数只可以由自己访 icon 通过调用getServletContext()方法可以获得Web工程的ServletContext对象，通过这个对象来访问全局参数 icon 获取Web工程中的资源Web工程里的properities文件资源 //获取Web工程的ServletContext对象 ServletContext context=getServletContext(); //获得对去加载读取资源的对象property Properities property=new Properities(); //获取输入流，就是资源 InputStream in=null; //加载资源并读取 property.load(in); String city=property.getProperty(); 这里的关键是如何读入资源，获得资源的输入流InputStream，有三种方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//获得Servlet对象ServletContext context=getServletContext();Properties properity=new Properties();//方法一：通过ServletContext的getRealpath()方法获得资源输入流，只需要传入资源的相对路径/* * getRealPath("")这个得到的是运行在服务器TomCat中Web项目的根路径 * D:\tomcat\apache-tomcat-7.0.52\apache-tomcat-7.0.52\wtpwebapps\Web\ * getRealPath("file/file.properties")这个会将传入的相对路径拼接到上面的项目根路径的后面 * D:\tomcat\apache-tomcat-7.0.52\apache-tomcat-7.0.52\wtpwebapps\Web\file/file.properties* */String path= context.getRealPath("file/file.properties");InputStream in=new FileInputStream(path);//方式二：通过context.getResourceAsStream("file/file.properties")直接过得资源的输入流InputStream in=context.getResourceAsStream("file/file.properties");//方式三：通过类加载器直接获得资源的输入流InputStream in=this.getClass().getClassLoader().getResourceAsStream("../../file/file.properities");properity.load(in);String city=properity.getProperty("city");System.out.println("city:"+city); ``` ## HttpServletRequest ### 获取客户端的信息&gt;HttpServletRequest中封装了客户端所有的信息 &gt;通过request可以获得客户端请求头的全部信息和客户端传递的参数```javapublic class Request extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //取出客户端请求里面的所有头信息(名称-值) Enumeration&lt;String&gt;headers=request.getHeaderNames(); while(headers.hasMoreElements()) &#123; String name=headers.nextElement(); String value=request.getHeader(name); System.out.println(name+":"+value); &#125; //获得客户端上传的参数 //1.利用枚举方法获得参数 Enumeration&lt;String&gt;parameter=request.getParameterNames(); while(parameter.hasMoreElements()) &#123; String name=parameter.nextElement(); String value=request.getParameter(name); System.out.println(name+":"+value); &#125; //2.利用Map来获取参数 Map&lt;String,String[]&gt;parameter=request.getParameterMap(); Set&lt;String&gt; paras=parameter.keySet(); Iterator&lt;String&gt; it=paras.iterator(); while(it.hasNext()) &#123; String name=it.next(); String value=parameter.get(name)[0]; System.out.println(name+":"+value); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;&#125;&#125; 中文乱码 当客户端提交的数据中有中文的时候会出现乱码的现象，Get和POST方式的解决方法不同 Get请求方式 由于Get请求方式上传提交的数据是在Url地址中的，所以服务器接收的时候已经过编码了，服务器端直接获得的数据是乱码的 //tomcat收到了这批数据，getParameter 默认使用ISO-8859-1去解码 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); //先让文字回到ISO-8859-1对应的字节数组 ， 然后再按utf-8组拼字符串 username = new String(username.getBytes(&quot;ISO-8859-1&quot;) , &quot;UTF-8&quot;); System.out.println(&quot;userName=&quot;+username+&quot;==password=&quot;+password); 直接在tomcat里面做配置，以后get请求过来的数据永远都是用UTF-8编码。 可以在tomcat里面做设置处理 conf/server.xml 加上URIEncoding=&quot;utf-8&quot; &lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt; Post请求 在getParameter之前加入这行代码，是在设置请求体的编码方式 request.setCharacterEncoding(&quot;UTF-8&quot;); HttpServletResponse 它的作用是响应返回数据给客户端输出数据到页面上 //以字符流的方式写数据 response.getWriter().write(&quot;&lt;h1&gt;hello response...&lt;/h1&gt;&quot;); //以字节流的方式写数据 response.getOutputStream().write(&quot;hello&quot;.getBytes()); 中文乱码 以字符流输出 response.getWriter() //1. 指定输出到客户端的时候，这些文字使用UTF-8编码 response.setCharacterEncoding(&quot;UTF-8&quot;); //2. 直接规定浏览器看这份数据的时候，使用什么编码来看。 response.setHeader(&quot;Content-Type&quot;, &quot;text/html; charset=UTF-8&quot;); response.getWriter().write(&quot;北京&quot;); 以字节流输出 response.getOutputStream() //1. 指定浏览器看这份数据使用的码表 response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;); //2. 指定输出的中文用的码表 response.getOutputStream().write(&quot;我爱北京&quot;.getBytes(&quot;UTF-8&quot;)); 不管是字节流还是字符流，直接使用一行代码，然后再写数据 response.setContentType(&quot;text/html;charset=UTF-8&quot;); id: 96 论文名称：Attention-based Dynamic Preference Model for Next Point-of-Interest Recommendation 作者：Chenwang Zheng and Dan Tao]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-链表]]></title>
    <url>%2F2020%2F06%2F19%2F%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[两个链表的第一个公共结点问题描述 输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） 解题思路 试想一种理想情况：链表A头结点到结点8的长度与链表B头结点到结点8的长度相等，那么就可以用双指针。 -1. 初始化：指针ta指向链表A头结点，指针tb指向链表B头结点 -2. 如果ta == tb， 说明找到了第一个公共的头结点，直接返回即可。 -3. 否则，ta != tb，则++ta，++tb 显然图一中第一个公共结点为8，但是链表A头结点到8的长度为2，链表B头结点到8的长度为3，显然并不相等。 所以需要制造这种理想情况。 假设链表A长度为a， 链表B的长度为b，此时a != b但是，a+b == b+a因此，可以让a+b作为链表A的新长度，b+a作为链表B的新长度。 代码实现1234567891011121314151617181920212223 /*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; if(pHead1==null || pHead2==null)&#123; return null; &#125; ListNode p1 = pHead1; ListNode p2 = pHead2; while(p1 != p2)&#123; p1 = p1 == null ? pHead2 : p1.next; p2 = p2 == null ? pHead1 : p2.next; &#125; return p1; &#125;&#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb-JDBC]]></title>
    <url>%2F2020%2F06%2F18%2FJavaWeb-JDBC%2F</url>
    <content type="text"><![CDATA[JDBC 概念：Java DataBase Connectivity, Java 数据库连接, Java语言操作数据库. JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 快速入门： 步骤： 1). 导入驱动jar包, mysql-connector-java-5.1.37-bin.jar * 复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 * 右键--&gt;Add As Library 2). 注册驱动 3). 获取数据库连接对象 Connection 4). 定义sql 5). 获取执行sql语句的对象 Statement 6). 执行sql，接受返回结果 7). 处理结果 8). 释放资源 代码实现： //1. 导入驱动jar包 //2.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;); //4.定义sql语句 String sql = &quot;update account set balance = 500 where id = 1&quot;; //5.获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //6.执行sql int count = stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 stmt.close(); conn.close(); 详解各个对象： 1). DriverManager：驱动管理对象 * 功能： 1. 注册驱动：告诉程序该使用哪一个数据库驱动jar * static void registerDriver(Driver driver): 注册与给定的驱动程序 DriverManager 。 * 写代码使用： Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 static { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(&quot;Can&apos;t register driver!&quot;); } } 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。 2. 获取数据库连接： * 方法：static Connection getConnection(String url, String user, String password) * 参数： * url：指定连接的路径 * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 * 例子：jdbc:mysql://localhost:3306/db3 * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 * user：用户名 * password：密码 2). Connection：数据库连接对象 1. 功能： 1. 获取执行sql 的对象 * Statement createStatement() * PreparedStatement prepareStatement(String sql) 2. 管理事务： * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 * 提交事务：commit() * 回滚事务：rollback() 3). Statement：执行sql的对象 1. 执行sql 1. boolean execute(String sql) ：可以执行任意的sql 了解 2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。 3. ResultSet executeQuery(String sql) ：执行DQL（select)语句 2. 练习： 1. account表 添加一条记录 2. account表 修改记录 3. account表 删除一条记录 代码： Statement stmt = null; Connection conn = null; try { //1. 注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2. 定义sql String sql = &quot;insert into account values(null,&apos;王五&apos;,3000)&quot;; //3.获取Connection对象 conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;); //4.获取执行sql的对象 Statement stmt = conn.createStatement(); //5.执行sql int count = stmt.executeUpdate(sql);//影响的行数 //6.处理结果 System.out.println(count); if(count &gt; 0){ System.out.println(&quot;添加成功！&quot;); }else{ System.out.println(&quot;添加失败！&quot;); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); }finally { //stmt.close(); //7. 释放资源 //避免空指针异常 if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } 4). ResultSet：结果集对象,封装查询结果 * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true * getXxx(参数):获取数据 * Xxx：代表数据类型 如： int getInt() , String getString() * 参数： 1. int：代表列的编号,从1开始 如： getString(1) 2. String：代表列名称。 如： getDouble(&quot;balance&quot;) * 注意： * 使用步骤： 1. 游标向下移动一行 2. 判断是否有数据 3. 获取数据 //循环判断游标是否是最后一行末尾。 while(rs.next()){ //获取数据 //6.2 获取数据 int id = rs.getInt(1); String name = rs.getString(&quot;name&quot;); double balance = rs.getDouble(3); System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance); } * 练习： * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。 1. 定义Emp类 2. 定义方法 public List&lt;Emp&gt; findAll(){} 3. 实现方法 select * from emp; 5). PreparedStatement：执行sql的对象 1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 1. 输入用户随便，输入密码：a&apos; or &apos;a&apos; = &apos;a 2. sql：select * from user where username = &apos;fhdsjkf&apos; and password = &apos;a&apos; or &apos;a&apos; = &apos;a&apos; 2. 解决sql注入问题：使用PreparedStatement对象来解决 3. 预编译的SQL：参数使用?作为占位符 4. 步骤： 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 5. 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 6. 给？赋值： * 方法： setXxx(参数1,参数2) * 参数1：？的位置编号 从1 开始 * 参数2：？的值 7. 执行sql，接受返回结果，不需要传递sql语句 8. 处理结果 9. 释放资源 5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作 1. 可以防止SQL注入 2. 效率更高 抽取JDBC工具类： JDBCUtils *目的：简化书写 * 分析： 1. 注册驱动也抽取 2. 抽取一个方法获取连接对象 * 需求：不想传递参数（麻烦），还得保证工具类的通用性。 * 解决：配置文件 jdbc.properties url= user= password= 3. 抽取一个方法释放资源 * 代码实现： public class JDBCUtils { private static String url; private static String user; private static String password; private static String driver; /** * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块 */ static{ //读取资源文件，获取值。 try { //1. 创建Properties集合类。 Properties pro = new Properties(); //获取src路径下的文件的方式---&gt;ClassLoader 类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource(&quot;jdbc.properties&quot;); String path = res.getPath(); System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties //2. 加载文件 // pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;)); pro.load(new FileReader(path)); //3. 获取数据，赋值 url = pro.getProperty(&quot;url&quot;); user = pro.getProperty(&quot;user&quot;); password = pro.getProperty(&quot;password&quot;); driver = pro.getProperty(&quot;driver&quot;); //4. 注册驱动 Class.forName(driver); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } /** * 获取连接 * @return 连接对象 */ public static Connection getConnection() throws SQLException { return DriverManager.getConnection(url, user, password); } /** * 释放资源 * @param stmt * @param conn */ public static void close(Statement stmt,Connection conn){ if( stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if( conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } /** * 释放资源 * @param stmt * @param conn */ public static void close(ResultSet rs,Statement stmt, Connection conn){ if( rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if( stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if( conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } 练习 * 需求： 1. 通过键盘录入用户名和密码 2. 判断用户是否登录成功 * select * from user where username = &quot;&quot; and password = &quot;&quot;; * 如果这个sql有查询结果，则成功，反之，则失败 * 步骤： 1. 创建数据库表 user CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32), PASSWORD VARCHAR(32) ); INSERT INTO USER VALUES(NULL,&apos;zhangsan&apos;,&apos;123&apos;); INSERT INTO USER VALUES(NULL,&apos;lisi&apos;,&apos;234&apos;); 2. 代码实现： public class login_demo { public static void main(String[] args) { // 1. 键盘录入，接受用户名和密码 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入姓名：&quot;); String username = sc.nextLine(); System.out.println(&quot;请输入密码：&quot;); String password = sc.nextLine(); // 2. 调用方法 boolean flag = login(username, password); // 3. 判断结果 if(flag){ System.out.println(&quot;登陆成功！&quot;); }else{ System.out.println(&quot;登录失败！&quot;); } } public static boolean login(String username, String password){ if(username==null || password==null){ return false; } Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; try { // 1. 获取数据库连接 conn = JDBCutils.getConnection(); // 2. 定义sql语句 String sql = &quot;select * from user where username = ? and password = ?&quot;; // 3. 获取执行sql的对象 pstmt = conn.prepareStatement(sql); // 给 ? 赋值 pstmt.setString(1, username); pstmt.setString(2, password); // 4. 执行sql rs = pstmt.executeQuery(); return rs.next(); } catch (SQLException e) { e.printStackTrace(); } finally { JDBCutils.close(rs,pstmt,conn); } return false; } } JDBC控制事务： 1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 2. 操作： 1. 开启事务 2. 提交事务 3. 回滚事务 3. 使用Connection对象来管理事务 * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 * 在执行sql之前开启事务 * 提交事务：commit() * 当所有sql都执行完提交事务 * 回滚事务：rollback() * 在catch中回滚事务 4. 代码： public class JDBCDemo10 { public static void main(String[] args) { Connection conn = null; PreparedStatement pstmt1 = null; PreparedStatement pstmt2 = null; try { //1.获取连接 conn = JDBCUtils.getConnection(); //开启事务 conn.setAutoCommit(false); //2.定义sql //2.1 张三 - 500 String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;; //2.2 李四 + 500 String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;; //3.获取执行sql对象 pstmt1 = conn.prepareStatement(sql1); pstmt2 = conn.prepareStatement(sql2); //4. 设置参数 pstmt1.setDouble(1,500); pstmt1.setInt(2,1); pstmt2.setDouble(1,500); pstmt2.setInt(2,2); //5.执行sql pstmt1.executeUpdate(); // 手动制造异常 int i = 3/0; pstmt2.executeUpdate(); //提交事务 conn.commit(); } catch (Exception e) { //事务回滚 try { if(conn != null) { conn.rollback(); } } catch (SQLException e1) { e1.printStackTrace(); } e.printStackTrace(); }finally { JDBCUtils.close(pstmt1,conn); JDBCUtils.close(pstmt2,null); } } } 数据库连接池1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 2. 好处： 1. 节约资源 2. 用户访问高效 3. 实现： 1. 标准接口：DataSource javax.sql包下的 1. 方法： * 获取连接：getConnection() * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 2. 一般我们不去实现它，有数据库厂商来实现 1. C3P0：数据库连接池技术 2. Druid：数据库连接池实现技术，由阿里巴巴提供的 4. C3P0：数据库连接池技术 * 步骤： 1. 导入jar包 (两个) c3p0-0.9.5.2.jar 和 mchange-commons-java-0.2.12.jar ， * 不要忘记导入数据库驱动jar包 2. 定义配置文件： * 名称： c3p0.properties 或者 c3p0-config.xml * 路径：直接将文件放在src目录下即可。 3. 创建核心对象 数据库连接池对象 ComboPooledDataSource 4. 获取连接： getConnection * 代码： //1.创建数据库连接池对象 DataSource ds = new ComboPooledDataSource(); //2. 获取连接对象 Connection conn = ds.getConnection(); 5. Druid：数据库连接池实现技术，由阿里巴巴提供的 1. 步骤： 1. 导入jar包 druid-1.0.9.jar 2. 定义配置文件： * 是properties形式的 * 可以叫任意名称，可以放在任意目录下 3. 加载配置文件。Properties 4. 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory 5. 获取连接：getConnection * 代码： //3.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //4.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //5.获取连接 Connection conn = ds.getConnection(); 2. 定义工具类 1. 定义一个类 JDBCUtils 2. 提供静态代码块加载配置文件，初始化连接池对象 3. 提供方法 1. 获取连接方法：通过数据库连接池获取连接 2. 释放资源 3. 获取连接池的方法 * 代码： public class JDBCUtils { //1.定义成员变量 DataSource private static DataSource ds ; static{ try { //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;)); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } /** * 释放资源 */ public static void close(Statement stmt,Connection conn){ /* if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close();//归还连接 } catch (SQLException e) { e.printStackTrace(); } }*/ close(null,stmt,conn); } public static void close(ResultSet rs , Statement stmt, Connection conn){ if(rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close();//归还连接 } catch (SQLException e) { e.printStackTrace(); } } } /** * 获取连接池方法 */ public static DataSource getDataSource(){ return ds; } } Spring JDBC : JDBC Template* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 * 步骤： 1. 导入jar包 2. 创建JdbcTemplate对象。依赖于数据源DataSource * JdbcTemplate template = new JdbcTemplate(ds); 3. 调用JdbcTemplate的方法来完成CRUD的操作 * update():执行DML语句。增、删、改语句 * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 * 注意：这个方法查询的结果集长度只能是1 * queryForList():查询结果将结果集封装为list集合 * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 * query():查询结果，将结果封装为JavaBean对象 * query的参数：RowMapper * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 * new BeanPropertyRowMapper&lt;类型&gt;(类型.class) * queryForObject：查询结果，将结果封装为对象 * 一般用于聚合函数的查询 4. 练习： * 需求： 1. 修改1号数据的 salary 为 10000 2. 添加一条记录 3. 删除刚才添加的记录 4. 查询id为1的记录，将其封装为Map集合 5. 查询所有记录，将其封装为List 6. 查询所有记录，将其封装为Emp对象的List集合 7. 查询总记录数 * 代码： import cn.itcast.domain.Emp; import cn.itcast.utils.JDBCUtils; import org.junit.Test; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.RowMapper; import java.sql.Date; import java.sql.ResultSet; import java.sql.SQLException; import java.util.List; import java.util.Map; public class JdbcTemplateDemo2 { //Junit单元测试，可以让方法独立执行 //1. 获取JDBCTemplate对象 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 1. 修改1号数据的 salary 为 10000 */ @Test public void test1(){ //2. 定义sql String sql = &quot;update emp set salary = 10000 where id = 1001&quot;; //3. 执行sql int count = template.update(sql); System.out.println(count); } /** * 2. 添加一条记录 */ @Test public void test2(){ String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;; int count = template.update(sql, 1015, &quot;郭靖&quot;, 10); System.out.println(count); } /** * 3.删除刚才添加的记录 */ @Test public void test3(){ String sql = &quot;delete from emp where id = ?&quot;; int count = template.update(sql, 1015); System.out.println(count); } /** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */ @Test public void test4(){ String sql = &quot;select * from emp where id = ? or id = ?&quot;; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20} } /** * 5. 查询所有记录，将其封装为List */ @Test public void test5(){ String sql = &quot;select * from emp&quot;; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) { System.out.println(stringObjectMap); } } /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6(){ String sql = &quot;select * from emp&quot;; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() { @Override public Emp mapRow(ResultSet rs, int i) throws SQLException { Emp emp = new Emp(); int id = rs.getInt(&quot;id&quot;); String ename = rs.getString(&quot;ename&quot;); int job_id = rs.getInt(&quot;job_id&quot;); int mgr = rs.getInt(&quot;mgr&quot;); Date joindate = rs.getDate(&quot;joindate&quot;); double salary = rs.getDouble(&quot;salary&quot;); double bonus = rs.getDouble(&quot;bonus&quot;); int dept_id = rs.getInt(&quot;dept_id&quot;); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; } }); for (Emp emp : list) { System.out.println(emp); } } /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6_2(){ String sql = &quot;select * from emp&quot;; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) { System.out.println(emp); } } /** * 7. 查询总记录数 */ @Test public void test7(){ String sql = &quot;select count(id) from emp&quot;; Long total = template.queryForObject(sql, Long.class); System.out.println(total); } }]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库知识]]></title>
    <url>%2F2020%2F06%2F12%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[数据库的基本概念 数据库的英文单词： DataBase 简称 ： DB 什么数据库？ 用于存储和管理数据的仓库。 数据库的特点： 持久化存储数据的。其实数据库就是一个文件系统 方便存储和管理数据 使用了统一的方式操作数据库 — SQL MySQL数据库Mysql的几个操作： - MySQL服务启动 1. 手动。 2. cmd--&gt; services.msc 打开服务的窗口 3. 使用管理员打开cmd * net start mysql: 启动mysql的服务 * net stop mysql: 关闭mysql服务 - MySQL登录 1. mysql -uroot -p密码 : 本地mysql连接 2. mysql -hip -uroot -p连接目标的密码 3. mysql --host=ip --user=root --password=连接目标的密码 - MySQL退出 1. exit 2. quit SQL1.什么是SQL？ Structured Query Language：结构化查询语言 2.SQL的作用 SQL是一种所有关系型数据库的查询规范，不同的数据库都支持。 通用的数据库操作语言，可以用在不同的数据库中。 不同的数据库SQL语句有一些区别 3.SQL通用语法 SQL 语句可以单行或多行书写，以分号结尾。 可使用空格和缩进来增强语句的可读性。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 3 种注释 单行注释: -- 注释内容 或 # 注释内容(mysql特有) 多行注释: /* 注释美容 */ 4. SQL分类 DDL(Data Definition Language) 数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language) 数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language )数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language) 数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 SQL语句-数据库的操作DDL:操作数据库、表 操作数据库（CRUD） 1）C (Create)： 创建 * 创建数据库： * create database 数据库名称； * 创建数据库，判断不存在，再创建： * create database if not exists 数据库名称; * 创建数据库，并指定字符集： * create database 数据库名称 character set 字符集名; 2）R (Retrieve)： 查询 * 查询所有数据库的名称： * show databases； * 查看某个数据库的定义信息： * show create database 数据库名称； 3）U (Update)： 更新 * 修改数据库的字符集： * alter database 数据库名称 character set 字符集名； 4）D (Delect)： 删除 * 删除数据库 * drop database 数据库名称; * 判断数据库存在，存在再删除 * drop database if exists 数据库名称; 5）使用数据库 * 查询当前正在使用的数据库名称 * select database(); * 使用数据库 * use 数据库名称; 操作表 (CRUD) 1) C(Create): 创建 *语法 creat table 表名( 列名1 数据类型1， 列名2 数据类型2， ...... 列名n 数据类型n ) * 注意：最后一列，不需要加逗号（,） * 数据库类型 1. int： 整数类型 * age int, 2. double: 小数类型 * score double(5,2) 3. date: 日期，只包含年月日，yyyy-MM-dd 4. datetime: 日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 5. timestamp: 时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 6. varchar：字符串 * name varchar(20):姓名最大20个字符 * zhangsan 8个字符 张三 2个字符 * 复制一个表： * create table 表名 like 被复制的表名; 2) R(Retrieve): 查询 * 查询某个数据库中所有表的名称 * show tables; * 查询某个表的信息 * show create table 表名; * 查询某个表的结构 * desc 表名； 3）U(Update): 更新 * 修改表名 * alter table 表名 rename to 新的表名; * 修改表的字符集 * alter table 表名 charaster set 字符集名称; * 添加一列 * alter table 表名 add 列名 数据类型; * 修改列命名称,数据类型 * alter table 表名 change 列名 新列名 新数据类型; * alter table 表名 modify 列名 新数据类型; * 删除列 * alter table 表名 drop 列名; 4）D(Delect): 删除 * drop table 表名； * drop table if exists 表名； 数据库的数据类型 DML: 增删改表中数据1. 增添数据 * insert into 表名(列名1, ..., 列名n) values（值1, ..., 值n); * 注意： * 列名和值要一一对应 * 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,...值n); * 除了数字类型，其他类型需要使用引号(单双都可以)引起来 2. 删除数据 * delete from 表名 where条件; eg, delete from db where id=3; * 注意： * 如果不加条件，则删除表中所有记录。 * 如果要删除所有记录 - delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作 - TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 3. 修改数据 * undate 表名 set 列名1=值1,列名2=值2,... where 条件; eg, update db set age=18 where id=3; DQL：查询表中的记录* select * from 表名; 1. 语法 select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 2. 基础查询 * 多个字段的查询 * select 字段1，字段2... from 表名; eg, select name, address from student; * 去除重复 * distinct eg, select distinct address from student; * 计算列 * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） eg, select name, math, english, math+english from student; * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null * 表达式1：哪个字段需要判断是否为null * 表达式如果该字段为null后的替换值。 eg, select name, math, english, math + ifnull(english) from student; * 起别名 * as eg, select name, math, english, math + ifnull(english) as totalscore from student; 3. 条件选择 * where子句后跟条件 * 运算符 * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; * BETWEEN...AND * IN( 集合) * LIKE：模糊查询 * 占位符： * _:单个任意字符 * %：多个任意字符 * IS NULL * and 或 &amp;&amp; * or 或 || * not 或 ! eg， -- 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20; SELECT * FROM student WHERE age &gt;= 20; -- 查询年龄等于20岁 SELECT * FROM student WHERE age = 20; -- 查询年龄不等于20岁 SELECT * FROM student WHERE age != 20; SELECT * FROM student WHERE age &lt;&gt; 20; -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30; SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; -- 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25 SELECT * FROM student WHERE age IN (22,18,25); -- 查询英语成绩为null SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断 SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; * 模糊查询 like * 占位符： * _:单个任意字符 * %：多个任意字符 -- 查询姓马的有哪些？ like SELECT * FROM student WHERE NAME LIKE &apos;马%&apos;; -- 查询姓名第二个字是化的人 SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;; -- 查询姓名是3个字的人 SELECT * FROM student WHERE NAME LIKE &apos;___&apos;; -- 查询姓名中包含德的人 SELECT * FROM student WHERE NAME LIKE &apos;%德%&apos;; 4. 排序查询 * 语法： order by 子句; * order by 排序字段1 排序方式1，排序字段2 排序方式2....; * 排序方式 * ASC：升序（默认） * DESC：降序 * 注意： * 如果有多个排序条件，当前面的条件值一样时，才会判断第二条件 eg， -- 如果数学成绩一样，则按照英语成绩排名 select * from student order by math ASC, english ASC; 5. 聚合函数：将一列数据作为一个整体，进行这一列纵向的计算 * count： 计算个数 * 一般选择非空的列：主键 * count(*) * max： 计算最大值 * min： 计算最小值 * sum： 计算和 * avg： 计算平均值 *注意：聚合函数的计算会排除null值 解决方案： - 选择不包含非空的列进行计算 - 使用IFNULL函数 eg， -- 统计name的数目 select count(name) from student; select count(ifnull(english, 0)) from student; 6. 分组查询 * 语法： group by 分组字段; * 注意： * 分组之后查询字段：分组字段、聚合函数 * where 和 having的区别： * where在分组之前进行限定，将不符合where条件的行去掉，在分组前过滤数据，即先过滤后分组；having在分组之后进行限定，筛选满足条件的组，在分组之后过滤数据，即先分组再过滤。 * where后不可以使用聚合函数，having可以使用聚合函数。 eg， -- 按照性别分组，分别查询男、女同学的平均分，人数 select sex，avg(math)，count(id) from student group by sex; -- 按照性别分组，分别查询男、女同学的平均分，人数 要求：分数低于70的不参与分组 select sex，avg(math)，count(id) from student where math &gt; 70 group by sex; -- 按照性别分组，分别查询男、女同学的平均分，人数 要求：分数低于70的不参与,分组之后人数要大于2人 select sex，avg(math)，count(id) from student where math &gt; 70 group by sex having count(id) &gt; 2; select sex，avg(math)，count(id) usernum from student where math &gt; 70 group by sex having usernum &gt; 2; 7. 分页查询 * 语法： limit 开始的索引,每页查询的条数; 数据库表的约束 约束的作用： 对表中的数据进行限制，保证数据的正确性、有效性和完整性。一个表如果添加了约束，不正确的数据将无法插入到表中。约束在创建表的时候添加比较合适。 约束的分类： 主键约束：primary key 非空约束：not null 唯一约束：unique 外键约束：foreign key 键的介绍 * 非空约束：not null，值不能为null 1. 创建表时添加约束 CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空 ); 2. 创建表完后，添加非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 3. 删除name的非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20); * 唯一约束：unique，值不能重复 1. 创建表时，添加唯一约束 CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束 ); * 注意mysql中，唯一约束限定的列的值可以有多个null 2. 删除唯一约束 ALTER TABLE stu DROP INDEX phone_number; 3. 在创建表后，添加唯一约束 ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE; * 主键约束：primary key 1. 注意： * 含义：非空且唯一 * 一张表只能有一个字段为主键 * 主键就是表中记录的唯一标识 2. 在创建表时，添加主键约束 create table stu( id int primary key,-- 给id添加主键约束 name varchar(20) ); 3. 删除主键 -- 错误 alter table stu modify id int ; ALTER TABLE stu DROP PRIMARY KEY; 4. 创建完表后，添加主键 ALTER TABLE stu MODIFY id INT PRIMARY KEY; 5. 自动增长： * 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长 * 在创建表时，添加主键约束，并且完成主键自增长 create table stu( id int primary key auto_increment,-- 给id添加主键约束 name varchar(20) ); * 删除自动增长 ALTER TABLE stu MODIFY id INT; * 添加自动增长 ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; * 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性 1. 在创建表时，可以添加外键 * 语法： create table 表名( .... 外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) ); 2. 删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 3. 创建表之后，添加外键 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 4. 级联操作 * 添加级联操作 语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE ; * 分类： * 级联更新：ON UPDATE CASCADE * 级联删除：ON DELETE CASCADE 数据库的设计多表之间的关系1. 分类： 1. 一对一(了解)： * 如：人和身份证 * 分析：一个人只有一个身份证，一个身份证只能对应一个人 2. 一对多(多对一)： * 如：部门和员工 * 分析：一个部门有多个员工，一个员工只能对应一个部门 3. 多对多： * 如：学生和课程 * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 2. 实现关系： 1. 一对多(多对一)： * 如：部门和员工 * 实现方式：在多的一方建立外键，指向一的一方的主键。 2. 多对多： * 如：学生和课程 * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 3. 一对一(了解)： * 如：人和身份证 * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。 3. 案例 -- 创建旅游线路分类表 tab_category -- cid 旅游线路分类主键，自动增长 -- cname 旅游线路分类名称非空，唯一，字符串 100 CREATE TABLE tab_category ( cid INT PRIMARY KEY AUTO_INCREMENT, cname VARCHAR(100) NOT NULL UNIQUE ); -- 创建旅游线路表 tab_route /* rid 旅游线路主键，自动增长 rname 旅游线路名称非空，唯一，字符串 100 price 价格 rdate 上架时间，日期类型 cid 外键，所属分类 */ CREATE TABLE tab_route( rid INT PRIMARY KEY AUTO_INCREMENT, rname VARCHAR(100) NOT NULL UNIQUE, price DOUBLE, rdate DATE, cid INT, FOREIGN KEY (cid) REFERENCES tab_category(cid) ); /*创建用户表 tab_user uid 用户主键，自增长 username 用户名长度 100，唯一，非空 password 密码长度 30，非空 name 真实姓名长度 100 birthday 生日 sex 性别，定长字符串 1 telephone 手机号，字符串 11 email 邮箱，字符串长度 100 */ CREATE TABLE tab_user ( uid INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) UNIQUE NOT NULL, PASSWORD VARCHAR(30) NOT NULL, NAME VARCHAR(100), birthday DATE, sex CHAR(1) DEFAULT &apos;男&apos;, telephone VARCHAR(11), email VARCHAR(100) ); /* 创建收藏表 tab_favorite rid 旅游线路 id，外键 date 收藏时间 uid 用户 id，外键 rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次 */ CREATE TABLE tab_favorite ( rid INT, -- 线路id DATE DATETIME, uid INT, -- 用户id -- 创建复合主键 PRIMARY KEY(rid,uid), -- 联合主键 FOREIGN KEY (rid) REFERENCES tab_route(rid), FOREIGN KEY(uid) REFERENCES tab_user(uid) ); 数据库设计的范式* 概念：设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 * 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 * 满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式(3NF）就行了 * 分类 * 第一范式(1NF)：数据库表的每一列都是不可分割的原子数据项，不能是集合、数组等非原子数据项。即第一范式每一列不可再拆分，称为**原子性**。 * 第二范式(2NF)：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） * 几个概念： 1. 函数依赖：A--&gt;B, 如果通过A属性(属性组)的值,可以确定唯一B属性的值, 则称B依赖于A。 例如：学号--&gt;姓名。 （学号，课程名称) --&gt; 分数 2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。 例如：（学号，课程名称）--&gt; 分数 3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如：（学号，课程名称）--&gt; 姓名 4. 传递函数依赖：A--&gt;B, B--&gt;C. 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A。 例如：学号--&gt;系名，系名--&gt;系主任 5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码。 例如：该表中码为：（学号，课程名称） * 主属性：码属性组中的所有属性 * 非主属性：除过码属性组的属性 * 第三范式：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）。 多表的操作多表的查询* 语法 * 准备sql # 创建部门表 CREATE TABLE dept( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); INSERT INTO dept (NAME) VALUES (&apos;开发部&apos;),(&apos;市场部&apos;),(&apos;财务部&apos;); # 创建员工表 CREATE TABLE emp ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), gender CHAR(1), -- 性别 salary DOUBLE, -- 工资 join_date DATE, -- 入职日期 dept_id INT, FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键) ); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;孙悟空&apos;,&apos;男&apos;,7200,&apos;2013-02-24&apos;,1); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;猪八戒&apos;,&apos;男&apos;,3600,&apos;2010-12-02&apos;,2); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;唐僧&apos;,&apos;男&apos;,9000,&apos;2008-08-08&apos;,2); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;白骨精&apos;,&apos;女&apos;,5000,&apos;2015-10-07&apos;,3); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;蜘蛛精&apos;,&apos;女&apos;,4500,&apos;2011-03-14&apos;,1); * 笛卡尔积： * 有两个集合A,B .取这两个集合的所有组成情况。 * 要完成多表查询，需要消除无用的数据 * 查询的分类 * 内连接查询 1. 隐式内连接： 使用where条件消除无用数据 * 例子： -- 查询所有员工信息和对应的部门信息 SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`; -- 查询员工表的名称，性别； 部门表的名称 SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`; 为了防止表名过于复杂，可以给表重新命名 SELECT t1.name, -- 员工表的姓名 t1.gender,-- 员工表的性别 t2.name -- 部门表的名称 FROM emp t1, dept t2 WHERE t1.`dept_id` = t2.`id`; 2. 显式内连接 * 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件 * 例如： * SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`; * SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`; 3. 内连接查询需要确定： * 从哪些表中查询数据 * 条件是什么 * 查询哪些字段 * 外连接查询 1. 左外连接： * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件； * 查询的是左表所有数据以及其交集部分。 * 例子： -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称 SELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`; 2. 右外连接： * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件； * 查询的是右表所有数据以及其交集部分。 * 例子： SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`; * 子查询 * 概念：查询中嵌套查询，称嵌套查询为子查询。 * 例子 -- 查询工资最高的员工信息 -- 1. 查询最高的工资是多少 9000 SELECT MAX(salary) FROM emp; -- 2. 查询员工信息，并且工资等于9000的 SELECT * FROM emp WHERE emp.`salary` = 9000; -- 一条sql就完成这个操作。子查询 SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp); * 子查询不同情况 1. 子查询的结果是单行单列的： * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= = *例子 -- 查询员工工资小于平均工资的人 SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp); 2. 子查询的结果是多行单列的： * 子查询可以作为条件，使用运算符in来判断 * 例子 -- 查询&apos;财务部&apos;和&apos;市场部&apos;所有的员工信息 SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;; SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2; -- 子查询 SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;); 3. 子查询的结果是多行多列的： * 子查询可以作为一张虚拟表参与查询 * 例子 -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息 -- 子查询 SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &apos;2011-11-11&apos;) t2 WHERE t1.id = t2.dept_id; -- 普通内连接 SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt; &apos;2011-11-11&apos; 事务1. 事务的基本介绍 * 概念： * 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 * 操作： 1. 开启事务： start transaction; 2. 回滚：rollback; 3. 提交：commit; * 例子： 创建表 CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), balance DOUBLE ); 添加数据 INSERT INTO account (NAME, balance) VALUES (&apos;zhangsan&apos;, 1000), (&apos;lisi&apos;, 1000); SELECT * FROM account; UPDATE account SET balance = 1000; -- 张三给李四转账 500 元 -- 0. 开启事务 START TRANSACTION; -- 1. 张三账户 -500 UPDATE account SET balance = balance - 500 WHERE NAME = &apos;zhangsan&apos;; -- 2. 李四账户 +500 -- 出错了... UPDATE account SET balance = balance + 500 WHERE NAME = &apos;lisi&apos;; -- 发现执行没有问题，提交事务 COMMIT; -- 发现出问题了，回滚事务 ROLLBACK; 2. 事物的四大特征 * 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 * 持久性：当事务提交或回滚后，数据库会持久化的保存数据。 * 隔离性：多个事务之间。相互独立。 * 一致性：事务操作前后，数据总量不变 3. 事务的隔离级别 * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 * 存在问题： 1. 脏读：一个事务，读取到另一个事务中没有提交的数据 2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 * 隔离级别： 1. read uncommitted：读未提交 * 产生的问题：脏读、不可重复读、幻读 2. read committed：读已提交 （Oracle） * 产生的问题：不可重复读、幻读 3. repeatable read：可重复读 （MySQL默认） * 产生的问题：幻读 4. serializable：串行化 * 可以解决所有的问题 * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 * 数据库查询隔离级别： * select @@tx_isolation; * 数据库设置隔离级别： * set global transaction isolation level 级别字符串; * 演示： set global transaction isolation level read uncommitted; start transaction; -- 转账操作 update account set balance = balance - 500 where id = 1; update account set balance = balance + 500 where id = 2;]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-动态规划]]></title>
    <url>%2F2020%2F06%2F12%2F%E5%89%91%E6%8C%87offer-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[分治策略：将原问题分解为若干个规模较小但类似于原问题的子问题（Divide），「递归」的求解这些子问题（Conquer），然后再合并这些子问题的解来建立原问题的解。 动态规划: 动态规划其实和分治策略是类似的，也是将一个原问题分解为若干个规模较小的子问题，递归的求解这些子问题，然后合并子问题的解得到原问题的解。 区别在于这些子问题会有重叠，一个子问题在求解后，可能会再次求解，于是我们想到将这些子问题的解存储起来，当下次再次求解这个子问题时，直接拿过来就是。 其实就是说，动态规划所解决的问题是分治策略所解决问题的一个子集，只是这个子集更适合用动态规划来解决从而得到更小的运行时间。 即用动态规划能解决的问题分治策略肯定能解决，只是运行时间长了。因此，分治策略一般用来解决子问题相互对立的问题，称为标准分治，而动态规划用来解决子问题重叠的问题。 https://www.zhihu.com/question/39948290/answer/883302989https://www.zhihu.com/question/39948290 1. 连续子数组最大和题目描述 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1). 解题思路这是一道典型的动态规划题目。 最大子数组的和一定是由当前元素和之前最大连续子数组的和叠加在一起形成的。 假设dp[i]代表以当前元素a[i]为截止点的连续子序列的最大和; 若dp[i-1]&gt;0, dp[i]=a[i]+dp[i-1], 因为当前数加上正数一定会变大; 若dp[i-1]&lt;0, dp[i]=a[i], 因为当前数加上负数一定会变小； 使用max记录最大的dp值。 max=Math.max(max, dp[i]). 1234567891011 public class Solution &#123; public int FindGreatestSumOfSubArray(int[] array) &#123; int max = array[0]; for(int i=1; i&lt;array.length; i++)&#123; array[i] += array[i-1] &gt; 0 ? array[i-1]: 0; max = Math.max(max, array[i]); &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-数组与数学问题]]></title>
    <url>%2F2020%2F06%2F07%2F%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[数组问题1. 数字统计题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 解题思路 哈希法：先遍历一遍数组，利用Map存储每个元素出现的次数，在遍历一次Map，找出众数。 12345678910111213141516171819202122232425262728293031 import java.util.HashMap;import java.util.Set;import java.util.Map;public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; if(array.length==0)&#123; return 0; &#125; int l = (int)(array.length / 2); Map&lt;Integer, Integer&gt; count = new HashMap&lt;&gt; (); for(int i=0; i&lt;array.length; i++)&#123; int num = array[i]; if(count.containsKey(num))&#123; count.put(num, count.get(num)+1); &#125;else&#123; count.put(num, 1); &#125; &#125; Set&lt;Integer&gt; set = count.keySet(); for(Integer k: set)&#123; Integer v = count.get(k); if(v.intValue() &gt; l)&#123; return k.intValue(); &#125; &#125; return 0; &#125;&#125;// 时间复杂度：O(n)// 空间复杂度：O(n) 排序法：先将数组进行排序，众数一定在数组中间，再比遍历数组统计该数出现的次数，进行判断。 1234567891011121314151617181920 import java.util.Arrays;public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; if(array.length==0)&#123; return 0; &#125; Arrays.sort(array); int num = array[array.length / 2]; int count = 0; for(int i=0; i&lt;array.length; i++)&#123; if(array[i] == num)&#123; count ++; &#125; &#125; return count&gt;(array.length / 2)?num:0; &#125;&#125; // 时间复杂度：O(nlogn)// 空间复杂度：O(1) 候选法（最优解):如果两个数不相等，就消去这两个数，最坏情况下，每次消去一个众数和一个非众数，那么如果存在众数，最后留下的数肯定是众数。 12345678910111213141516171819202122232425262728 public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; int num = -1; int cnt = 0; for(int i=0; i&lt;array.length; i++)&#123; if(cnt == 0)&#123; num = array[i]; cnt ++; &#125;else&#123; if(num == array[i])&#123; cnt++; &#125;else&#123; cnt --; &#125; &#125; &#125; cnt = 0; for(int i=0; i&lt;array.length; i++)&#123; if(array[i] == num)&#123; cnt ++; &#125; &#125; return cnt&gt;(array.length/2)?num: 0; &#125;&#125;// 时间复杂度：O(n)// 空间复杂度：O(1) 2. 连续子数组最大和题目描述 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1). 解题思路这是一道典型的动态规划题目。 最大子数组的和一定是由当前元素和之前最大连续子数组的和叠加在一起形成的。 假设dp[i]代表以当前元素a[i]为截止点的连续子序列的最大和; 若dp[i-1]&gt;0, dp[i]=a[i]+dp[i-1], 因为当前数加上正数一定会变大; 若dp[i-1]&lt;0, dp[i]=a[i], 因为当前数加上负数一定会变小； 使用max记录最大的dp值。 max=Math.max(max, dp[i]). 1234567891011 public class Solution &#123; public int FindGreatestSumOfSubArray(int[] array) &#123; int max = array[0]; for(int i=1; i&lt;array.length; i++)&#123; array[i] += array[i-1] &gt; 0 ? array[i-1]: 0; max = Math.max(max, array[i]); &#125; return max; &#125;&#125; 3. 把数组排成最小的数题目描述 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 解题思路将各个元素从小到大进行排序，排序之后再把他们串联起来。 比较两个字符串s1, s2大小的时候，先将它们拼接起来，比较s1+s2,和s2+s1那个大，如果s1+s2大，那说明s2应该放前面，所以按这个规则，s2就应该排在s1前面。 123456789101112131415161718192021222324 import java.util.ArrayList;public class Solution &#123; public String PrintMinNumber(int [] numbers) &#123; if(numbers.length == 0) return ""; for(int i=0; i&lt;numbers.length; i++)&#123; for(int j=i+1; j&lt;numbers.length; j++)&#123; int s1 = Integer.parseInt(numbers[i] + "" + numbers[j]); int s2 = Integer.parseInt(numbers[j] + "" + numbers[i]); if(s1 &gt; s2)&#123; int temp = numbers[i]; numbers[i] = numbers[j]; numbers[j] = temp; &#125; &#125; &#125; String str = new String(""); for(int i=0; i&lt;numbers.length; i++)&#123; str = str + numbers[i]; &#125; return str; &#125;&#125; 4. 数组中的逆序对问题描述 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 输入描述 题目保证输入的数组中没有的相同的数字 数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 解题思路归并排序法：二路归并即merge，是将两个有序的序列合并为一个有序的序列，在两个子序列left、right合并过程中，当left中当前元素A小于right中当前元素B时，因为right序列已经有序，所以不用比较，A一定是left、right两个子序列当前剩余元素中最小的元素，这省去了A与B后其他元素比较的操作。 对于本题，在两个子序列left、right合并过程中，当left中当前元素A大于right中当前元素B时，因为left序列已经有序，所以不用比较，B一定小于left序列当前所有剩余元素，其全部可以与B组成逆序对，即通过一次比较可到一批逆序对，加速统计过程。 123456789101112131415161718192021222324252627282930313233343536373839404142 public class Solution &#123; private int num = 0; public int InversePairs(int [] array) &#123; if(array.length &lt;= 1)&#123; return 0; &#125; mergeSort(array, 0, array.length-1); return num; &#125; public void mergeSort(int[] array, int lo, int hi)&#123; if(lo &gt;= hi)&#123; return; &#125; int mid = lo + (hi - lo) / 2; mergeSort(array, lo, mid); mergeSort(array, mid+1, hi); merge(array, lo, mid, hi); &#125; public void merge(int[] array, int lo, int mid, int hi)&#123; int i=lo, j=mid+1, k=0; int[] temp = new int[hi-lo+1]; while(i&lt;=mid &amp;&amp; j&lt;=hi)&#123; if(array[i]&gt;array[j])&#123; temp[k++] = array[j++]; num += mid-i+1; num %= 1000000007; &#125;else&#123; temp[k++] = array[i++]; &#125; &#125; while(i &lt;= mid)&#123; temp[k++] = array[i++]; &#125; while(j &lt;= hi)&#123; temp[k++] = array[j++]; &#125; for(int l=0; l&lt;k; l++)&#123; array[lo+l] = temp[l]; &#125; &#125;&#125; 数学问题1. 统计1出现的次数题目描述 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 解题思路https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/ https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6?answerType=1&amp;f=discussion 2. 丑数题目描述 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 解题思路丑数能够分解成2^x3^y5^z, 所以只需要把得到的丑数不断地乘以2、3、5之后并放入他们应该放置的位置即可，而此题的难点就在于如何有序的放在合适的位置。1乘以 （2、3、5）=2、3、5；2乘以（2、3、5）=4、6、10；3乘以（2、3、5）=6,9,15；5乘以（2、3、5）=10、15、25；如果不加策略地添加丑数是会有重复并且无序，而在2x，3y，5z中，如果x=y=z那么最小丑数一定是乘以2的，但关键是有可能存在x》y》z的情况，所以我们要维持三个指针来记录当前乘以2、乘以3、乘以5的最小值，然后当其被选为新的最小值后，要把相应的指针+1；因为这个指针会逐渐遍历整个数组，因此最终数组中的每一个值都会被乘以2、乘以3、乘以5，也就是实现了我们最开始的想法，只不过不是同时成乘以2、3、5，而是在需要的时候乘以2、3、5. 123456789101112131415161718 import java.util.ArrayList;public class Solution &#123; public int GetUglyNumber_Solution(int index) &#123; if(index &lt;= 0) return 0; int p2=0, p3=0, p5=0; int[] result = new int[index]; result[0] = 1; for(int i=1; i&lt;index; i++)&#123; result[i] = Math.min(result[p2]*2, Math.min(result[p3]*3, result[p5]*5)); if(result[i] == result[p2]*2) p2++; if(result[i] == result[p3]*3) p3++; if(result[i] == result[p5]*5) p5++; &#125; return result[index-1]; &#125;&#125; 3. 和为S的两个数字题目描述 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 解题思路双指针法:因为数组是有序的，所以可以用双指针，指向数组的首尾，具体步骤如下： 1.初始化：指针i指向数组首，指针j指向数组尾部; 2. 如果arr[i] + arr[j] == sum , 说明是可能解; 3. 否则如果arr[i] + arr[j] &gt; sum, 说明和太大，所以--j; 4. 否则如果arr[i] + arr[j] &lt; sum, 说明和太小，所以++i. 123456789101112131415161718192021222324252627282930 import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if(array.length&lt;2)&#123; return ret; &#125; int min = Integer.MAX_VALUE; int i=0; int j=array.length-1; while(i&lt;j)&#123; int s = array[i] + array[j]; if(s &lt; sum)&#123; i++; &#125;else if(s &gt; sum)&#123; j--; &#125;else&#123; if(array[i]*array[j]&lt;min)&#123; ret.clear(); min=array[i]*array[j]; ret.add(array[i]); ret.add(array[j]); &#125; i++; &#125; &#125; return ret; &#125;&#125; 4. 和为S的连续正数序列题目描述 输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。 解题思路 方法一：暴力法 求和为sum的连续子序列，可用暴力方法，算法步骤： 1）用指针i枚举目标序列的左边界； 2）用指针j枚举目标序列的右边界； 3）用指针k枚举区间[i, j]，来计算区间和，看是否等于目标sum。 1234567891011121314151617181920212223242526 public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); for(int i=1; i&lt;=sum/2; i++)&#123; for(int j=i+1; j&lt;sum; j++)&#123; int tmp=0; for(int k=i; k&lt;=j; k++)&#123; tmp += k; &#125; if(tmp == sum)&#123; ArrayList&lt;Integer&gt; s = new ArrayList&lt;&gt;(); for(int k=i; k&lt;=j; k++)&#123; s.add(k); &#125; ret.add(s); &#125;else if(tmp &gt; sum)&#123; break; &#125; &#125; &#125; return ret; &#125;&#125; // 时间复杂度：O(N^3)// 空间复杂度：O(1) 方法二：前缀和 对于求一个区间和，一贯的优化技巧是使用前缀和。比如： sum[i]表示前i个数的和。比如sum[1] = 1,表示前一个数的和为1，sum[2] = 3, 表示前2个数的和为3. 现在我们要求区间[2,4]表示求第2,3,4个数的和，就等于sum[4] - sum[1] = 9。 代码中我们用一个变量来模拟这个前缀和。 12345678910111213141516171819202122232425 public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); int temp=0; for(int i=1; i&lt;=sum/2; i++)&#123; for(int j=i; j&lt;sum; j++)&#123; temp += j; if(temp==sum)&#123; ArrayList&lt;Integer&gt; s = new ArrayList&lt;&gt;(); for(int k=i; k&lt;=j; k++)&#123; s.add(k); &#125; ret.add(s); &#125;else if(temp &gt; sum)&#123; temp = 0; break; &#125; &#125; &#125; return ret; &#125;&#125; // 时间复杂度：O(N^2)// 空间复杂度：O(1) 方法三：滑动窗口 1. 什么是滑动窗口？ 顾名思义，首先是一个窗口，既然是一个窗口，就需要用窗口的左边界i和右边界j来唯一表示一个窗口， 其次，滑动代表，窗口始终从左往右移动，这也表明左边界i和右边界j始终会往后移动，而不会往左移动。 这里我用左闭右开区间来表示一个窗口。比如： 2. 滑动窗口的操作 * 扩大窗口，j += 1 * 缩小窗口，i += 1 算法步骤： 1）初始化，i=1,j=1, 表示窗口大小为0 2）如果窗口中值的和小于目标值sum， 表示需要扩大窗口，j += 1 3）否则，如果狂口值和大于目标值sum，表示需要缩小窗口，i += 1 4）否则，等于目标值，存结果，缩小窗口，继续进行步骤2,3,4 这里需要注意2个问题： *什么时候窗口终止呢，这里窗口左边界走到sum的一半即可终止，因为题目要求至少包含2个数 *什么时候需要扩大窗口和缩小窗口？解释可看上述算法步骤。 1234567891011121314151617181920212223242526272829 public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); int l=1; int r=1; int temp=0; while(l &lt;= sum/2)&#123; if(temp &lt; sum)&#123; temp += r; r++; &#125;else if(temp &gt; sum)&#123; temp -= l; l++; &#125;else&#123; ArrayList&lt;Integer&gt; s = new ArrayList&lt;&gt;(); for(int k=l; k&lt;r; k++)&#123; s.add(k); &#125; ret.add(s); temp -= l; l++; &#125; &#125; return ret; &#125;&#125; // 时间复杂度：O(N)// 空间复杂度：O(1)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-字符串问题]]></title>
    <url>%2F2020%2F06%2F07%2F%E5%89%91%E6%8C%87offer-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 字符串的排列题目描述 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 解题思路利用递归的思想，首先固定第一个字符，将剩余的部分看做一个新的字符串，递归的取得首位后面各种字符串的组合。再第一个字符串与后面的每一个字符串进行交换，同样递归的获得其字符串组合。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 import java.util.ArrayList;import java.util.Collections;// 使用数组public class Solution &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; ret = new ArrayList&lt;String&gt;(); if(str.length()==0 &amp;&amp; str==null)&#123; return ret; &#125; Permute(str.toCharArray(), 0, ret); Collections.sort(ret); return ret; &#125; public void Permute(char[] str, int i, ArrayList&lt;String&gt; ret)&#123; if(i == str.length - 1)&#123; if(!ret.contains(new String(str)))&#123; ret.add(new String(str)); &#125; &#125;else&#123; for(int j=i; j&lt;str.length; j++)&#123; swap(str, i, j); Permute(str, i+1, ret); swap(str, i, j); &#125; &#125; &#125; public void swap(char[] str, int i, int j)&#123; char temp = str[i]; str[i] = str[j]; str[j] = temp; &#125;&#125; // 使用StringBuffer public class Solution &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; ret = new ArrayList&lt;String&gt;(); if(str.length()==0 &amp;&amp; str==null)&#123; return ret; &#125; Permute(new StringBuffer(str), 0, ret); Collections.sort(ret); return ret; &#125; public void Permute(StringBuffer str, int i, ArrayList&lt;String&gt; ret)&#123; if(i == str.length() - 1)&#123; if(!ret.contains(str.toString()))&#123; ret.add(str.toString()); &#125; &#125;else&#123; for(int j=i; j&lt;str.length(); j++)&#123; swap(str, i, j); Permute(str, i+1, ret); swap(str, i, j); &#125; &#125; &#125; public void swap(StringBuffer str, int i, int j)&#123; char temp = str.charAt(i); str.setCharAt(i, str.charAt(j)); str.setCharAt(j, temp); &#125;&#125; // 算法时间复杂度： O(n!) // 空间复杂度：O(1) 2. 第一个只出现一次的字符题目描述 在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数） 解题思路遍历一遍字符串，统计每个字符出现的次数。然后再遍历一遍字符串，找出答案。 1234567891011121314151617181920212223242526272829303132333435363738394041 import java.util.HashMap;public class Solution &#123; public int FirstNotRepeatingChar(String str) &#123; if(str==null || str.length()==0)&#123; return -1; &#125; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0; i&lt;str.length(); i++)&#123; if(!map.keySet().contains(str.charAt(i)))&#123; map.put(str.charAt(i), 1); &#125;else&#123; map.put(str.charAt(i), map.get(str.charAt(i))+1); &#125; &#125; for(int i=0; i&lt;str.length(); i++)&#123; if(map.get(str.charAt(i))==1)&#123; return i; &#125; &#125; return -1; &#125;&#125;// ************** 使用数组实现 ************** public class Solution &#123; public int FirstNotRepeatingChar(String str) &#123; if(str==null || str.length()==0)&#123; return -1; &#125; int[] count = new int[128]; for(int i=0; i&lt;str.length(); i++)&#123; count[str.charAt(i)] ++; &#125; for(int i=0; i&lt;str.length(); i++)&#123; if(count[str.charAt(i)] == 1)&#123; return i; &#125; &#125; return -1; &#125;&#125; 3. 左旋转字符串题目描述 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。 解题思路123456789101112 public class Solution &#123; public String LeftRotateString(String str,int n) &#123; if(n &gt; str.length())&#123; return str; &#125; int k = n % str.length(); String s1 = str.substring(0, k); String s2 = str.substring(k); return s2+s1; &#125;&#125; 4. 翻转单词顺序列题目描述 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 解题思路 题目抽象：给定一个首尾可能带空格的字符串，请让你翻转该字符串。首尾不能有多余空格。如果全部是空格，请返回原字符串。 然后以空格为分割单元将单词分开并按正常顺序拼接。 12345678910111213141516171819202122232425262728 public class Solution &#123; public String ReverseSentence(String str) &#123; //判断str是否为空 if(str.isEmpty()) return str; //判断str中是否全为空格 int i=0, size=str.length(); while(i&lt;size &amp;&amp; str.charAt(i)==' ') i++; if(i == size) return str; String ret = ""; String tmp = ""; boolean hasstr = false; for(i=size-1; i&gt;=0; i--)&#123; char c = str.charAt(i); if(c != ' ')&#123; tmp = c + tmp; hasstr = true; &#125;else if(c==' ' &amp;&amp; hasstr)&#123; ret = ret + tmp + " "; tmp = ""; hasstr = false; &#125; &#125; if(tmp != "") ret = ret + tmp; return ret; &#125;&#125; 5. 扑克牌顺子题目描述 LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 解题思路12345678910111213141516171819202122232425import java.util.Arrays;public class Solution &#123; public boolean isContinuous(int [] numbers) &#123; if(numbers.length == 0) return false; Arrays.sort(numbers); int zeor_num = 0; int gap = 0; for(int i=0; i&lt;numbers.length-1; i++)&#123; if(numbers[i] == 0)&#123; zeor_num += 1; continue; &#125; if(numbers[i+1] == numbers[i]) return false; int g = numbers[i+1]-numbers[i]; if(g &gt; 1) gap = gap + g - 1; &#125; if(zeor_num &gt;= gap)&#123; return true; &#125; return false; &#125;&#125; 6. 把字符串转换成整数题目描述将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 输入描述 输入一个字符串,包括数字字母符号,可以为空 输出描述 如果是合法的数值表达则返回该数字，否则返回0 解题思路这道题难点在于边界的考察。对于一般规则的数字“字符串”转化为数字如下： int的范围为[2^31-1, -2^31]如果超过了这两个范围该怎么办？其实也很简单，首先判断这个数的正负，如果正数，超过了Integer.MAX_VALUE，就设置Integer.MAX_VALUE，如果是负数，首先我们不考虑负号，如果超过了Integer.MAX_VALUE, 则就置为Integer.MAX_VALUE+1, 最后再根据正负号，来加负号。 123456789101112131415161718192021222324252627282930313233343536 public class Solution &#123; public int StrToInt(String str) &#123; if(str == null || "".equals(str.trim()))&#123; return 0; &#125; int l = str.length(); //if(l == 0) return 0; int i = 0; int ret = 0; int flag = 1; char[] arr = str.toCharArray(); if(arr[i] == '-')&#123; flag = -1; &#125; if(arr[i] == '+' || arr[i] == '-')&#123; i++; &#125; while(i &lt; l)&#123; if(arr[i] &gt;= '0' &amp;&amp; arr[i] &lt;= '9')&#123; int cur = arr[i] - '0'; if(flag==1 &amp;&amp; (ret&gt;Integer.MAX_VALUE/10 || (ret==Integer.MIN_VALUE/10 &amp;&amp; cur &gt; 7)))&#123; return 0; &#125; if(flag==-1 &amp;&amp; (ret&gt;Integer.MAX_VALUE/10 || (ret==Integer.MIN_VALUE/10 &amp;&amp; cur &gt; 8)))&#123; return 0; &#125; ret = ret * 10 + cur; i++; &#125;else&#123; return 0; &#125; &#125; return ret * flag; &#125;&#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法-树结构总结]]></title>
    <url>%2F2020%2F06%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[“树”是数据结构中常见的非线性存储结构。在“树”结构中有一些常用的术语，总结为下： 父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点。 子节点：一个节点含有的子树的根节点称为该节点的子节点。 兄弟节点：拥有共同父节点的节点互称为兄弟节点。 度：节点的子树数目就是节点的度。 叶子节点：度为零的节点就是叶子节点。 节点的层次：从根节点开始，根节点为第一层，根的子节点为第二层，以此类推。 节点深度：对任意节点x，x节点的深度表示为根节点到x节点的路径长度。例如：根节点深度为0，第二层节点深度为1，以此类推。 “根节点—&gt;节点的路径长度” 节点高度：对任意节点x，叶子节点到x节点的路径长度就是节点x的高度。 “节点—&gt;叶子节点的路径长度” 树的深度：一棵树中节点的最大深度就是树的深度，也称为高度。 数据结构中有很多种树结构：二叉树，二叉搜索树， 红黑树，B+树等，下面对常见的几种树结构的的定义以及用途进行简单的介绍。 1. 二叉树 二叉树的定义：二叉树的每个结点最多只有二棵子树(不存在度大于2的结点)的树结构。每个节点有左右两个子节点。 二叉树示例： 满二叉树 和 完全二叉树： 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。即除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点都在同一层上。 完全二叉树：对于一颗二叉树，假设其深度为d（d&gt;1）。除第d层外的所有节点构成满二叉树，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树 示例： 二叉树的性质： 在非空二叉树中，第i层的结点总数不超过2i-1, i&gt;=1; 深度为d的二叉树最多有2d-1个结点(d&gt;=1)，最少有d个结点; 具有n个结点的完全二叉树的深度为log2(n+1)； 2. 二叉查找树（二叉搜索树、二叉排序树、BST） 二叉查找树定义:二叉查找树又称二叉搜索树、二叉排序树、BST. 它是具有以下性质的二叉树： 若左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值； 左、右子树也分别为二叉排序树； 没有键值相等的节点。 示例左边的是BST，右边的不是： 对二叉查找树进行中序遍历，即可得到有序的数列。 它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。 二叉查找树的高度决定了二叉查找树的查找效率。 3. 二叉树的操作 二叉树的遍历 二叉树有三种遍历方式： 先序遍历：先访问根节点，再前序遍历左子树，最后前序遍历右子树。 中序遍历：先中序访问左子树，再访问根节点，再中序访问右子树。中序遍历得到一个有序（递增）的数列。 后序遍历：先后序访问左子树，再后序访问右子树，再访问根节点。 12345678910111213141516171819202122232425262728 // 二叉树的定义public class TreeNode&#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val)&#123; this.val = val; &#125;&#125; // 先序遍历 (根节点-&gt;左子树-&gt;右子树)public void PreOrderTraversal(TreeNode root)&#123; System.out.println(root.val); PreOrderTraversal(root.left); PreOrderTraversal(root.right);&#125; // 中序遍历 （左子树-&gt;根节点-&gt;右子树）public void InOrderTraversal(TreeNode root)&#123; InOrderTraversal(root.left); System.out.println(root.val); InOrderTraversal(root.right);&#125; // 后序遍历 (左子树-&gt;右子树-&gt;根节点)public void PostOrderTraversal(TreeNode root)&#123; PostOrderTraversal(root.left); PostOrderTraversal(root.right); System.out.println(root.val);&#125; 二叉树的层级遍历 二叉树的层级遍历需要借助一个队列(queue)来保存当前节点的子节点。 1. 初始化：一个队列queue，将root节点入队列q 2. 如果队列不空，做如下操作： 3. 弹出队列头，保存为node，将node的左右非空孩子加入队列 4. 重复2,3步骤，直到队列为空 以上图左子图为例： 1. 创建空队列q=[]; 2. 将根节点6入队列，q=[6]; 3. 队列不空，取出队列中头元素6，若6节点左右子节点不空，入队，q=[2,8]; 4. 队列不空，取出头元素2，将节点2的左右子节点入队，q=[8,1,4]; 5. 重复上述步骤，直到队列为空。 123456789101112131415161718192021222324252627282930 import java.util.Queue;import java.util.LinkedList;import java.util.ArrayList;public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; public int TreeDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; ArrayList&lt;TreeNode&gt; ret = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;(); q.add(root); while(q.size()!=0)&#123; TreeNode node = q.poll(); ret.add(node); if(node.left != null)&#123; q.add(node.left); &#125; if(node.right != null)&#123; q.add(node.right); &#125; &#125; &#125; 若需记录树的深度或有几层，可作如下改进： 1234567891011121314151617181920212223242526272829303132333435363738 //递归方法 public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root == null)return 0; int ld = TreeDepth(root.left); int rd = TreeDepth(root.right); return Math.max(ld,rd) + 1; &#125;&#125; //非递归方法 public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;(); q.add(root); int level = 0; int size; TreeNode node; while(q.size()!=0)&#123; size = q.size(); while(size != 0)&#123; node = q.poll(); if(node.left != null)&#123; q.add(node.left); &#125; if(node.right != null)&#123; q.add(node.right); &#125; size--; &#125; level++; &#125; return level; &#125;&#125; 二叉查找树插入节点操作 二叉查找树的插入过程如下： 1) 若当前的二叉查找树为空，则插入的元素为根节点; 2) 若插入的元素值小于根节点值，则将元素插入到左子树中; 3) 若插入的元素值不小于根节点值，则将元素插入到右子树中。 二叉查找树删除节点操作 二叉查找树的删除，分三种情况进行处理： 1）p为叶子节点，直接删除该节点，再修改其父节点的指针（注意分是根节点和不是根节点），如图a; 2）p为单支节点（即只有左子树或右子树）。让p的子树与p的父亲节点相连，删除p即可（注意分是根节点和不是根节点），如图b; 3）p的左子树和右子树均不空。找到p的后继y，y为这个节点右子树的最小值或者左子树的最大值。 如图c。 4. 平衡二叉树对于一般的二叉搜索树，其期望高度（即为一棵平衡树时）为log2n，其各操作的时间复杂度O(log2n)同时也由此而决定。但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即O(n)。我们可以通过随机化建立二叉搜索树来尽量的避免这种情况，但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。于是就有了我们下边介绍的平衡二叉树。 平衡二叉树（Balanced Binary Tree）：又被称为AVL树（有别于AVL算法），且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 并且平衡二叉树必定是二叉搜索树。平衡二叉树的常用算法有红黑树、AVL树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。 最小二叉平衡树的节点的公式为：F(n)=F(n-1)+F(n-2)+1这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。 判断一颗二叉树是不是平衡二插树1234567891011121314151617 public class Solution &#123; public boolean IsBalanced_Solution(TreeNode root) &#123; return depth(root) != -1; &#125; public int depth(TreeNode root)&#123; if(root == null)return 0; int left = depth(root.left); if(left == -1)return -1; //如果发现子树不平衡之后就没有必要进行下面的高度的求解了 int right = depth(root.right); if(right == -1)return -1;//如果发现子树不平衡之后就没有必要进行下面的高度的求解了 if(left - right &lt;(-1) || left - right &gt; 1) return -1; else return 1+(left &gt; right?left:right); &#125;&#125; AVL树的查找、插入和删除在平均和最坏情况下都是O(logn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。 AVL树平衡操作：https://blog.csdn.net/qq_25343557/article/details/89110319https://www.cnblogs.com/zhuwbox/p/3636783.html 5. 红黑树红黑树的定义：红黑树是一种自平衡二叉查找树。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。 红黑树与AVL树的区别： 区别： 1）红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。 2）平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。 共同点： 进行插入或者删除是都是需要进行一定的平衡操作的。 红黑树的性质： 红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制的一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求: 性质1. 节点是红色或黑色。 性质2. 根是黑色。 性质3. 所有叶子都是黑色（叶子是NIL节点）。 性质4. 每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。) 性质5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。 参考： 书籍《算法 第四版》 https://www.cnblogs.com/maybe2030/p/4732377.htmlhttps://blog.csdn.net/u014532217/article/details/79118023https://blog.csdn.net/qq_31709249/article/details/103092783]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-String Problem]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-String%20problem%2F</url>
    <content type="text"><![CDATA[Longest Substring Without Repeating CharactersDescription Given a string, find the length of the longest substring without repeating character. example Input: &quot;abcabcbb&quot; Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. solution1. 方法一：暴力法 检查每一个子字符串是否有重复的字符12345678910111213141516171819public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); int ans = 0; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt;= n; j++) if (allUnique(s, i, j)) ans = Math.max(ans, j - i); return ans; &#125; public boolean allUnique(String s, int start, int end) &#123; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (int i = start; i &lt; end; i++) &#123; Character ch = s.charAt(i); if (set.contains(ch)) return false; set.add(ch); &#125; return true; &#125;&#125; 算法分析：时间复杂度：O(n3)；空间复杂度：O(min(m,n)) 2. 方法二：滑动窗口 滑动窗口经常用在数组和字符串的问题中，滑动窗口是数组和字符串中的一些元素，它用两个索引来表示滑动窗口的起始位置[i,j),滑动窗口通过滑动左右的两个索引来改变滑动窗口滑动的方向以及窗口内的元素. 本题用HashSet来存储现在的滑动窗口内的元素[i,j),通过检查第j个元素，如果不在集合中就存储到集合并继续增加滑动窗口右侧可值j，如果第j个元素已经在集合中了，那么就滑动左侧的索引i，从集合中删除第i个元素，直到此时第j个元素不在集合中了。 代码实现12345678910111213141516171819 public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int ans = 0, i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; n) &#123; // try to extend the range [i, j] if (!set.contains(s.charAt(j)))&#123; set.add(s.charAt(j++)); ans = Math.max(ans, j - i); &#125; else &#123; set.remove(s.charAt(i++)); &#125; &#125; return ans; &#125;&#125; 算法分析：时间复杂度：O(2n)=O(n) 3. 方法三:滑动窗口的优化 利用HashMap来代替HashSet123456789101112131415class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n=s.length(); int maxn=0; Map&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(); for(int i=0,j=0;j&lt;n;j++)&#123; if(map.contains(s.charAt(j)))&#123; i=Math.max(map.get(s.charAt(j)),i); &#125; amxn=Math.max(maxn,j-i+1); map.put(s.charAt(j),j+1); &#125; return maxn; &#125;&#125; 算法分析：时间复杂度O(n) Longest Palindromic Substring 回文字符串：正读反读都一样 1.方法一：暴力法 遍历所有的子字符串，判断它是不是回文字符串 1234567891011121314151617181920212223242526272829303132333435363738 class Solution &#123; public String longestPalindrome(String s) &#123; if(s.length()==1)&#123; return s; &#125; if(s.isEmpty())&#123; return ""; &#125; int maxn=0; int iMin=0; //遍历每个子字符串并判断是不是回文的 for(int i=0;i&lt;s.length();i++)&#123; for(int j=s.length()-1;j&gt;=i;j--) if(s.charAt(i)==s.charAt(j))&#123; if(check(s,i,j))&#123; if(j-i+1&gt;maxn)&#123; maxn=j-i+1; iMin=i; &#125; break; &#125; &#125; &#125; return s.substring(iMin,maxn); &#125; //检测一个字符串是不是回文 public boolean check(String s,int i,int j)&#123; while(i&lt;=j)&#123; if(s.charAt(i)!=s.charAt(j))&#123; return false; &#125; i++; j--; &#125; return true; &#125;&#125; 算法分析： 时间复杂度O(n^3) 2. 方法二：动态规划 暴力法时间复杂度高的原因是去检查每一个子字符串是不是回文的，降低时间复杂度就要减少对子字符串是不是回文的判断 假设一个字符串”ababa”,当我已经确认了”bab”是回文字符串，由于它左右两边的字符都是a，那么这个完整的字符串本身就是回文的，就可以不用对整个字符串再进行完整的判断。 假设一个字符串的长度为n，那么建立一个n*n数组P。在矩阵中P[i][j]=l，若l&gt;0：表示以字符S[i]开始和以S[j]结尾的字符串是回文字符串，字符串的长度为l;若l=0，表示此字符串不是回文字符串 只需要对矩阵中j&gt;=i的部分赋值即可，就j&lt;i部分为0； 1.一个字符的情况：将矩阵的对角线赋值为1，因为每个字符本身是回文的 2.两个字符的情况：j-i=1 P[i][j]=2,if S[i]=S[j] 3.多个字符的情况：j-i&gt;=2 if S[i]!=S[j] P[i][j]=0; if S[i]=S[j] if P[i+1][j-1]&gt;0 P[i][j]=p[i+1][j-1]+2; else P[i][j]=0; 字符串有多个字符组成时，如果两边的字符相等，那么这个字符串可能是回文的，这时将字符串去掉首末字符得到子字符串，如果子字符串回文的，那么这个字符串也是回文的。 12345678910111213141516171819202122232425262728293031323334353637383940 public static String longestPalindrome(String s)&#123; if(s.length()==0)&#123; return ""; &#125; if(s.length()==1)&#123; return s; &#125; int[][] p=new int[s.length()][s.length()]; int indexMin=0,maxn=1; //初始化二维数组P for(int i=0;i&lt;s.length();i++)&#123; for(int j=0;j&lt;s.length();j++)&#123; if(i==j) p[i][j]=1; &#125; &#125; for(int j=0;j&lt;s.length();j++)&#123; for(int i=j-1;i&gt;=0;i--)&#123; if(s.charAt(i)==s.charAt(j))&#123; if(j-i==1)&#123; p[i][j]=2; &#125; if(j-i&gt;=2)&#123; if(p[i+1][j-1]&gt;0)&#123; p[i][j]=p[i+1][j-1]+2; &#125;else&#123; p[i][j]=0; &#125; &#125; &#125;else&#123; p[i][j]=0; &#125; if(p[i][j]&gt;maxn)&#123; maxn=p[i][j]; indexMin=i; &#125; &#125; &#125; return s.substring(indexMin, indexMin+maxn);&#125; 算法分析： 时间复杂度：O(n^2) 空间复杂度：O(n^2)需要一个n*n的矩阵来存储数据 3.方法三：Expand Around Center 对于动态规划算法时间复杂度为O(n^2)，空间复杂度为O(n^2)，可以进一步优化只用O(1)的空间实现O(n^2)的时间复杂度 一个回文字符串它是成中心对称的，比如”baab”,”bab”,但是回文字符串分为两种：奇数字符数，偶数字符数 1234567891011121314151617181920212223242526272829 class Solution &#123; public String longestPalindrome(String s) &#123; if(s.length()==0)&#123; return ""; &#125; if(s.length()==1)&#123; return s; &#125; int indexMin=0,maxn=1; for(int i=0;i&lt;s.length();i++)&#123; int len1=expandAroundCenter(s,i,i); int len2=expandAroundCenter(s,i,i+1); int len=Math.max(len1,len2); if(len&gt;maxn)&#123; indexMin=i-(len-1)/2; maxn=len; &#125; &#125; return s.substring(indexMin,indexMin+maxn); &#125; private int expandAroundCenter(String s,int L,int R)&#123; while(L&gt;=0 &amp;&amp; R&lt;s.length() &amp;&amp; s.charAt(L)==s.charAt(R))&#123; L--; R++; &#125; return R-L-1; &#125; &#125; 算法分析 时间复杂度：O(n^2) 空间复杂苏：O(1) 4.方法四：最长公共字符串 将字符串S翻转为S’,检查S和S’的最长公共字符串就是S的最长回文子字符串此方法中存在一种问题，就是当字符串中某一个子串存在一个镜像子串本身并不是回文的，翻转之后会被检测为回文的。 Longest Common Substring 最长公共子字符串 动态规划问题 动态规划问题的两个特点： 1.最优子结构 2.重叠子问题 因为有重叠子问题，当前计算的过程中可能有的问题在之前的计算已经计算过了，现在又要计算一遍，导致大量重复的计算动态规划通过找到解决问题的递推关系，将已经完成计算的存储起来，当开始新的计算时如果包含之前计算的子问题时，不需要再次计算，只需要访问已经存储的计算结果就可以动态规划解决问题的方法一般减少了时间复杂度，增加了存储空间。 对于这个问题，假设有两个字符串s[0,…m],t[0,…,n],求两个字符串的最长公共子字符串定义矩阵mXn的矩阵L,L[i][j]表示以s[i]开始和t[j]结尾的公共子字符串长度的最大值，那么对于L[i+1][j+1]只是比L[i][j]增加了s[i+1]和t[j+1] 因此可以构造出最长公共子字符串的递归式： if s[i]==t[j] L[i][j]=L[i-1][j-1]+1 if s[i]!=t[j] L[i][j]=0 假设有两个字符串：”ABAB”和”BABA” ,构造出了上述的矩阵代码实现123456789101112131415161718192021222324 public static String LCS(String s1,String s2)&#123; if(s1.isEmpty() || s2.isEmpty())&#123; return ""; &#125; int indexMax=0,maxn=0; int[][] L=new int[s1.length()][s2.length()]; for(int i=0;i&lt;s1.length();i++)&#123; for(int j=0;j&lt;s2.length();j++)&#123; if(s1.charAt(i)==s2.charAt(j))&#123; if(i==0 || j==0)&#123; L[i][j]=1; &#125;else&#123; L[i][j]=L[i-1][j-1]+1; &#125; &#125; if(L[i][j]&gt;maxn)&#123; maxn=L[i][j]; indexMax=i; &#125; &#125; &#125; return s1.substring(indexMax+1-maxn, indexMax+1);&#125; 算法分析： 时间复杂度：O(m*n) 空间复杂度：O(m*n) 算法优化 从上面动态查找最长公共子字符串的过程中发现，在循环查找的过程中只会用到矩阵L中的两行，即正在计算的一行和完成计算的上一行，之前计算的和带计算的都用不到，所以只需要维护两行数据就足够了，不需要使用mxn的数组 代码实现：123456789101112131415161718192021222324252627282930 public class LCS_improve &#123; public static String LCS_improve(String s1,String s2)&#123; if(s1.isEmpty() || s2.isEmpty())&#123; return ""; &#125; int indexMax=0,maxn=0; int [][] L=new int[2][s1.length()]; for(int i=0;i&lt;s1.length();i++)&#123; int cur=(i+2)%2; int pre=(i+1)%2; for(int j=0;j&lt;s2.length();j++)&#123; if(s1.charAt(i)==s2.charAt(j))&#123; if(i==0 || j==0)&#123; L[cur][j]=1; &#125;else&#123; L[cur][j]=L[pre][j-1]+1; &#125; &#125;else&#123; L[cur][j]=0; &#125; if(L[cur][j]&gt;maxn)&#123; maxn=L[cur][j]; indexMax=i; &#125; &#125; &#125; return s1.substring(indexMax+1-maxn, indexMax+1); &#125;&#125; 算法分析时间复杂度：O(mn)空间复杂度：O(min(m,n)) Longest Common PrefixDescription Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “” Example Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] Output: &quot;fl&quot; Solution 1. 方法一：横向比较 这是一种迭代的方法，假设字符串数组的长度为n，先将第一个字符串和第二个字符串比较得到最长公共前缀prefix，再将得到的prefix和第三个字符串比较得到新的prefix，依次向后比较，直到最后一个字符串。如果比较的过程中有prefix为空时，直接返回” “,LCP(S1,S2,.....,SN)=LCP(LCP(LCP(S1,S2),S3),.....SN)。 public String longestCommonPrefix(String[] strs) { if (strs.length == 0) return ""; String prefix = strs[0]; for (int i = 1; i &lt; strs.length; i++) while (strs[i].indexOf(prefix) != 0) { prefix = prefix.substring(0, prefix.length() - 1); if (prefix.isEmpty()) return ""; } return prefix; } 算法分析时间复杂度：在最坏的情况下为O(S),S为字符串数组中所有字符的总数空间复杂度：O(1) 2. 方法二：纵向比较 横向比较需要从第一个字符串比较到最后一个，如果数组中最短的字符串再最后的位置，那么在整个算法执行的过程中会有很多不必要的比较运算，增加了时间复杂度。因此采用纵向的比较，以最短字符串的长度l为标准，最多只比较到每个字符串的l位。从所有字符串的第一个字符开始比较，对位比较所有的字符串，直到在某一位的字符不相同或者已经到了最短的字符串的末尾字符，就结束运算。 public class Longest_Common_Prefix { public String longestCommonPrefix(String[] strs) { if(strs.length == 0) { return ""; } for(int i=0;i&lt;strs[0].length();i++) { char t = strs[0].charAt(i); for(int j=1;j&lt;strs.length;j++) { if(i == strs[j].length() || strs[j].charAt(i) != t) { return strs[0].substring(0, i); } } } return strs[0]; } } 算法分析时间复杂度：最坏情况下(所有字符串相同)O(S),一般情况下n*min(Si)空间复杂度：O(1) 3. 方法三：分而治之 将字符数组分为两组，分别对两组查找最长公共前缀sl,sr，最后再计算sl和sr的公共前缀。 public class Longest_Common_Prefix { //分而治之的方法 public String longestCommonPrefix(String[] strs) { if(strs.length==0) { return ""; } return longestCommonPrefix(strs,0,strs.length-1); } private String longestCommonPrefix(String[] strs,int l,int r) { if(l==r) { return strs[l]; } int mid = (l+r)/2; String lcpLeft=longestCommonPrefix(strs,l,mid); String lcpRight=longestCommonPrefix(strs,mid+1,r); return commonPrefix(lcpLeft,lcpRight); } private String commonPrefix(String s1,String s2) { int len=Math.min(s1.length(), s2.length()); for(int i=0;i&lt;len;i++) { if(s1.charAt(i) != s2.charAt(i)) { return s1.substring(0, i); } } return s1.substring(0,len); } } 算法分析时间复杂度：最坏情况下为O(S),(S=mn,m为每个字符串的长度，n为字符串的个数)空间复杂度：O(mlogn),算法logn次的递归调用，每次都需要m个存储空间 4. 方法四：二分法 首先找到字符串数组中最短字符串的长度minLen,它也是公共前缀的最大的长度，那么查找最长公共前缀的范围就缩小到每个字符串[0,minLen]之间。 将查找范围分为等长的两部分，[0,mid]和[mid+1,minLen]，取第一个字符串的前半部分的子字符串substr1 = str1.subString(0,mid),去和其他的字符串比较判断substr1是不是公共前缀，这时会有两种情况： 如果substr1是公共前缀，那么就将substr1增加判断更长的子字符串是不是公共前缀 如果substr1不是公共前缀，那么对于长度大于substr1的字符串都不是公共前缀，这时减小substr1去判断更小的子字符串是不是公共前缀 class Solution { public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return ""; int minLen = Integer.MAX_VALUE; for (String str : strs) minLen = Math.min(minLen, str.length()); int low = 1; int high = minLen; while (low &lt;= high) { int middle = (low + high) / 2; if (isCommonPrefix(strs, middle)) low = middle + 1; else high = middle - 1; } return strs[0].substring(0, (low + high) / 2); } private boolean isCommonPrefix(String[] strs, int len){ String str1 = strs[0].substring(0,len); for (int i = 1; i &lt; strs.length; i++) if (!strs[i].startsWith(str1)) return false; return true; } } 算法分析时间复杂度：O(S * logn)空间复杂度：O(1) Valid ParenthesesDescription Given a string containing just the characters &apos;(&apos;, &apos;)&apos;, &apos;{&apos;, &apos;}&apos;, &apos;[&apos; and &apos;]&apos;, determine if the input string is valid. An input string is valid if: 1.Open brackets must be closed by the same type of brackets. 2.Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example Example 1: Input: &quot;()&quot; Output: true Example 2: Input: &quot;()[]{}&quot; Output: true Example 3: Input: &quot;(]&quot; Output: false Example 4: Input: &quot;([)]&quot; Output: false Example 5: Input: &quot;{[]}&quot; Output: true Solution 方法概述-堆栈法 对于一个有效的字符表达式，字符串中的括号都是成对出现的。正如题中所说，打开的括号必须有相同形式的关闭括号，并且所有打开的括号必须以正确的顺序关闭。 从起始位置开始检查字符串，如果第一个字符是关闭字符，那么这个字符串一定不是有效的；如果第一个是某种打开字符，将它压入堆栈 stack.push(char c)，每遇到一个打开字符就做相同的操作；如果遍历字符串中遇到的关闭字符，看栈顶的字符是不是和此关闭字符相匹配的打开字符，如果是，将字符出栈并继续遍历，如果不是，那么就不是有效的字符串；顺利遍历完整个字符串时，检查栈是否为空，如果是空，那么字符串时有效的，否则无效。 class Solution { public boolean isValid(String s) { if(s.isEmpty()) { return true; } char[] stack = new char[s.length()]; int top = 0; for(int i=0;i&lt;s.length();i++) { char c = s.charAt(i); if(c=='{' || c=='[' || c=='(') { stack[top++] = c; } if(c=='}') { if(top==0 || stack[--top]!='{') { return false; } } if(c==']') { if(top==0 || stack[--top]!='[') { return false; } } if(c==')') { if(top==0 || stack[--top]!='(') { return false; } } } return top==0; } } Generate ParenthesesDescription Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. Example given n = 3, a solution set is: [ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot; ] Solution 方法一：暴力法 方法概述：产生所有可能的字符串，检查每个字符串是不是有效形式。 public class Generate_Parentheses { public List&lt;String&gt; generateParentheses(int n){ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); generateAll(new char[2*n],0,list); return list; } private void generateAll(char[] current,int index,List&lt;String&gt; result) { if(index == current.length) { if(valid(current)) { result.add(new String(current)); } }else { current[index] = '('; generateAll(current,index+1,result); current[index] = ')'; generateAll(current,index+1,result); } } private boolean valid(char[] current) { int flag=0; for(char c:current) { if(c == '(') flag++; else flag--; if(flag&lt;0) return false; } return (flag==0); } } 算法分析 时间复杂度：O(n*2^2n) 空间复杂度：O(n*2^2n) 方法二： 回溯算法 方法概述：回溯算法相当于穷举法(通用解法的美称)，性能一般不太理想，但某些情况和穷举法相比性能也有显著的提升，和穷举法不同的是回溯法设置一些条件过滤了一些不可能的情况，回溯法一般用递归来解决 public class Generate_Parentheses { //回溯法 public List&lt;String&gt; generateParentheses(int n){ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); backtrack(list,"",0,0,n); return list; } private void backtrack(List&lt;String&gt; list,String s,int open,int close,int max) { if(s.length() == 2*max) { list.add(s); return; } if(open&lt;max) { backtrack(list,s+'(',open+1,close,max); } if(close&lt;open) { backtrack(list,s+')',open,close+1,max); } } } 算法分析 时间复杂度：O(4^n/n^1/2) 空间复杂度：O(4^n/n^1/2) Longest Valid Parentheses(32-Hard)Description Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring. Example Example 1: Input: &quot;(()&quot; Output: 2 Explanation: The longest valid parentheses substring is &quot;()&quot; Example 2: Input: &quot;)()())&quot; Output: 4 Explanation: The longest valid parentheses substring is &quot;()()&quot; Solution Approach 1. Dynamic Programming public class Solution { public int longestValidParentheses(String s) { int maxans = 0; int dp[] = new int[s.length()]; for (int i = 1; i &lt; s.length(); i++) { if (s.charAt(i) == ')') { if (s.charAt(i - 1) == '(') { dp[i] = (i &gt;= 2 ? dp[i - 2] : 0) + 2; } else if (i - dp[i - 1] &gt; 0 &amp;&amp; s.charAt(i - dp[i - 1] - 1) == '(') { dp[i] = dp[i - 1] + ((i - dp[i - 1]) &gt;= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2; } maxans = Math.max(maxans, dp[i]); } } return maxans; } } Approach 2. Using Stack public class Solution { public int longestValidParentheses(String s) { int maxans = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(-1); for (int i = 0; i &lt; s.length(); i++) { if (s.charAt(i) == '(') { stack.push(i); } else { stack.pop(); if (stack.empty()) { stack.push(i); } else { maxans = Math.max(maxans, i - stack.peek()); } } } return maxans; } } Approach 3. Without extra space class Solution { public int longestValidParentheses(String s) { int left = 0, right = 0, maxlength = 0; for (int i = 0; i &lt; s.length(); i++) { if (s.charAt(i) == '(') { left++; } else { right++; } if (left == right) { maxlength = Math.max(maxlength, 2 * right); }else if (right &gt;= left) { left = right = 0; } } left = right = 0; for (int i = s.length() - 1; i &gt;= 0; i--) { if (s.charAt(i) == '(') { left++; } else { right++; } if (left == right) { maxlength = Math.max(maxlength, 2 * left); } else if (left &gt;= right) { left = right = 0; } } return maxlength; } } Substring with Concatenation of All WordsDescription You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example Input: s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively. The output order does not matter, returning [9,0] is fine too. Solution Code public class SubstringIndexOfAllWords { public List&lt;Integer&gt; findSubString(String s, String[] words){ List&lt;Integer&gt; indexs = new ArrayList&lt;Integer&gt;(); int n = s.length(); int num = words.length; if(n == 0 || num == 0) return indexs; int len = words[0].length(); //counts用于存储words中字符串的个数和每个字符串的个数 Map&lt;String,Integer&gt; counts = new HashMap(); for(String word : words) { counts.put(word, counts.getOrDefault(word, 0) + 1); } for(int i = 0;i &lt; n - num * len +1; i++) { Map&lt;String,Integer&gt; temp = new HashMap(); int j = 0; while(j &lt; num) { String word = s.substring(i + j * len, i + (j + 1) * len); if(counts.containsKey(word)) { temp.put(word, temp.getOrDefault(word, 0) + 1); if(temp .get(word) &gt; counts.get(word)) { break; } }else { break; } j++; } if(j == num) { indexs.add(i); } } return indexs; } }]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Sort Problem]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-Sort%20Problem%2F</url>
    <content type="text"><![CDATA[Next Permutation(31-Medium)Description Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. Example 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 Solution Code 如果一个数组中的元素从左到右成递减次序，那么就没有一个比它更大的排列，eg.5,4,3,1。 首先从数组的右边起，找到a[i]使其右边的部分不再递减。 public class NextPermutation { public void nextPermutation(int[] nums) { int i = nums.length - 2; while(i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i+1]) { i--; } if(i &gt;= 0) { int j = nums.length - 1; while(j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[i]) { j--; } swap(nums, i, j); } reverse(nums, i + 1); } public void reverse(int[] nums, int i) { int j = nums.length - 1; while(i &lt; j) { swap(nums, i, j); i++; j--; } } public void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } Time Complexity: O(n)Space Complexity: O(1)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Search Problem]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-Search%20problem%2F</url>
    <content type="text"><![CDATA[Search in Rotated Sorted Array（33-Medium）Description Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n). Example Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 Solution 利用二分查找：O(log n) class Solution { public int search(int[] nums, int target) { if(nums.length == 0) return -1; int l =0; int r = nums.length - 1; while(l &lt;= r){ int m = (l + r) / 2; if(target == nums[l]) return l; if(target == nums[m]) return m; if(target == nums[r]) return r; if(target &gt; nums[l] &amp;&amp; target &lt; nums[m]){ r = m - 1; continue; }else if(target &gt; nums[m] &amp;&amp; target &lt; nums[r]){ l = m + 1; continue; }else if(nums[l] &gt; nums[m]){ r = m -1; continue; }else if(nums[m] &gt; nums[r]){ l = m + 1; continue; } } return -1; } } 优化： public int search(int[] nums, int target) { int lo = 0, hi = nums.length - 1; while (lo &lt; hi) { int mid = (lo + hi) / 2; if ((nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid])) lo = mid + 1; else hi = mid; } return lo == hi &amp;&amp; nums[lo] == target ? lo : -1; } Find First and Last Position of Element in Sorted Array（34-Medium）Description Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] Solution 改进基本的二分查找： 在二分查找中基本的条件： 1）if(nums[mid] &gt; target) right = mid -1; 2) if(nums[mid] &lt; target) left = mid + 1; 3) if(nums[mid] = target) right = mid,找到目标值 在本题中查找first和last目标值，将分为两部分查找，先找first，再找 last。 1.Search first first的查找应该使查找范围尽量靠左，尽管数组中可能有多个target，但是应该找到最左面的 [1,3,5,5,5,5,9], target = 5 l = 1; r = 9; mid = 5(2)； mid == 5,这回应该尽量向左找，因为此时的5可能不是first，r = mid l = 1; r = mid = 5; mid = 3; mid &lt; 5,这时时基本的二分查找条件，l = mid + 1 l = r = 5, 循环结束 2. Search last 和first相反，last应该使查找范围尽量靠右 同样的例子，[1,3,5,5,5,5,9], target = 5 l = 1; r = 9; mid = 5(2)； mid == 5,这回应该尽量向右找，因为此时的5可能不是last，l = mid l = mid = 5, r = 9, mid = 5(3) mid = 5, 尽量向右找， l = mid l = mid = 5 , r = 9 , mid = 5(4) mid = 5 , 尽量向右找, l = mid l = mid = 5, r = 9, mid = 5,----? 这时出问题了，最后的范围只剩下[5,9]但是取中值的时候，mid总是等于5，跳不出循环， 我们想让mid更靠右，因为last target 更在乎它右边的值，而first更在乎它左边的值， 但是 mid = (l + r）/ 2 的公式更偏向与左边，索引在找last的时候讲中值公式更改为 mid = (l + r）/ 2 + 1 索引最后一次 mid = 9 mid &gt; 5,也就是说右边从这个值开始不会再有5了，而最后一个5在m - 1，r = m - 1 通过first, last 的差异来进行两次循环 solution 1： class Solution { public int[] searchRange(int[] nums, int target) { int[] index = {-1,-1}; if(nums.length == 0) return index; int l = 0; int r = nums.length - 1; //第一次：找到第一个目标值索引 while(l &lt; r) { int m = (l + r) / 2; if(nums[m] &lt; target) { l = m + 1; }else { r = m; } } if(nums[l] != target) { return index; }else { index[0] = l; } //第二次：找到最后一个目标值的索引 r = nums.length - 1; while(l &lt; r) { int m = (l + r) / 2 + 1; if(nums[m] &gt; target) { r = m - 1; }else { l = m; } } index[1] = r; return index; } } solution 2 class Solution { public int[] searchRange(int[] nums, int target) { int[] index = {-1,-1}; if(nums.length == 0) { return index; } int left_index = Index(nums,target,true); if(left_index == nums.length || nums[left_index] != target) { return index; }else { index[0] = left_index; } index[1] = Index(nums, target,false) - 1; return index; } public int Index(int[] nums, int target,boolean left) { int l = 0; int r = nums.length; while(l &lt; r) { int m = (l + r) / 2; if(nums[m] &gt; target || (left &amp;&amp; nums[m] == target)) { r = m; }else { l = m + 1; } } return l; } } 时间复杂度 O(log n)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Math Problem]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-Math-Problem%2F</url>
    <content type="text"><![CDATA[Palindrome Number 判断一个整数是否是回文的 方法：将这个整数的后半段反转，将它和前半段比较是否相同 特殊情况： x&lt;0 不是回文的 x是以0结尾的整数 不是回文的 public class PalindromeNumber { public boolean isPalindrome(int x) { if(x &lt; 0 || x % 10 == 0 &amp;&amp; x != 0) { return false; } int reverseNumber = 0; while(x &gt; reverseNumber) { reverseNumber = reverseNumber * 10 + x % 10; x = x / 10; } return x == reverseNumber || x== reverseNumber / 10; } }]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Linked List]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-Linked-List%2F</url>
    <content type="text"><![CDATA[Remove Nth Node From End of ListDescription Given a linked list, remove the n-th node from the end of list and return its head. Example Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Solution 方法一：两次扫描第一次扫描确定链表的长度，第二遍扫描删除指定的节点 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ //***********自己实现的方法*****************// class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode t = head; int len=0; int point=1; while(t != null) { len++; t = t.next; } if(len - n == 0) { return head.next; } t=head; while(point &lt; len-n){ t = t.next; point++; } t.next=t.next.next; return head; } } 方法优化提升首先设置一个指向head的“dumpy”结点，设置这个结点是为了简化一些特殊的情况，比如链表只有一个结点点或者要删除的节点是第一个结点。第一次扫描链表得到链表的长度L第二次扫描先指向dumpy，从开始移动到第 L-n 个结点，使第 L-n 个结点指向第 L-n+2 个结点。 public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0); dummy.next = head; int length = 0; ListNode first = head; while (first != null) { length++; first = first.next; } length -= n; first = dummy; while (length &gt; 0) { length--; first = first.next; } first.next = first.next.next; return dummy.next; } 算法分析 时间复杂度：O(L) L为链表的长度 空间复杂度：O(1) 方法二：一次扫描法一次扫描的方法是通过设置两个指针 first 和 second，首先 first 指针从开始移动 n+1 次，second 指针在起始的位置。这样使两个指针始终保持 n 个节点的距离向前移动，当 first 指针指向节点为空的时候，second 指针处在倒数第 n+1 的位置，此时可以删除目标位置的节点。 public ListNode removeNthFormEnd(ListNode head,int n) { ListNode dumpy = new ListNode(0); dumpy.next = head; ListNode first = head; ListNode second = head; for(int i=1;i&lt;n+1;i++) { first=first.next; } while(first != null) { first = first.next; second = second.next; } second.next = second.next.next; return dumpy.next; } 算法分析 时间复杂度：O(L) L为链表的长度 空间复杂度：O(1) Merge Two Sorted ListsDescription Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4 Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 Solution 方法一：迭代法/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode cur = new ListNode(0); ListNode relt = cur; while(l1!=null &amp;&amp; l2!=null) { if(l1.val &lt; l2.val) { cur.next = l1; l1 = l1.next; }else { cur.next = l2; l2 = l2.next; } cur = cur.next; } if(l1==null) cur.next=l2; if(l2==null) cur.next=l1; return relt.next; } } 方法二：递归法/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if(l1==null) return l2; if(l2==null) return l1; if(l1.val &lt; l2.val) { l1.next=mergeTwoLists(l1.next,l2); return l1; }else { l2.next=mergeTwoLists(l1,l2.next); return l2; } } } Merge k Sorted ListsDescription Merge k sorted linked lists and return it as one sorted list. Example Input: [ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6 ] Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 Solution 分而治之方法方法描述：这是一种递归的方法，思想就是将k个链表两两合并，如下图所示。 public class MergeKSortedLists { public ListNode mergeKLists(ListNode[] lists) { return merge(lists,0,lists.length-1); } private ListNode merge(ListNode[] lists,int left,int right) { if(left == right) { return lists[left]; } if(left &lt; right) { int mid = (right + left)/2; ListNode l1 = merge(lists,left,mid); ListNode l2 = merge(lists,mid+1,right); return mergeTwoLists(l1,l2); }else { return null; } } private ListNode mergeTwoLists(ListNode l1,ListNode l2) { if(l1 == null) return l2; if(l2 == null) return l1; if(l1.val &lt; l2.val) { l1.next = mergeTwoLists(l1.next,l2); return l1; }else { l2.next = mergeTwoLists(l1,l2.next); return l2; } } } 算法分析 时间复杂度：O(N*lgk),N是两个链表节点总数，lgk是分治算法递归实现的复杂度. 空间复杂度：O(1) Swap nodes in pairsDescription Given a linked list, swap every two adjacent nodes and return its head. Example Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Soution 迭代法public class SwapNodesInPairs { public ListNode swappairs(ListNode head) { if(head==null || head.next==null) return head; ListNode dumpy = head.next; while(head!=null &amp;&amp; head.next!=null) { ListNode first = head.next; ListNode second = head.next.next; first.next = head; head.next = (second==null || second.next==null) ? second : second.next; head = second; } return dumpy; } } 算法分析 时间复杂度：O(n),n为链表的长度 空间复杂度：O(1) 递归法public class SwapNodesInPairs { public ListNode swapPairs(ListNode head) { if(head==null || head.next==null) return head; ListNode first = head.next; ListNode second = head.next.next; first.next = head; head.next = swapPairs(second); return first; } } Reverse Nodes in k-GroupDescription Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Soluton /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseKGroup(ListNode head, int k) { /* if(head == null) return null; if(k == 1) return head;*/ ListNode dumpy = new ListNode(-1); dumpy.next = head; ListNode temp = head; int count = 0; while(temp!=null &amp;&amp; count!=k) { temp = temp.next; count++; } if(count == k) { temp = reverseKGroup(temp,k); ListNode pre = head; ListNode cur = head.next; while(k &gt; 1) { pre.next = cur.next; cur.next = dumpy.next; dumpy.next = cur; cur = pre.next; k--; } pre.next = temp; } return dumpy.next; } } 算法分析 时间复杂度：O(n) 空间复杂度：O(1) Reverse Linked List实现翻转链表的功能 方法一：原地翻转public class ReverseLinkedList { public ListNode reverseList(ListNode head) { //原地翻转法 if(head == null) return head; ListNode dumpy = head; ListNode pre = head; ListNode cur = head.next; while(cur != null) { pre.next = cur.next; cur.next = dumpy.next; dumpy.next = cur; cur = pre.next; } return dumpy.next; } } 方法二：建立新链表，插入式翻转public class ReverseLinkedList { public ListNode reverseList(ListNode head) { //建立新链表，添加节点翻转法 if(head == null) return head; ListNode dumpy = new ListNode(-1); ListNode cur = head; while(cur != null) { ListNode nex = cur.next; cur.next = dumpy.next; dumpy.next = cur; cur = nex; } return dumpy.next; } }]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Dynamic Programming]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-dynamic%20programming%2F</url>
    <content type="text"><![CDATA[Longest Palindromic Substring 回文字符串：正读反读都一样 方法一：暴力法 遍历所有的子字符串，判断它是不是回文字符串 class Solution { public String longestPalindrome(String s) { if(s.length()==1){ return s; } if(s.isEmpty()){ return ""; } int maxn=0; int iMin=0; //遍历每个子字符串并判断是不是回文的 for(int i=0;i&lt;s.length();i++){ for(int j=s.length()-1;j&gt;=i;j--) if(s.charAt(i)==s.charAt(j)){ if(check(s,i,j)){ if(j-i+1&gt;maxn){ maxn=j-i+1; iMin=i; } break; } } } return s.substring(iMin,maxn); } //检测一个字符串是不是回文 public boolean check(String s,int i,int j){ while(i&lt;=j){ if(s.charAt(i)!=s.charAt(j)){ return false; } i++; j--; } return true; } } 算法分析：时间复杂度O(n^3) 方法二：动态规划 暴力法时间复杂度高的原因是去检查每一个子字符串是不是回文的，降低时间复杂度就要减少对子字符串是不是回文的判断 假设一个字符串”ababa”,当我已经确认了”bab”是回文字符串，由于它左右两边的字符都是a，那么这个完整的字符串本身就是回文的，就可以不用对整个字符串再进行完整的判断。 假设一个字符串的长度为n，那么建立一个n*n数组P。在矩阵中P[i][j]=l，若l&gt;0：表示以字符S[i]开始和以S[j]结尾的字符串是回文字符串，字符串的长度为l;若l=0，表示此字符串不是回文字符串 只需要对矩阵中j&gt;=i的部分赋值即可，就j&lt;i部分为0； 1.一个字符的情况：将矩阵的对角线赋值为1，因为每个字符本身是回文的 2.两个字符的情况：j-i=1 P[i][j]=2,if S[i]=S[j] 3.多个字符的情况：j-i&gt;=2 if S[i]!=S[j] P[i][j]=0; if S[i]=S[j] if P[i+1][j-1]&gt;0 P[i][j]=p[i+1][j-1]+2; else P[i][j]=0; 字符串有多个字符组成时，如果两边的字符相等，那么这个字符串可能是回文的，这时将字符串去掉首末字符得到子字符串，如果子字符串回文的，那么这个字符串也是回文的。 public static String longestPalindrome(String s){ if(s.length()==0){ return ""; } if(s.length()==1){ return s; } int[][] p=new int[s.length()][s.length()]; int indexMin=0,maxn=1; //初始化二维数组P for(int i=0;i&lt;s.length();i++){ for(int j=0;j&lt;s.length();j++){ if(i==j) p[i][j]=1; } } for(int j=0;j&lt;s.length();j++){ for(int i=j-1;i&gt;=0;i--){ if(s.charAt(i)==s.charAt(j)){ if(j-i==1){ p[i][j]=2; } if(j-i&gt;=2){ if(p[i+1][j-1]&gt;0){ p[i][j]=p[i+1][j-1]+2; }else{ p[i][j]=0; } } }else{ p[i][j]=0; } if(p[i][j]&gt;maxn){ maxn=p[i][j]; indexMin=i; } } } return s.substring(indexMin, indexMin+maxn); } 算法分析： 时间复杂度：O(n^2) 空间复杂度：O(n^2),需要一个n*n的矩阵来存储数据 方法三：Expand Around Center 对于动态规划算法时间复杂度为O(n^2)，空间复杂度为O(n^2)，可以进一步优化只用O(1)的空间实现O(n^2)的时间复杂度 一个回文字符串它是成中心对称的，比如”baab”,”bab”,但是回文字符串分为两种：奇数字符数，偶数字符数 class Solution { public String longestPalindrome(String s) { if(s.length()==0){ return ""; } if(s.length()==1){ return s; } int indexMin=0,maxn=1; for(int i=0;i&lt;s.length();i++){ int len1=expandAroundCenter(s,i,i); int len2=expandAroundCenter(s,i,i+1); int len=Math.max(len1,len2); if(len&gt;maxn){ indexMin=i-(len-1)/2; maxn=len; } } return s.substring(indexMin,indexMin+maxn); } private int expandAroundCenter(String s,int L,int R){ while(L&gt;=0 &amp;&amp; R&lt;s.length() &amp;&amp; s.charAt(L)==s.charAt(R)){ L--; R++; } return R-L-1; } } 算法分析 时间复杂度：O(n^2) 空间复杂苏：O(1) 方法四：最长公共字符串** 将字符串S翻转为S’,检查S和S’的最长公共字符串就是S的最长回文子字符串此方法中存在一种问题，就是当字符串中某一个子串存在一个镜像子串本身并不是回文的，翻转之后会被检测为回文的。 下面是一种基于动态规划的求解最长公共字符串的方法。 Longest Common Substring 最长公共子字符串 动态规划问题 问题：因为有重叠子问题，当前计算的过程中可能有的问题在之前的计算已经计算过了，现在又要计算一遍，导致大量重复的计算 动态规划的解决方法：动态规划通过找到解决问题的递推关系，将已经完成计算的存储起来，当开始新的计算时如果包含之前计算的子问题时，不需要再次计算，只需要访问已经存储的计算结果就可以 动态规划解决问题的方法一般减少了时间复杂度，增加了存储空间。 动态规划问题的两个特点： 最优子结构 重叠子问题 对于这个问题，假设有两个字符串s[0,...m],t[0,...,n],求两个字符串的最长公共子字符串 定义矩阵mXn的矩阵L,L[i][j]表示以s[i]开始和t[j]结尾的公共子字符串长度的最大值，那么对于L[i+1][j+1]只是比L[i][j]增加了s[i+1]和t[j+1] 因此可以构造出最长公共子字符串的递归式： if s[i]==t[j] L[i][j]=L[i-1][j-1]+1 if s[i]!=t[j] L[i][j]=0 假设有两个字符串：”ABAB”和”BABA” ,构造出了上述的矩阵代码实现 public static String LCS(String s1,String s2){ if(s1.isEmpty() || s2.isEmpty()){ return ""; } int indexMax=0,maxn=0; int[][] L=new int[s1.length()][s2.length()]; for(int i=0;i&lt;s1.length();i++){ for(int j=0;j&lt;s2.length();j++){ if(s1.charAt(i)==s2.charAt(j)){ if(i==0 || j==0){ L[i][j]=1; }else{ L[i][j]=L[i-1][j-1]+1; } } if(L[i][j]&gt;maxn){ maxn=L[i][j]; indexMax=i; } } } return s1.substring(indexMax+1-maxn, indexMax+1); } 算法分析： 时间复杂度：O(mn) 空间复杂度：O(mn) 算法优化从上面动态查找最长公共子字符串的过程中发现，在循环查找的过程中只会用到矩阵L中的两行，即正在计算的一行和完成计算的上一行，之前计算的和带计算的都用不到，所以只需要维护两行数据就足够了，不需要使用mxn的数组 代码实现： public class LCS_improve { public static String LCS_improve(String s1,String s2){ if(s1.isEmpty() || s2.isEmpty()){ return ""; } int indexMax=0,maxn=0; int [][] L=new int[2][s1.length()]; for(int i=0;i&lt;s1.length();i++){ int cur=(i+2)%2; int pre=(i+1)%2; for(int j=0;j&lt;s2.length();j++){ if(s1.charAt(i)==s2.charAt(j)){ if(i==0 || j==0){ L[cur][j]=1; }else{ L[cur][j]=L[pre][j-1]+1; } }else{ L[cur][j]=0; } if(L[cur][j]&gt;maxn){ maxn=L[cur][j]; indexMax=i; } } } return s1.substring(indexMax+1-maxn, indexMax+1); } } 算法分析： 时间复杂度：O(mn) 空间复杂度：O(min(m,n))]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Array Problem]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-Array-Problem%2F</url>
    <content type="text"><![CDATA[Two SumDescription Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Solution 方法一：暴力遍历12345678910111213public int[] twoSum(int[] nums, int target) &#123; int[] res=new int[2]; int n=0; for(int i=0;i&lt;nums.length-1;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums[i]+nums[j]==target)&#123; res[n++]=i; res[n++]=j; &#125; &#125; &#125; return res; &#125; 时间复杂度：O(n^2) 方法二： 利用哈希表12345678910111213public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123; return new int[] &#123; i, map.get(complement) &#125;; &#125; &#125; throw new IllegalArgumentException("No two sum solution");&#125; 时间复杂度：O(n)空间复杂度：O(n) 方法三：对方法二的改进1234567891011public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException("No two sum solution");&#125; 时间复杂度：O(n)空间复杂度：O(n) 3SumDescription Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note The solution set must not contain duplicate triplets Example Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is:[ [-1, 0, 1], [-1, -1, 2]] Solution1234567891011121314151617181920212223242526272829public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums)&#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList(); Arrays.sort(nums); for(int i=0;i&lt;nums.length;i++) &#123; if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) &#123; continue; &#125; int left=i+1; int right=nums.length-1; while(left&lt;right) &#123; if(nums[i]+nums[left]+nums[right]==0) &#123; list.add(Arrays.asList(nums[i],nums[left],nums[right])); left++; right--; while(left&lt;right &amp;&amp; left&gt;0 &amp;&amp; nums[left]==nums[left-1]) &#123; left++; &#125; while(left&lt;right &amp;&amp; right&lt;nums.length-1 &amp;&amp; nums[right]==nums[right+1]) &#123; right--; &#125; &#125;else if(nums[i]+nums[left]+nums[right]&lt;0) &#123; left++; &#125;else &#123; right--; &#125; &#125; &#125; return list;&#125; 时间复杂度：O(n^2) 3Sum ClosestDescription Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Solution解法思路类似于3Sum123456789101112131415161718192021222324252627public int threeSumClosest(int[] nums,int target) &#123; int sum=0,cox=Integer.MAX_VALUE; int[] rest = new int[3]; Arrays.sort(nums); for(int i=0;i&lt;nums.length;i++) &#123; int l=i+1; int r=nums.length-1; while(l&lt;r) &#123; sum=nums[i]+nums[l]+nums[r]; int temp=Math.abs(target-sum); if(temp&lt;cox) &#123; cox=temp; rest[0]=nums[i]; rest[1]=nums[l]; rest[2]=nums[r]; &#125; if(sum==target) &#123; return sum; &#125;else if(sum&lt;target) &#123; l++; &#125;else &#123; r--; &#125; &#125; &#125; return rest[0]+rest[1]+rest[2]; &#125; 时间复杂度O(n^2) 4SumSolution12345678910111213141516171819202122232425262728293031323334353637public class FourSum &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums,int target)&#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList(); Arrays.sort(nums); for(int i=0;i&lt;nums.length;i++) &#123; if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) &#123; continue; &#125; for(int j=i+1;j&lt;nums.length;j++) &#123; if(j&gt;i+1 &amp;&amp; nums[j]==nums[j-1]) &#123; continue; &#125; int l=j+1; int r=nums.length-1; while(l&lt;r) &#123; int sum=nums[i]+nums[j]+nums[l]+nums[r]; if(sum == target) &#123; list.add(Arrays.asList(nums[i],nums[j],nums[l],nums[r])); l++; r--; while(l&lt;r &amp;&amp; l&gt;0 &amp;&amp; nums[l] == nums[l-1]) &#123; l++; &#125; while(l &lt; r &amp;&amp; r &lt; nums.length &amp;&amp; nums[r] == nums[r+1]) &#123; r--; &#125; &#125;else if(sum &gt; target)&#123; r--; &#125;else &#123; l++; &#125; &#125; &#125; &#125; return list; &#125;&#125; 时间复杂度：O(n^3) Median of Two Sorted ArraysDescription There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays.The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty. Example nums1 = [1, 3] nums2 = [2] median is 2.0 Solution class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int m=nums1.length; int n=nums2.length; if(m&gt;n){ int[] temp=nums1;nums1=nums2;nums2=temp; int tmp=m;m=n;n=tmp; } int iMin=0,iMax=m,hl=(m+n+1)/2; while(iMin&lt;=iMax){ int i=(iMin+iMax)/2; int j=hl-i; if(i&lt;iMax &amp;&amp; nums2[j-1]&gt;nums1[i]){ iMin=i+1; }else if(i&gt;iMin &amp;&amp; nums1[i-1]&gt;nums2[j]){ iMax=i-1; }else{ int maxLeft=0; if(i==0){ maxLeft=nums2[j-1]; }else if(j==0){ maxLeft=nums1[i-1]; }else{ maxLeft=Math.max(nums1[i-1],nums2[j-1]); } if((m+n)%2==1){ return maxLeft; } int minRight=0; if(i==m){ minRight=nums2[j]; }else if(j==n){ minRight=nums1[i]; }else{ minRight=Math.min(nums1[i],nums2[j]); } return (maxLeft+minRight)/2.0; } } return 0.0; } }]]></content>
      <categories>
        <category>Leetcode, Algorithms</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想-面向对象（基础）]]></title>
    <url>%2F2019%2F08%2F16%2FJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、关键字this关键字this关键字在方法内部使用，表示对“调用方法的那个对象”的引用，如果在方法内调用同一个类的另一个方法可以不使用this super关键字 this &amp;&amp; super A:this本类的引用，super代表父类存储空间的标识（看成对父类的引用） B:this.变量 ，super.变量 -----引用变量 this(.....) ，uper(.....) -----调用构造方法 this.成员方法 ，super.成员方法 -----调用成员方法 static关键字static的特点：1.类中static关键字修饰的变量（静态变量）被类的所有对象共享 class Static{ static int i=47; } 即使创建多个对象也共享同一个变量i： Static st1=new Static(); Static st2=new Static(); st1.i和st2.i指向同一个存储空间地址，有相同的值，也可以通过Static.i引用变量 2.类中static修饰的方法可以在不创建方法的前提下直接调用static修饰的方法不与包含它的类的任何对象关联在一起，不用创建对象通过类本身调用，这是static方法的主要用途 class Static{ public static void increment(){ Static.i++; } } 定义了一个静态方法，通过类直接调用：Static.increment() 3.静态是随着类的加载而加载,与对象无关 4.static方法没有this关键字 5.static方法不能调用非静态方法，反过来可以 6.所有构造方法都默认被static修饰 final关键字1.修饰数据声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量 final修饰基本类型（整型，浮点，字符等），表示一个常量，赋值后不可以改变 final修饰引用类型（类，接口，数组），final使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的 2.修饰方法 final修饰的方法不能被重写（private方法也不可重写） private方法隐式地被指定为final，如果在子类中定义的方法和基类中的一个private方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法 3.修饰类 final修饰的类不可以被继承 成员变量和局部变量 局部变量：在方法外---在栈内存 （变量没有默认初始值）---随之对象的创建产生，随着对象的消失 成员变量： 在方法内---在堆内存 （变量有默认初始值）--随着方法的调用产生 二、继承 java中继承的特点： A: 只支持单继承，不支持多继承 B: 支持多层继承 class A{} class B extends A{} class C extends B{} 注意事项 A:子类只能继承父类中非私有的成员（成员变量和成员方法） B:子类不能继承父类的构造方法，但可以通过super关键字去访问父类构造方法 1.访问权限包访问权限（friendly） ：默认的访问权限通常是包访问权限，当前包中所有其他类可以访问那个成员，对于这个包之外的所有类是privatepublic：公共的，谁都可以访问protected：继承访问权限private：私有的，除了包含该成员的类之外其他类无法访问！注意：a.类不可以用private，protected修饰，只可以是包访问权限和publicb.如果类的构造方法由private修饰，则无法创建该类的对象，从而禁止拥有该类的访问权限，但是任然可以调用访问该类中static修饰的成员 2.类间的关系组合 class Actor{ public void act() {} } class HappyActor{ public void act(){ print(&quot;HappyActor&quot;); } class SadActor{ public void act(){ print(&quot;SadActor&quot;); } } class Stage{ privat Actor actor=new HappyActor(); public void change(){ actor=new SadActor(); } public void perform(){ actor.act(); } } 继承代理 3.重写和重载 重写（Override） 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。 为了满足里式替换原则，重写有有以下两个限制： 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型。 使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。 重载（Overload） 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。 应该注意的是，返回值不同，其它都相同不算是重载。 三、多态1.多态的前提要有继承关系，要有方法重写，要有父类引用指向子类对象（父类 F = new 子类()) class fu{ public fu(){ } public void show(){ System.out.println(&quot;fu&quot;); } } class zi extends fu{ public void show(){ System.out.println(&quot;show zi&quot;); } public void method(){ Sysltem.out.println(&quot;method zi&quot;); } } class DuotaiDemo{ public static void main(String[] args){ fu f = new zi(); f.show(); } } 2.多态中成员访问特点 A:成员变量—编译看左边，运行看左边 B:构造方法—创建子类对象时，访问父类的构造方法，对父类的数据进行初始化 C:成员方法—编译看左边，运行看右边（因为有成员方法重写，所以调用子类） D:静态方法—编译看左边，运行看左边（静态只和类有关） 多态好处 ：提高了代码的维护性（继承）、扩展性（多态）弊端 ：不能使用子类的特有功能 对象间的转型:向下转型 父-&gt;子 zi z = (zi)f向上转型 子-&gt;父 fu f = new zi() 四、接口1.抽象类和抽象方法抽象类和抽象方法必须用abstract修饰 格式： abstract class 类名 {} public abstract void 方法名(); 特点： 抽样类中不一定有抽样方法，但是有抽样方法的类一定要定义成抽类 抽样类不能实例化，抽象类有构造方法，但不可以实例化，构造方法是给子类调用的 抽象类的子类：如果不想重写抽样方法，子类是一个抽样类，如果想重写抽样方法，子类是一个具体的类 成员特点： 成员变量：既可以是常量，也可以是变量 构造方法：有，用于子类访问父类数据初始化 成员方法：既可以是抽象的，也可以是非抽象的，成员方法是抽象的，子类必须得重写，成员方法是非抽象的，子类继承 2.接口interface产生一个完全抽象的类，此类没有提供任何相应的具体实现，它允许确定方法名、参数列表、和返回类型，但是没有任何方法体。 接口只提供了形式，而未提供任何具体实现 接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected 接口的字段默认都是 static 和 final 的 A.接口成员特点：成员变量：只能是常量，是静态的，默认修饰符 public static final构造方法：没有（所有类都默认继承object类）成员方法：只能是抽象方法，默认修饰符public B.比较 从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 C.使用选择 使用接口：a.需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；b.需要使用多重继承；c.创建不带任何方法定义和成员变量的基类； 使用抽象类：a.需要在几个相关的类中共享代码；b.需要能控制继承来的成员的访问权限，而不是都为 public；c.需要继承非静态和非常量字段； 在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低 D.关系类和类：继承关系，只能单继承，多层继承类和接口：实现关系，可以单实现也可以多实现，可以在继承一个类的同时实现多个接口接口和接口：继承关系，可以单继承，也可多继承 五、内部类匿名内部类内部类的简写前提：存在一个类和接口类名或接口 格式： new名 () { 方法重写; };本质是一个继承了该类或实现了接口的子类匿名对象 六、字符串String主要方法构造方法 public String() 空构造 public String(byte[] bytes) 把字节数组转换成字符串 public String(byte[] bytes,int offset,int length) 把字节数组一部分转换成字符串 public String(char[] value) 把字符数组转换成字符串 public String(char[] value,int offset,int count) 把字符数组一部分转换成字符串 public String(String original) eg. String s = new String(参数) 成员方法 **判断功能** public boolean equals(Object anObject) 比较字符串的内容是否相同 public boolean equalsIgnoreCase(String str) 比较字符串的内容是否相同，忽略大小写 public boolean contens(String str) 大的字符串是否包含小串 public boolean startsWith(String str) 判断字符串是否以某个特定的字符串开头 public boolean endsWith(String str) 判断字符串是否以某个特定的字符串结尾 public boolean isEmpty() 判断字符串是否为空 **获取功能** public int length() 获取字符串长度 public char charAt(int index) 返回索引处的字符 public int indexOf(int ch) 返回指定字符第一次出现的字符串内的索引 public int indexOf(String str) 返回指定子字符串第一次出现的字符串内的索引。 public int indexOf(int ch,int fromIndex) 返回指定字符第一次出现的字符串内的索引，以指定的索引开始搜索 public int indexOf(String str,int fromIndex) 返回指定子串的第一次出现的字符串中的索引，从指定的索引开始 public String substring(int beginIndex) 返回一个字符串，该字符串是此字符串的子字符串。 子字符串以指定索引处的字符开头，并扩展到该字符串的末尾 public String substring(int beginIndex,int endIndex) 返回一个字符串，该字符串是此字符串的子字符串，子串开始于指定beginIndex并延伸到字符索引endIndex - 1 **转换功能** public byte[] getBytes() 把字符串换换为字节数组 public toCharArray() 把字符串转换为字符数组 public static String valueof(char[] chs) 字符数组转化成字符串 public static String valueof(int i) 把int转化成字符串 public String toLowerCase() 字符串变小写 public String toUpperCase() 字符串变小写 public String concat(String str) 字符串拼接 **替换功能** public String replace(char old,char new); public String replace(String old,String new); **去除字符串开头结尾两个空格** public String trim(); **按字典顺序比较两个字符串** public int compareTo(String str); public int compareToIgnorceCase(String str); String, StringBuffer and StringBuilder 可变性String 不可变StringBuffer 和 StringBuilder 可变 线程安全String 不可变，因此是线程安全的StringBuilder 不是线程安全的StringBuffer 是线程安全的，内部使用 synchronized 进行同步 类型转换String和StringBuffer相互转换 String s = new String() A:StringBuffer sb = new StringBuffer(s) B:StringBuffer sd2 = new StringBuffer() sb2.append(s) StringBuffer sb = new Stringbuffer(&quot;java&quot;) A:String str = new String(sb) B:String str2 = sb.toString() String和int int a=100; String s2=String.valueOf(a); System.out.println(s2); String s =&quot;100&quot;; int y=Integer.parseInt(s); System.out.println(y); * 把int转化为String 1. String s=&quot;&quot;+i; 2. String s=Integer.toString(i); 3. String s=String.valueOf(i); * 把String转化为int型 1. int i=Integer.parsenInt(s); 2. int i=Integer.valueOf(s).intValue(); * 把String转化为Integer * Integer integer=Integer.valueOf(i) * 把Integer转化为int * int num=Integer.intValue()；]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-Logistic回归]]></title>
    <url>%2F2019%2F02%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Logistic%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[Logistic回归-模型原理及梯度下降算法1. Logistc回归模型回归：用一条直线对给定数据进行拟合(最佳拟合直线) Logistic 回归：根据现有数据对分类边界建立回归方程，以此直线进行分类 给定数据集 \( [(x_{1},y_{1}),(x_{2},y_{2}),…,(x_{m},y_{m})] \) ，每个样本 x 有 d 个属性 \( x=[x_{1},x_{2},…,x_{d}] \) 。 对于给定数据集，该数据集的线性拟合公式为： $$ f(x) = w_{0}x_{0}+w_{1}x_{1}+w_{2}x_{2}+…+w_{d}x_{d} $$ $$ f(x) = w^{T}x $$ 其中 \( w^{T}=[w_{0}，w_{1},w_{2},…,w_{d}] \) 若要进行分类任务(以二分类为例)，需要找到一个单调可微的函数将分类任务的真实标记 y 和线性回归模型的预测值关联起来。 分类输出标记 y = {0 ， 1} ， 回归模型的预测值 \( z = w^{T}x \) ， 因此需要一个函数将 z 转化为 0 / 1 值。 最理想的函数是 “ 单位阶跃函数 ”，但是这个函数是不连续的函数，它的跳跃点从0到1的跳跃过程很难处理。需要一个近似单位阶跃的函数，更容易处理且单调可微，这就是 “ 对几率函数(logistic function) ” 函数 ,它是“Sigmoid函数”的一种 。 $$ y_{w}(x) = \frac{1}{1+z^{-1} }= \frac{1}{1+(w^{T}x)^{-1}} $$ $$ y = \begin{cases}1 &amp; \text{ if } z&gt;0 \0.5 &amp; \text{ if } z=0 \0 &amp; \text{ if } z&lt;0\end{cases} $$ 对下式取对数： $$ y = \frac{1}{ 1 + e^{-(w^{T}x+b)} }$$ $$ ln\frac{y}{1-y}=w^{T}x+b $$ 将上式中y作为样本为正例的可能性，1-y表示样本为负例的可能性，两者的比值 y/1-y 称为“几率”(odds),表示样本是正例的相对可能性，对“几率”取对数得到 ln(y/1-y) 称为“对数几率”(log odds/logit)。由此可见Logistic回归实际是在用线性回归模型的预测结果去逼近真实标记的对数几率。 我们将 ln(y/1-y)中的y视为类后验概率 P( y = 1 | x ）于是将 对几率函数重写为 $$ ln\frac{p(y=1|x)}{p(y=0|x)}=w^{T}x+b $$ 在Logistic回归中，输出y=1的对数几率是输入x的线性函数，于是得到二项Logistic回归模型的条件概率： $$ p(y=1|x)=\frac{e^{w^{T}+b}}{1+e^{w^{T}+b}} $$ $$ p(y=0|x)=\frac{1}{1+e^{w^{T}+b}} $$ 对于任意给定的样本x，按照上两是计算得到 p(y=1|x) 和 P(y=0|x),比较两个条件概率的大小，将x分到概率较大的那一类。 考虑对样本进行分类的线性函数 \( w^{T}+b \)，它的值域为实数域，通过Logistic回归条件概率将线性函数转化成概率，线性函数的值越接近正无穷，概率值就越接近1;线性函数值越接近负无穷，概率值就越接近0，这就是对几率函数的性质，这样的模型就是Logistic回归。 Logistic Regression虽然名字是回归，但它是一种分类学习算法，它的优点是分类时直接对分类可能性直接建模，无需事先假设数据分布，避免了假设分布不准确带来的问题；它不是仅预测出类别，而是类别的近似概率预测，这对很多需要概率辅助的分类任务很有用；对率函数是任意可导的凸函数，有很好的的数学性质，现有的很多数值优化算法都可直接用于求解最优解。 2. 模型参数估计确定了分类器的函数形式，最终的问题就是如何确定最佳回归参数，向量 w 就是回归参数 ，使用极大似然估计来估计参数模型 w 和 b。 给定数据集 \( [(x_{1},y_{1}),(x_{2},y_{2}),…,(x_{m},y_{m})] \)，将权值向量和特征向量扩充，仍记为w，x。 $$ w = (w^{1},w^{2},…,w^{d},b) $$ $$ x = (x^{1},x^{2},…,x^{d},1) $$ 设 ： \( p_{1}(x;w)=p(y=1|x;w) \), \( p_{0}(x;w)=p(y=0|x;w) \) 似然函数为： $$ \prod_{i=0}^{m}p(x_{i};w)^{y_{i}}[1-p(x_{i};w)]^{1-y_{i}} $$ 对数似然函数为： $$ Ln(w) = \sum_{i=0}^{m}[y_{i}log(p(x_{i};w))+(1-y_{i})log(1-p(x_{i};w))]=\sum_{i=0}^{m}[y_{i}log(\frac{p(x_{i};w)}{1-p(x_{i};w)})+log(1-p(x_{i};w))]=\sum_{i=0}^{m}[y_{i}(w^{T}x)-log(1+e^{w^{T}x})] $$ 对Ln(w)求极大值，可以得到w的估计值。问题变成了对似然函数的最优化问题，Logistic回归常用的方法是梯度下降法和拟牛顿法。 3. 误差评估在logistic回归中明确了分类预测函数，其中\( z = w^{T}x \)是分类边界，即决策边界就是划分样本类别的边界，可以是点，可以是线，可以是面，“决策边界是预测分类函数的 \( y_{w}(x) \)的属性，不是训练集的属性，因为能够划分类别界限的是\( y_{w}(x) \)，而训练集是用来训练调节参数” 在前面确定了 logistic regression的分类原理和方法，接下来要要评估分类效果，即评估\( y_{i} \) 和 \( f(x_{i}) \) 之间的误差，通过均方误差来描述误差,误差评估的函数又称为代价函数，均方误差是回归任务中常用的度量标准： $$ J(w)=\frac{1}{2m}\sum_{i=1}^{m}(f(x_{i})-y_{i})^{2} $$ 我们的目标就是通过调节参数 w 使 J(w)能够达到最小， 4. 优化算法-梯度下降法Gradient Descent训练学习的目标就是不断调节参数w来使J(w)达到最小，通常使用梯度下降方法来调节w： $$w_{j}=w_{j}-\alpha \frac{\partial }{\partial w}J(w)$$ 梯度方向是函数值下降最为剧烈的方向。那么，沿着 J(w) 的梯度方向走，我们就能接近其最小值，或者极小值，从而接近更高的预测精度。学习率 α 是个相当玄乎的参数，其标识了沿梯度方向行进的速率，步子大了，很可能这一步就迈过了最小值。而步子小了，又会减缓我们找到最小值的速率。在实际编程中，学习率可以以 3 倍，10 倍这样进行取值尝试：α=0.001,0.003,0.01…0.3,1 4.1 批量梯度下降法(Batch Gradient Descent)对一个大小为m的训练集，w的迭代过程如下，重复迭代直到收敛： $$w_{j}=w_{j}+\alpha \frac{1}{m}\sum_{i=1}^{m}(y_{i}-f(x_{i}))x_{j}^{i}$$ 矩阵表示如下： $$w_{j}=w_{j}+\alpha \frac{1}{m}(y-f(x))^{T}x_{j}$$ 这种方法是批量梯度下降法，每次更新一次系数就要完整遍历一次数据集，如果训练集体积巨大，那么计算的复杂度太高。 4.2 随机梯度下降法(Stochastic Gradient Descent)由于批量梯度下降法计算开销太大，一种改进方法是一次仅用一个样本点来更新回归系数，该方法称为随机梯度下降算法。由于可以在新样本到来时对分类器进行增量式更新，因而随机梯度下降算法是一个在线学习算法。与“在线学习”相对应，一次处理所有数据被称作是“批处理”。 重复迭代直至收敛：for i = 1 to m$$ w_{j}=w_{j}+\alpha \frac{1}{m}(y_{i}-f(x_{i}))x_{j}^{i} $$]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-贝叶斯分类器]]></title>
    <url>%2F2019%2F01%2F24%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一. 概率知识 先验概率：先验概率（prior probability）是指根据以往经验和分析得到的概率 后验概率：后验概率,事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小后验概率就是条件概率 p(c|x) = p(x|c)p(c)/p(x) 贝叶斯概率引入先验知识和逻辑推理来处理不确定的命题 事情还没有发生，要求这件事情发生的可能性的大小，是先验概率。事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小，是后验概率。 先验概率的计算比较简单，没有使用贝叶斯公式；而后验概率的计算，要使用贝叶斯公式，而且在利用样本资料计算逻辑概率时，还要使用理论概率分布，需要更多的数理统计知识 二. 贝叶斯分类器基本原理1. 贝叶斯判定准则假设训练集为 T = {(x1,y1),(x2,y2),....,(xN,yN)}, 有 K 中标记类型，标记集 y = {c1,c1,...,cK} 定义损失函数 L(Y=ck,f(x)) 为将样本 x 分类错误所产生的损失 基于后验概率可以得到将样本 x 分类为 ci 产生的期望损失，即在样本x上的‘条件风险’ 注：期望损失也称为风险 对于分类准则f(x),总体风险为： 我们的任务就是找到一个分类准则使总体风险最小化。如果对于每个样本 x ，若f(x)能最小化条件风险 R(f(x)|x) ,则总体风险 R(f) 也将最小化。 贝叶斯判定准则： 为了最小化总体风险，只需在每个样本上选择那个能使条件风险R(c|x)最小的类别标记 上式为最小分类错误的贝叶斯最优分类器，即对每个样本x，选择能使后验概率 P(c | x)最大的类别标记，所以期望风险最小化准则就是后验概率最大化准则 2. 朴素贝叶斯2.1 朴素贝叶斯的原理经过上面的分析我们得到要想设计最优的贝叶斯判定准则来最小化决策风险，首先要获得的就是后验概率 P(c| x)。 由贝叶斯定理可以得到后验概率的计算公式： P( c ) 是先验该概率，P(x | c)是样本 x 相对于类标记 c 的条件概率，或称为似然概率 先验概率p(c)表示样本空间中各类样本所占的比例 类条件概率p(x | c)是样本x所有属性的联合概率，难以从有限的训练样本中直接估计得到，为了避开这个障碍简化问题，朴素贝叶斯法做了‘ 属性条件独立的 ’的假设，即对已知类别，假设所有属性相互独立。 这就是朴素贝叶斯的由来，朴素贝叶斯分类器中的’ 朴素 ‘的含义是： 所有属性特征相互独立同等重要。如果属性之间不相互独立就是贝叶斯网，一种经典的概率图模型。 有朴素贝叶斯分类器的的属性相互独立的假设条件可以将后验概率公式变为如下： 由于对于所有类别来说 P(x) 相同，因此可以得到贝叶斯判定准则如下，xi 为样本 x 第 i 个属性的值： 这就是朴素贝叶斯分类器的表达式。 所以朴素贝叶斯分类器学习的关键是如何求解 P(c) 和 P(x | c) 2.2 极大似然估计法 初学，目前还没有搞懂，先占个坑吧！ 在朴素贝叶斯算法中，分类器的训练学习意味着估计 P(c) 和 P(xi | c) ,可以使用极大似然估计法估计响应的概率，先验概率和条件概率的极大似然估计如下： 2.3 朴素贝叶斯分类算法朴素贝叶斯分类器的训练过程就是基于训练集来估计类先验概率 P(c) , 和每个属性的条件概率 P(xi | c) 算法实例 注：算法和实例图来自于《统计学方法》 2.5 贝叶斯估计实现算法中可能出现的问题 下溢出问题 训练朴素贝叶斯分类器之后，当有新样本时，会计算样本属于某个类别的概率 P(i) = P(ci) P(w0 | ci) P(w1 | ci) ... P(wk | ci) 在计算概率是由于太多很小的数相乘，程序会下溢出或者得不到正确答案(比如python程序在乘法中得到非常小的输时会四舍五入) 一种解决方法是对上面的乘法计算公式取对数将乘法转化为加法，ln(a*b) = ln(a) + ln(b),通过对数避免下溢出或四舍五入，采用对数进行处理不会有任何损失，不会影响最终结果(因为算法最后是通过比较各个类别概率大小决定样本的类别，而不是返回概率本身) 训练集中特征不存在，概率为零 在计算条件概率时，如果某个属性在训练集中没有和某个类同事出现，那么这个条件概率就为0，这样在最后计算样本属于该类的概率时不管其他属性如何，这个概率都为零，为了避免其他属性携带的信息被训练集中未出现的属性抹去，通常要进行“平滑”，常用拉普拉斯平滑。 贝叶斯估计 用极大似然估计会出现所要计算的概率为0的情况，会影响到后验概率的计算进而影响最终的判定结果，使分类产生偏差。解决这一问题的方法是使用贝叶斯估计代替极大似然估计，下面公式是先验概率和条件概率的贝叶斯估计： λ ≧ 0 ，当 λ = 0 时，就是最大似然估计；当 λ = 1 时， 就是拉普拉斯平滑 2.5 朴素贝叶斯分类器的实现方式 基于高斯分布模型 GuassianNB:高斯朴素贝叶斯算法是基于假设特征服从高斯分布 基于贝努利模型 MultinomialNB:用于实现服从多项式分布数据的朴素贝叶斯算法，常用于文本分类(文本数据经常用词向量来表示) 基于多项式模型 BernoulliNB:用于实现服从多变量贝努利分布数据的朴素贝叶斯算法，这种算法要求样本表示成二进制特征向量]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-模型评估与选择]]></title>
    <url>%2F2019%2F01%2F16%2F%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[模型评估与选择一.误差与过拟合分类器分类错误的样本数占样本总数的比例为错误率(errorate)，E=m/n(m为分类错误的总样本数，n为总样本数），分类的精度(accuracy) P=(1-E)x100% 学习器实际预测值和样本真实值之间的差异为“误差” 训练误差/经验误差：学习器在训练数据上的误差 泛华误差：学习器在新样本上的误差 我们希望得到的是泛化误差尽可能小的学习器，在通过训练数据训练学习器的过程中是在尽可能的最小化训练误差。有时学习器的训练误差非常小，但当遇到新的样本时表现的却不好。因此为了的当泛华能力比较强的学习器，只能让学习器从训练样本中学习到尽可能适应所有样本的普遍规律，要尽可能的学习所有训练样本的共性，这样学习器在遇到引得样本时才会做出正确的判断。通过训练数据训练出的学习器会有两个问题： 过拟合:学习器学习能力过于强大把训练数据学习的太好了，可能把训练样本自身的特点当做了所有样本的一般性质，导致过拟合，是学习器的泛化能力降低。过拟合无法避免，只能尽量减小。 欠拟合：和过拟合相对应，有学习器学习能力过低，对训练样本的一般性质没有学好，欠拟合容易克服，关键的问题是过拟合 二.模型评估和选择方法不同的机器学习算法，同一算法的不同参数配置都是不同的模型，机器学习的模型选择就是对模型的泛化误差进行评估选择泛化误差最小的模型。 通过训练数据得到的学习器，将学习器在在测试数据上的测试误差作为学习器的泛华误差。 训练集与测试集要有如下关系：训练集和测试集都是从样本真实分布中独立同分布采样而得，他们应该尽可能互斥，测试样本尽量不出现在训练样本中。 假设包含m个样例的样本集D={(x1,y1),(x2,y2),...,(xm,ym)},如何划分训练集和测试集的常用方法如下： 留出法直接将样本集D划分为两个互斥的集合D= S U T,S作为训练集，T作为测试集估计分类器的泛化误差。 训练集和测试集的划分要保持数据分布的一致性，避免数据划分引入偏差影响结果。比如在分类任务中要保持两个集合中样本的类别别比例相似。 在使用留出法时不同的划分会得到不同的模型，单次留出法得到的结果往往不够稳定可靠，一般采用若干次留出法随机划分，重复试验评估后取平均值作为留出法的评估结果。并且常将样本集的2/3 ~ 4/5的样本用于训练，剩余的用于测试。 交叉验证法 将样本集D划分为k个大小相似的互斥子集，D=D1 U D2 U…U Dk,每个子集尽可能保持数据分布的一致性， 每次使用k-1个子集的并集作为训练集，剩余的一个子集作为测试集， 这样可以得到k组训练/测试集，进行k次实验，得到的是k次测试结果的均值 交叉验证法评估结果的稳定性很大程度取决于k的取值，因此也称为“k折交叉”验证，k常取10，其他常用值为5，20等。 交叉验证法的特例：留一法(LOO)，k=m 留一法的优点：留一法不受随机样本划分方式的影响，因为m个样本只有唯一的方式划分为m个子集，每个子集一个样本，在多数情况下，留一法中被实际评估的模型和期望评估的用D训练出的模型很相似，评估结果往往被认为很准确。 留一法的缺点：数据集比较大时，计算复杂度高，开销非常大。 自助法自助法采用又放回采样方法，原始样本集D，每次从D中随机挑选一个样本，拷贝到D’中，并放回D中，重复每次，就得到了包含m个样本的数据集D’。通过采样法，初始数据集D中有约36.8%的样本未出现在D’中，D’作为训练集，D/D’作为测试集 总结： 在初始数据集比较充足时，留出法和交叉验证法更常用一些 在数据集比较小，难以有效划分训练/测试集是使用自助法 对于数据集小且可有效划分的时候最好使用留一法来进行划分，因为这种方法最为准确 数据集的分类及作用 训练集 training set： 用于训练模型 验证集 validation set： 用于模型选择 测试集 test set： 用于最终对学习方法的评估 调参机器学习中的两类参数： 算法的参数/超参数 模型的参数 算法的参数往往在实数范围内，因此对每种参数配置都训练出模型是不可能的，现实中往往对每个参数选定一个范围和步长值，这样选定的参数不是最佳的，但这是计算开销和性能估计之间进行这种的结果。调参往往很苦难，工程量大。 三.性能度量衡量模型泛化能力的评价标准就是性能度量，对比不同模型时使用不同的性能度量往往得到不同的评判结果。所以模型好坏是相对的，不仅取决于算法和数据，还决定于任务需求。 1.错误率和精度错误率和精度是分类任务中最常用的两个性能度量 2.查准率，查全率，F1错误率和精度有时不能满足所有的任务度量需求，对于某些问题不光要分类正确，还要求其他更进一步的需求，因此精度不能满足评估需求。比如挑西瓜，我们更关心挑出的西瓜有多少好瓜，或者有多少好瓜被挑选出来了，为了衡量这种指标，引入了查准率和查全率，查准率( precision , 注：分类精度为 accuracy)亦称准确率，查全率(recall)亦称召回率。 对于二分类问题，样本真实类别和分类器预测类别有四种组合： TP 真正例(true positive) FP 假正例(false positive) FN 假反例(false negative) TN 真反例(true negative） TP+FP+FN+TN = 样本总数 查准率：它是相对我们预测结果而言，预测的正例中有多少是真正的正例 查全率：它是相对测试样本而言，样本中的正例有多少被预测出来 查准率和查全率往往是矛盾的，查全率高时，查准率会偏低；二查准率高时，查全率就会偏低。只有在一些简单任务中这两个指标才会都很高 设计了“PR曲线”来综合考虑查全率、查准率的性能度量 在P-R曲线中，如果一个分类器的曲线完全包住另一个分类器的曲线，那么前者的性能优于后者，如果俩个分类器的曲线相交，则很难判断性能的优劣，需要其他指标来衡量。 平衡点(BEP)：曲线查全率等于查准率的点，过于简单 F1：是基于查全率和查准率的调和平均，公式如下： 其中Fβ是F1的更一般形式，因为在实际中不同的应用对查全率和查准率的要求不一样，所有 Fβ 是加权调和平均。β=1 时就是 F1； β&gt;1 时查全率影响更大；0&lt;β&lt;1 时，查准率影响更大些。 3. ROC和AUC3.1 ROCROC是一种度量分类器分类好坏的标准，评估分类器性能的标准有很多，但不同任务不同需求对好坏的标准并不一样。使用最多的标准就是分类精度，但有些现实问题中 accuracy 不能很好地评估分类器的性能。eg. 测试样本中有A类样本90个，B 类样本10个。分类器 C1 把所有的测试样本都分成了A类;分类器 C2 把A类的90个样本分对了70个，B类的10个样本分对了5个;则C1的分类精度为 90%，C2的分类精度为75% 。但是，显然C2更有用些，而且不同问题中分类错误的代价不一样。 很多学习器为测试样本产生一个实值或概率预测，将这个预测值和分类阈值threshol进行比较，大于阈值分为正例，否则分为反例。这个阈值直接决定了分类器的性能即泛化能力。根据分类器对测试样本的预测结果对所有的测试样本进行排序，分类就是在这个排序中选取某个截断点，截断点之前为正例，截断点之后为反例。根据不同的任务需求选取不同的截断点，比如如果更重视查准率，那么就选择的截断点更靠前，如果更重视查全率，选择的截断点更靠后的位置。因此排序质量的好坏，表示综合考虑分类器在不同任务下的“期望泛化性能”的好坏，ROC曲线就是从‘期望性能’的角度评估分类器的性能。 ROC全称是“受试者工作特征”ROC横坐标x为‘真正例率’ TRP，纵坐标y为‘假正利率’ FRP TRP = TP / (TP + FN) 真正例率表示原测试样本中正例被分为正例的比例 FPR = FP /（TN + FP） 假正例率表示原测试样本中反例被分为正例的比例 根据分类器的预测结果对测试样本进行排序，按照此顺序逐个把每个样本作为截断点(阈值)进行预测，每次得到两个指标值，得到ROC曲线，所以ROC体现的是分类器期望性能。 假设在一个二分类中，有正例和反例，那么对于分类结果当然是越多的正例被分出来更好，就是横坐标TRP越大越好，希望误分的反例越少越好，即FPR越小越好。放在具体领域来理解上述两个指标。如在医学诊断中，判断有病的样本。那么尽量把有病的揪出来是主要任务，也就是第一个指标TPR，要越高越好。而把没病的样本误诊为有病的，也就是第二个指标FPR，要越低越好。 类似于将预测结果排序得到分类结果统计图，如下图，左侧为负类分类结果统计图，右侧为正类分类结果统计图，两个图重叠的不跟越少那么分类器的分类性能越好，重叠的越多分类器的性能会越差，当有重叠时选择合适的阈值直接决定了分类器的分类能力。 如下图所示:不同分类性能的分类器对应的ROC曲线，分类能力越好的分类器的ROC曲线越接近左上角 3.2 AUC通过ROC曲线可以对不同分类器进行比较，如果一个分类器完全包住另一个分类器，那么前者的性能一定优于后者，若果曲线之间相交，就要比较ROC曲线下面的面积，即 AUC(Area Under ROC Cure) ，AUC量化了ROC曲线表示的分类器的分类能力。 3.2.1 AUC的含义 The AUC value is equivalent to the probability that a randomly chosen positive example is ranked higher than a randomly chosen negative example. 首先AUC值是一个概率值，当你随机挑选一个正样本以及一个负样本，当前的分类算法根据计算得到的Score值将这个正样本排在负样本前面的概率就是AUC值。当然，AUC值越大，当前的分类算法越有可能将正样本排在负样本前面，即能够更好的分类 AUC值为ROC曲线所覆盖的区域面积，显然，AUC越大，分类器分类效果越好。 AUC = 1，是完美分类器，采用这个预测模型时，不管设定什么阈值都能得出完美预测。 0.5 &lt; AUC &lt; 1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。 AUC = 0.5，随机猜测，模型没有预测价值。 AUC &lt; 0.5，比随机猜测还差；但只要总是反预测而行，就优于随机猜测。 3.2.2 AUC的计算方式4. 代价敏感错误率和代价曲线在现实任务中，不同错误所造成的后果并不一样，代价不相同。例如将健康患者诊断为患病，会增加后续检查的麻烦，而将患病者诊断为健康，后果核能是错失拯救生命的机会，后者误判的代价很明显远大于前者误判。 以二分类为例的代价矩阵如下 假设给定 m+ 个正例和 m- 个负例，D+ 和 D- 分别代表正、反例集合 ，则代价敏感错误率为 在非均等代价下，“代价曲线”可以反映分类器的期望总体代价。x坐标为正例概率代价，如下公式，p为样例为正例的概率。纵轴y为归一化代价FNR为假正例率，FPR为假反例率，FPR=1-FNR 。 代价曲线如下 ，ROC曲线的每个点代表代价平面上的一条线段。 5. 偏差和方差对算法除了通过实验评估学习器的泛化性能，还要分析为神魔有这样的性能，偏差方差分解是解释算法泛化性能的重要工具 5.1 偏差-方差分解那么如何理解方差和偏差呢？ 如下图经典的靶心图，假设红心是最正确的预测值就是样本的真实分类，二蓝色的点为模型对样本的输出值。由图可以观察到左侧两个靶子上的样本蓝点/预测值比较集中方差较小，右侧两个靶子的蓝点相对很分散则方差较大；从横向来看，上面的两个蓝色预测值比较集中的靠近靶心，所以偏差小，二下面的两个靶子中的蓝色点离靶心比较远则偏差比较大。 以回归为例，算法的期望预测为： 方差： 噪声为样本在测试集的实际标记和真实标记的偏差 偏差是期望预测和真实标记的误差 对算法的泛化误差分解 分解结果：泛化误差可以分解为偏差、方差和噪声 注：这个分解形式仅在基于均方误差的回归任务中推导出。 偏差度量了学习算法的期望预测与真实结果的偏离程度，刻画了算法本身的拟合能力 方差度量了同样大小的训练集的变动所导致的的学习性能的变化，刻画了数据扰动所造成的影响 噪声表达了当前任务上任何学习算法所能达到的期望泛化误差的下界。刻画了问题的本身难度 所以泛化性能是由算法的能力、数据的充分性和任务本身难度所共同决定的。 5.2 偏差-方差窘境一般情况下，偏差和方差是有冲突的，这就是偏差方差窘境，如下图所示 对于一个特定的任务，当训练不足时，分类器的拟合能力不足，存在欠拟合，训练数据的扰动不足以使分类器发生显著的变化，这时偏差主导着泛化误差(总体误差)；当加强训练程度时，分类器拟合能力逐渐增强，偏差逐渐变小不再主导误差，训练数据发生的扰动逐渐被学习器学到(即通过不同训练集得到的分类器的拟合能力不相同)，这时方差主导了泛化误差；当训练程度十分充足时，分类器的拟合能力非常的强，训练数据的轻微扰动都会导致分类器发生显著的变化，如果训练数据局部特性、非数据集一般特性被分类器学习到，则发生了过拟合。]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-模型评估与选择]]></title>
    <url>%2F2019%2F01%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%2F</url>
    <content type="text"><![CDATA[模型评估与选择一.误差与过拟合分类器分类错误的样本数占样本总数的比例为错误率(errorate)，E=m/n(m为分类错误的总样本数，n为总样本数），分类的精度(accuracy) P=(1-E)x100% 学习器实际预测值和样本真实值之间的差异为“误差” 训练误差/经验误差：学习器在训练数据上的误差 泛华误差：学习器在新样本上的误差 我们希望得到的是泛化误差尽可能小的学习器，在通过训练数据训练学习器的过程中是在尽可能的最小化训练误差。有时学习器的训练误差非常小，但当遇到新的样本时表现的却不好。因此为了的当泛华能力比较强的学习器，只能让学习器从训练样本中学习到尽可能适应所有样本的普遍规律，要尽可能的学习所有训练样本的共性，这样学习器在遇到引得样本时才会做出正确的判断。通过训练数据训练出的学习器会有两个问题： 过拟合:学习器学习能力过于强大把训练数据学习的太好了，可能把训练样本自身的特点当做了所有样本的一般性质，导致过拟合，是学习器的泛化能力降低。过拟合无法避免，只能尽量减小。 欠拟合：和过拟合相对应，有学习器学习能力过低，对训练样本的一般性质没有学好，欠拟合容易克服，关键的问题是过拟合 二.模型评估和选择方法不同的机器学习算法，同一算法的不同参数配置都是不同的模型，机器学习的模型选择就是对模型的泛化误差进行评估选择泛化误差最小的模型。 通过训练数据得到的学习器，将学习器在在测试数据上的测试误差作为学习器的泛华误差。 训练集与测试集要有如下关系：训练集和测试集都是从样本真实分布中独立同分布采样而得，他们应该尽可能互斥，测试样本尽量不出现在训练样本中。 假设包含m个样例的样本集D={(x1,y1),(x2,y2),...,(xm,ym)},如何划分训练集和测试集的常用方法如下： 留出法直接将样本集D划分为两个互斥的集合D= S U T,S作为训练集，T作为测试集估计分类器的泛化误差。 训练集和测试集的划分要保持数据分布的一致性，避免数据划分引入偏差影响结果。比如在分类任务中要保持两个集合中样本的类别别比例相似。 在使用留出法时不同的划分会得到不同的模型，单次留出法得到的结果往往不够稳定可靠，一般采用若干次留出法随机划分，重复试验评估后取平均值作为留出法的评估结果。并且常将样本集的2/3 ~ 4/5的样本用于训练，剩余的用于测试。 交叉验证法 将样本集D划分为k个大小相似的互斥子集，D=D1 U D2 U…U Dk,每个子集尽可能保持数据分布的一致性， 每次使用k-1个子集的并集作为训练集，剩余的一个子集作为测试集， 这样可以得到k组训练/测试集，进行k次实验，得到的是k次测试结果的均值 交叉验证法评估结果的稳定性很大程度取决于k的取值，因此也称为“k折交叉”验证，k常取10，其他常用值为5，20等。 交叉验证法的特例：留一法(LOO)，k=m 留一法的优点：留一法不受随机样本划分方式的影响，因为m个样本只有唯一的方式划分为m个子集，每个子集一个样本，在多数情况下，留一法中被实际评估的模型和期望评估的用D训练出的模型很相似，评估结果往往被认为很准确。 留一法的缺点：数据集比较大时，计算复杂度高，开销非常大。 自助法自助法采用又放回采样方法，原始样本集D，每次从D中随机挑选一个样本，拷贝到D’中，并放回D中，重复每次，就得到了包含m个样本的数据集D’。通过采样法，初始数据集D中有约36.8%的样本未出现在D’中，D’作为训练集，D/D’作为测试集 总结： 在初始数据集比较充足时，留出法和交叉验证法更常用一些 在数据集比较小，难以有效划分训练/测试集是使用自助法 对于数据集小且可有效划分的时候最好使用留一法来进行划分，因为这种方法最为准确 数据集的分类及作用 训练集 training set： 用于训练模型 验证集 validation set： 用于模型选择 测试集 test set： 用于最终对学习方法的评估 调参机器学习中的两类参数： 算法的参数/超参数 模型的参数 算法的参数往往在实数范围内，因此对每种参数配置都训练出模型是不可能的，现实中往往对每个参数选定一个范围和步长值，这样选定的参数不是最佳的，但这是计算开销和性能估计之间进行这种的结果。调参往往很苦难，工程量大。 三.性能度量衡量模型泛化能力的评价标准就是性能度量，对比不同模型时使用不同的性能度量往往得到不同的评判结果。所以模型好坏是相对的，不仅取决于算法和数据，还决定于任务需求。 1.错误率和精度错误率和精度是分类任务中最常用的两个性能度量 2.查准率，查全率，F1错误率和精度有时不能满足所有的任务度量需求，对于某些问题不光要分类正确，还要求其他更进一步的需求，因此精度不能满足评估需求。比如挑西瓜，我们更关心挑出的西瓜有多少好瓜，或者有多少好瓜被挑选出来了，为了衡量这种指标，引入了查准率和查全率，查准率( precision , 注：分类精度为 accuracy)亦称准确率，查全率(recall)亦称召回率。 对于二分类问题，样本真实类别和分类器预测类别有四种组合： TP 真正例(true positive) FP 假正例(false positive) FN 假反例(false negative) TN 真反例(true negative） TP+FP+FN+TN = 样本总数 查准率：它是相对我们预测结果而言，预测的正例中有多少是真正的正例 查全率：它是相对测试样本而言，样本中的正例有多少被预测出来 查准率和查全率往往是矛盾的，查全率高时，查准率会偏低；二查准率高时，查全率就会偏低。只有在一些简单任务中这两个指标才会都很高 设计了“PR曲线”来综合考虑查全率、查准率的性能度量 在P-R曲线中，如果一个分类器的曲线完全包住另一个分类器的曲线，那么前者的性能优于后者，如果俩个分类器的曲线相交，则很难判断性能的优劣，需要其他指标来衡量。 平衡点(BEP)：曲线查全率等于查准率的点，过于简单 F1：是基于查全率和查准率的调和平均，公式如下： 其中Fβ是F1的更一般形式，因为在实际中不同的应用对查全率和查准率的要求不一样，所有 Fβ 是加权调和平均。β=1 时就是 F1； β&gt;1 时查全率影响更大；0&lt;β&lt;1 时，查准率影响更大些。 3. ROC和AUC3.1 ROCROC是一种度量分类器分类好坏的标准，评估分类器性能的标准有很多，但不同任务不同需求对好坏的标准并不一样。使用最多的标准就是分类精度，但有些现实问题中 accuracy 不能很好地评估分类器的性能。eg. 测试样本中有A类样本90个，B 类样本10个。分类器 C1 把所有的测试样本都分成了A类;分类器 C2 把A类的90个样本分对了70个，B类的10个样本分对了5个;则C1的分类精度为 90%，C2的分类精度为75% 。但是，显然C2更有用些，而且不同问题中分类错误的代价不一样。 很多学习器为测试样本产生一个实值或概率预测，将这个预测值和分类阈值threshol进行比较，大于阈值分为正例，否则分为反例。这个阈值直接决定了分类器的性能即泛化能力。根据分类器对测试样本的预测结果对所有的测试样本进行排序，分类就是在这个排序中选取某个截断点，截断点之前为正例，截断点之后为反例。根据不同的任务需求选取不同的截断点，比如如果更重视查准率，那么就选择的截断点更靠前，如果更重视查全率，选择的截断点更靠后的位置。因此排序质量的好坏，表示综合考虑分类器在不同任务下的“期望泛化性能”的好坏，ROC曲线就是从‘期望性能’的角度评估分类器的性能。 ROC全称是“受试者工作特征”ROC横坐标x为‘真正例率’ TRP，纵坐标y为‘假正利率’ FRP TRP = TP / (TP + FN) 真正例率表示原测试样本中正例被分为正例的比例 FPR = FP /（TN + FP） 假正例率表示原测试样本中反例被分为正例的比例 根据分类器的预测结果对测试样本进行排序，按照此顺序逐个把每个样本作为截断点(阈值)进行预测，每次得到两个指标值，得到ROC曲线，所以ROC体现的是分类器期望性能。 假设在一个二分类中，有正例和反例，那么对于分类结果当然是越多的正例被分出来更好，就是横坐标TRP越大越好，希望误分的反例越少越好，即FPR越小越好。放在具体领域来理解上述两个指标。如在医学诊断中，判断有病的样本。那么尽量把有病的揪出来是主要任务，也就是第一个指标TPR，要越高越好。而把没病的样本误诊为有病的，也就是第二个指标FPR，要越低越好。 类似于将预测结果排序得到分类结果统计图，如下图，左侧为负类分类结果统计图，右侧为正类分类结果统计图，两个图重叠的不跟越少那么分类器的分类性能越好，重叠的越多分类器的性能会越差，当有重叠时选择合适的阈值直接决定了分类器的分类能力。 如下图所示:不同分类性能的分类器对应的ROC曲线，分类能力越好的分类器的ROC曲线越接近左上角 3.2 AUC通过ROC曲线可以对不同分类器进行比较，如果一个分类器完全包住另一个分类器，那么前者的性能一定优于后者，若果曲线之间相交，就要比较ROC曲线下面的面积，即 AUC(Area Under ROC Cure) ，AUC量化了ROC曲线表示的分类器的分类能力。 3.2.1 AUC的含义 The AUC value is equivalent to the probability that a randomly chosen positive example is ranked higher than a randomly chosen negative example. 首先AUC值是一个概率值，当你随机挑选一个正样本以及一个负样本，当前的分类算法根据计算得到的Score值将这个正样本排在负样本前面的概率就是AUC值。当然，AUC值越大，当前的分类算法越有可能将正样本排在负样本前面，即能够更好的分类 AUC值为ROC曲线所覆盖的区域面积，显然，AUC越大，分类器分类效果越好。 AUC = 1，是完美分类器，采用这个预测模型时，不管设定什么阈值都能得出完美预测。 0.5 &lt; AUC &lt; 1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。 AUC = 0.5，随机猜测，模型没有预测价值。 AUC &lt; 0.5，比随机猜测还差；但只要总是反预测而行，就优于随机猜测。 3.2.2 AUC的计算方式4. 代价敏感错误率和代价曲线在现实任务中，不同错误所造成的后果并不一样，代价不相同。例如将健康患者诊断为患病，会增加后续检查的麻烦，而将患病者诊断为健康，后果核能是错失拯救生命的机会，后者误判的代价很明显远大于前者误判。 以二分类为例的代价矩阵如下 假设给定 m+ 个正例和 m- 个负例，D+ 和 D- 分别代表正、反例集合 ，则代价敏感错误率为 在非均等代价下，“代价曲线”可以反映分类器的期望总体代价。x坐标为正例概率代价，如下公式，p为样例为正例的概率。纵轴y为归一化代价FNR为假正例率，FPR为假反例率，FPR=1-FNR 。 代价曲线如下 ，ROC曲线的每个点代表代价平面上的一条线段。 5. 偏差和方差对算法除了通过实验评估学习器的泛化性能，还要分析为神魔有这样的性能，偏差方差分解是解释算法泛化性能的重要工具 5.1 偏差-方差分解那么如何理解方差和偏差呢？ 如下图经典的靶心图，假设红心是最正确的预测值就是样本的真实分类，二蓝色的点为模型对样本的输出值。由图可以观察到左侧两个靶子上的样本蓝点/预测值比较集中方差较小，右侧两个靶子的蓝点相对很分散则方差较大；从横向来看，上面的两个蓝色预测值比较集中的靠近靶心，所以偏差小，二下面的两个靶子中的蓝色点离靶心比较远则偏差比较大。 以回归为例，算法的期望预测为： 方差： 噪声为样本在测试集的实际标记和真实标记的偏差 偏差是期望预测和真实标记的误差 对算法的泛化误差分解 分解结果：泛化误差可以分解为偏差、方差和噪声 注：这个分解形式仅在基于均方误差的回归任务中推导出。 偏差度量了学习算法的期望预测与真实结果的偏离程度，刻画了算法本身的拟合能力 方差度量了同样大小的训练集的变动所导致的的学习性能的变化，刻画了数据扰动所造成的影响 噪声表达了当前任务上任何学习算法所能达到的期望泛化误差的下界。刻画了问题的本身难度 所以泛化性能是由算法的能力、数据的充分性和任务本身难度所共同决定的。 5.2 偏差-方差窘境一般情况下，偏差和方差是有冲突的，这就是偏差方差窘境，如下图所示 对于一个特定的任务，当训练不足时，分类器的拟合能力不足，存在欠拟合，训练数据的扰动不足以使分类器发生显著的变化，这时偏差主导着泛化误差(总体误差)；当加强训练程度时，分类器拟合能力逐渐增强，偏差逐渐变小不再主导误差，训练数据发生的扰动逐渐被学习器学到(即通过不同训练集得到的分类器的拟合能力不相同)，这时方差主导了泛化误差；当训练程度十分充足时，分类器的拟合能力非常的强，训练数据的轻微扰动都会导致分类器发生显著的变化，如果训练数据局部特性、非数据集一般特性被分类器学习到，则发生了过拟合。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-IO概述]]></title>
    <url>%2F2018%2F12%2F13%2FJava-IO%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Java IO概述Java IO是一套提供输入输出（读写数据）功能的API，提供了java.io 包 Java IO的构成概述java.io包中主要包括了五个类和一个接口： File:文件类，用于文件的管理 InputStream:字节输入流类，二进制格式操作，基于字节的输入，是所有字节输入流类的父类 OutputStream:字节输出流类，二进制格式操作，基于字节的输出，是所有字节输出流类的父类 Reader:字符输入流类，文件格式操作，基于字符的输入操作，是所有字符输入流类的父类 Writer:字符输出流类，文件格式操作，基于字符的输出操作，是所有字符输入流类的父类 RandomAccessFile:可以在文件的任意位置进行存取操作 Serializable: 下面是一张通过输入、输出、基于字节或者字符、以及其他比如缓冲、解析之类的特定用途划分的大部分Java IO类的表格 Java IO关注的是从原始数据源读取数据输出原始数据到目标介质 ，主要的数据源和目标介质有 文件 管道 Java中的管道是为运行在同一个JVM中的两个线程提供通信能力 在Java中使用管道时，通信的双方应该是运行在同一进程中的不同线程 网络连接 内存缓存 System.in,System.out,System.error(Java标准的输入输出) 一个程序需要InputStream或者Reader从数据源读取数据，需要OutputStream或者Writer将数据写入到目标媒介中 Java IO的分类根据数据流向： 输入流-读取数据 输出流-写数据 根据处理的数据类型： 字节流：数据流中最小的数据单元是字节 字符流：数据流中最小的数据单元是字符，Java中的字符是Unicode编码，一个字符占用两个字节，因为数据编码的不同，而有了对字符进行高效操作的流对象，本质其实就是基于字节流读取时，去查了指定的码表。 注解： 采用数据流的目的是使输入输出独立于设备，不用关心设备 对于程序来说，输出流是往存储介质或数据通道写入数据，而输入流是从存储介质或数据通道中读取数据 只读或只写，每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流 File类-文件管理File类用于管理文件的类，包括创建文件，删除文件，获取文件路径、文件名等，做判断过滤等功能 构造方法 public File(String pathname) 通过将给定的路径名字符串转换为抽象路径名来创建新的File实例 public File(String parent,String child) 从父路径名字符串和子路径名字符串创建新的File实例 public File(File parent,String child) 从父抽象路径名和子路径名字符串创建新的File实例 成员方法： 创建功能： public boolean createNewFile() throws IOException 当且仅当具有该名称的文件尚不存在时，原子地创建一个由该抽象路径名命名的新的空文件 public boolean mkdir() 创建文件夹 public boolean mkdirs() 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目 删除功能： public boolean delete() 删除由此抽象路径名表示的文件或目录 重命名： public boolean renameTo(File dest) 判断： public boolean isDirectory() 判断是否是目录 public boolean isFile() 判断是否是文件 public boolean exists() 判断是否存在 public boolean canRead() 判断是否可读 public boolean canWrite() 判断是否可写 public boolean isHidden() 判断是否隐藏 获取： public String getAbsolutePath() 获取绝对路径 public String getPath() 获取相对路径 public String getName() 获取名称 public long length() 获取长度，字节数 public long lastModified() 获取最后一次修改时间 public String[] list() 获取指定目录下所有文件夹或文件名称的数组 public File[] listFiles() 获取指定目录下所有文件夹或文件的File的数组 文件名称过滤器FilenameFilter public String[] list(FilenameFilter filter) public File[] listFiles(FilenameFilter filter) 字节流InputStream InputStream FileInputStream BufferedInputStream]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-图(最短路径)]]></title>
    <url>%2F2018%2F11%2F13%2FJava%E7%AE%97%E6%B3%95-%E5%9B%BE-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[最短路径最短路径应用的图是加权有向图加权有向图的数据结构：首先定义的是加权有向边的数据类型：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class DirectEdge &#123; private int v;//边的起点 private int w;//边的终点 private double weight;//边的权重 public DirectEdge(int v,int w,double weight)&#123; this.v=v; this.w=w; this.weight=weight; &#125; public double weight()&#123; return weight; &#125; public int from()&#123; return v; &#125; public int to()&#123; return w; &#125; public String toString()&#123; return String.format("%d-&gt;%d %.2f", v,w,weight); &#125;&#125; ``` 在加权有向边的基础上定义加权有向图 ```javapublic class EdgeWeightDigraph &#123; private int V; private int E; private Bag&lt;DirectEdge&gt;[] adj; public EdgeWeightDigraph(int V)&#123; this.V=V; this.E=0; adj=(Bag&lt;DirectEdge&gt;[])new Bag[V]; for(int v=0;v&lt;V;v++)&#123; adj[v]=new Bag&lt;DirectEdge&gt;(); &#125; &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; public void addEdge(DirectEdge e)&#123; int v=e.from(); adj[v].add(e); E++; &#125; public Iterable&lt;DirectEdge&gt; adj(int v)&#123; return adj[v]; &#125; public Iterable&lt;DirectEdge&gt; edges()&#123; Bag&lt;DirectEdge&gt; bag=new Bag&lt;DirectEdge&gt;(); for(int v=0;v&lt;V;v++)&#123; for(DirectEdge e:adj[v])&#123; bag.add(e); &#125; &#125; return bag; &#125;&#125; 最短路径：从图的一个顶点到达另一个顶点的成本最小(权重和最小)的路径，这里的最短路径是单点最短路径最短路径树： 给定一幅加权有向图和顶点s，可以找到一个以s为起点的最小路径树，他是图的一幅子图，包含了顶点s和所有s可达的顶点。树的根节点是s，树的每一条路径都是有向图中的一条最短路径 最短路径算法原理边的松弛顶点的松弛最短路径的最优条件：一幅有向加权图G,顶点s为起点，distTo[]保存着起点s到任意顶点v的路径长度，若s到v不可达，该值为无穷大。当且仅当对于从v到w的任意一条边e，满足distTo[w]&lt;=distTo[v]+e.weight()条件时，才是最短路径 Dijkstra算法 算法思想1) 首先Dijkstra算法只适用在权值非负的加权有向图 如下图所示，E(v2,v5)为负值，如果想找到v5到v4的最短路径，那么这一条路径：v5-&gt;v4-&gt;v2-&gt;v5-&gt;v4的权值之和为-6，如此一直沿着这条路径循环，那么v5到v4的路径权重之和会越来越小，趋近于负无穷，那么这两个顶点之间的最短路径无法确定。我们称图中这样的循环为负值圈，有向图中出现负值圈时，最短路径的问题就无法确定。 2）Dijkstra算法的思想 首先确定源点s，dist[v]表示的是从s到v的最短路径距离 Dijkstra算法每次从没有确定最短路径的顶点中选择dist[]值最小的顶点v，对v的所有边进行松弛，如此操作直到确定所有顶点的最短路径 算法实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Dijkstra &#123; private DirectEdge[] edgeTo; private double[] distTo; private IndexMinPQ&lt;Double&gt; pq; public Dijkstra(EdgeWeightDigraph G,int s)&#123; edgeTo=new DirectEdge[G.V()]; distTo=new double[G.V()]; pq=new IndexMinPQ&lt;Double&gt;(G.V()); //初始化distTo所有项为正无穷 for(int v=0;v&lt;G.V();v++)&#123; distTo[v]=Double.POSITIVE_INFINITY; &#125; //起始点设置为0 distTo[s]=0.0; //将起始点入队 pq.insert(s, 0.0); while(!pq.isEmpty())&#123; relax(G,pq.deleteMin()); &#125; &#125; private void relax(EdgeWeightDigraph G,int v)&#123; for(DirectEdge e:G.adj(v))&#123; int w=e.to(); if(distTo[w]&gt;distTo[v]+e.weight())&#123; distTo[w]=distTo[v]+e.weight(); edgeTo[w]=e; if(pq.contains(w))&#123; pq.changeKey(w, distTo[w]); &#125;else&#123; pq.insert(w, distTo[w]); &#125; &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return distTo[v]&lt;Double.POSITIVE_INFINITY; &#125; public double distTo(int v)&#123; return distTo[v]; &#125; public Iterable&lt;DirectEdge&gt; pathTo(int v)&#123; Stack&lt;DirectEdge&gt; stack=new Stack&lt;DirectEdge&gt;(); while(edgeTo[v]!=null)&#123; stack.push(edgeTo[v]); v=edgeTo[v].from(); &#125; return stack; &#125;&#125; 算法分析 Dijkstra算法时间复杂度取决于存储顶点的数据结构 上面算法的实现使用的是最小优先队列，每次删除最小距离顶点时间复杂度为logV，整个算法需要对每条边松弛，所以基于最小优先队列的Dijkstra算法的时间复杂度为ElogV 基于拓扑排序的最短路径算法 算法原理 将图按照拓扑排序的顺序放松顶点 这种算法只能应用在无环有向图中，并且它允许图的边的权重是负值，他还能解决相关的问题比如最长路径 算法实现 12345678910111213141516171819202122232425262728293031323334353637383940//利用拓扑排序实现的最短路径算法 public class AcyclicSP &#123; private DirectEdge[] edgeTo; private double[] distTo; public AcyclicSP(EdgeWeightDigraph G,int s)&#123; edgeTo=new DirectEdge[G.V()]; distTo=new double[G.V()]; for(int v=0;v&lt;G.V();v++)&#123; distTo[v]=Double.POSITIVE_INFINITY; &#125; distTo[s]=0.0; TopoEdgeWeight top=new TopoEdgeWeight(G); for(int v:top.order())&#123; relax(G,v); &#125; &#125; private void relax(EdgeWeightDigraph G,int v)&#123; for(DirectEdge e:G.adj(v))&#123; int w=e.to(); if(distTo[w]&gt;distTo[v]+e.weight())&#123; distTo[w]=distTo[v]+e.weight(); edgeTo[w]=e; &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return distTo[v]&lt;Double.POSITIVE_INFINITY; &#125; public double distTo(int v)&#123; return distTo[v]; &#125; public Iterable&lt;DirectEdge&gt; pathTo(int v)&#123; Stack&lt;DirectEdge&gt; stack=new Stack&lt;DirectEdge&gt;(); while(edgeTo[v]!=null)&#123; stack.push(edgeTo[v]); v=edgeTo[v].from(); &#125; return stack; &#125; &#125; 在查找最短路径之前需要对图进行拓扑排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class TopoEdgeWeight &#123; private boolean marked[]; private Stack&lt;Integer&gt; stack; public TopoEdgeWeight(EdgeWeightDigraph G)&#123; marked=new boolean[G.V()]; stack=new Stack&lt;Integer&gt;(); EdgeWeightDigraphCycle cycle=new EdgeWeightDigraphCycle(G); if(!cycle.hasCycle())&#123; TopoSort(G); &#125; &#125; private void TopoSort(EdgeWeightDigraph G)&#123; for(int v=0;v&lt;G.V();v++)&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; private void dfs(EdgeWeightDigraph G,int v)&#123; marked[v]=true; for(DirectEdge e:G.adj(v))&#123; if(!marked[e.to()])&#123; dfs(G,e.to()); &#125; &#125; stack.push(v); &#125; public Iterable&lt;Integer&gt; order()&#123; return stack; &#125;&#125;``` 在拓扑排序之前需要检查图是不是无环图 ```javapublic class EdgeWeightDigraphCycle &#123; private boolean[] marked; private DirectEdge[] edgeTo; private Stack&lt;DirectEdge&gt; cycle; private boolean[] onStack; public EdgeWeightDigraphCycle(EdgeWeightDigraph G)&#123; marked=new boolean[G.V()]; edgeTo=new DirectEdge[G.V()]; onStack=new boolean[G.V()]; for(int v=0;v&lt;G.V();v++)&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; private void dfs(EdgeWeightDigraph G,int v)&#123; marked[v]=true; onStack[v]=true; for(DirectEdge e:G.adj(v))&#123; int w=e.to(); if(hasCycle())&#123; return; &#125;else if(!marked[w])&#123; edgeTo[w]=e; dfs(G,w); &#125;else if(onStack[w])&#123; cycle=new Stack&lt;DirectEdge&gt;(); DirectEdge f=e; while(f.from()!=w)&#123; cycle.push(f); f=edgeTo[f.from()]; &#125; cycle.push(f); return; &#125; &#125; onStack[v]=false; &#125; public boolean hasCycle()&#123; return cycle!=null; &#125; public Iterable&lt;DirectEdge&gt; cycle()&#123; return cycle; &#125;&#125; 算法分析基于拓扑排序的最短路径算法是一种比Dijkstra算法更快更简单的在无环加权有向图中找到最短路径的算法基于拓扑排序的最短路径算法的时间复杂度是O(V+E) Floyd算法 算法原理 从任意节点v到节点w最短路径有两种情况：第一种是直接从v到w；第二种是从v经过若干个节点到达w，对图中的每个节点k，检查dist(v,k)+dist(k,w)&lt;dist(v,w)是否成立，如果成立，那么更新v到w的最短路径为dist(v,k)+dist(k,w)，如此当我们遍历完图中所有的节点之后，v到w的最短路径和最短距离就确定了。 此算法就是一任意的顺序放松图中所有的边，重复V轮。 算法实现三重循环实现 for (int k=0; k&lt;n; ++k) { for (int i=0; i&lt;n; ++i) { for (int j=0; j&lt;n; ++j) { if (dist[i][k] + dist[k][j] &lt; dist[i][j] ) { dist[i][j] = dist[i][k] + dist[k][j]; path[i][j] = path[k][j]; } } } } 算法分析 Floyd算法的时间复杂度为：O(V3) Bellman-Ford算法Bellman-ford算法是求含负权图的单源最短路径算法，效率很低，但代码很容易写 算法原理利用队列 算法实现 public class BellmanFord { private double[] distTo; private DirectEdge[] edgeTo; private boolean[] onQ;//该顶点是否在队列中 private Queue&lt;Integer&gt; queue;//用于存放将被放松的顶点 private int cont;//放松的次数 private Iterable&lt;DirectEdge&gt; cycle; public BellmanFord(EdgeWeightDigraph G,int s){ distTo=new double[G.V()]; edgeTo=new DirectEdge[G.V()]; onQ=new boolean[G.V()]; queue=new Queue&lt;Integer&gt;(); for(int v=0;v&lt;G.V();v++){ distTo[v]=Double.POSITIVE_INFINITY; } queue.enqueue(s); onQ[s]=true; distTo[s]=0.0; while(!queue.isEmpty() &amp;&amp; hasNegativeCycle()){ int v=queue.dequeue(); onQ[v]=false; relax(G,v); } } private void relax(EdgeWeightDigraph G,int v){ for(DirectEdge e:G.adj(v)){ int w=e.to(); if(distTo[w]&gt;distTo[v]+e.weight()){ distTo[w]=distTo[v]+e.weight(); edgeTo[w]=e; if(!onQ[w]){ queue.enqueue(w); onQ[w]=true; } } if(cont++ % G.V() ==0){ findNegativeCycle(); } } } public void findNegativeCycle(){ int V=edgeTo.length; EdgeWeightDigraph bf=new EdgeWeightDigraph(V); for(int v=0;v&lt;V;v++){ if(edgeTo[v]!=null){ bf.addEdge(edgeTo[v]); } } EdgeWeightDigraphCycle cf=new EdgeWeightDigraphCycle(bf); cycle=cf.cycle(); } public boolean hasNegativeCycle(){ return cycle!=null; } public Iterable&lt;DirectEdge&gt; negativeCycle(){ return cycle; } public boolean hasPathTo(int v){ return distTo[v]&lt;Double.POSITIVE_INFINITY; } public double distTo(int v){ return distTo[v]; } public Iterable&lt;DirectEdge&gt; pathTo(int v){ Stack&lt;DirectEdge&gt; stack=new Stack&lt;DirectEdge&gt;(); while(edgeTo[v]!=null){ stack.push(edgeTo[v]); v=edgeTo[v].from(); } return stack; } } 算法分析 BellmanFord算法的时间复杂度一般情况为O(E+V),最坏情况为O(VE)]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorihtms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-图（最小生成树）]]></title>
    <url>%2F2018%2F11%2F04%2FJava%E7%AE%97%E6%B3%95-%E5%9B%BE%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最小生成树定义：加权图：加权图是图中每条边都关联一个权值的图模型(边的权重可以表示距离、时间、费用等不同变量；权中可正可负)带权重边的表示：1234567891011121314151617181920212223242526272829303132333435public class Edge implements Comparable&lt;Edge&gt; &#123; private int v; private int w;//v,w为边连接的两个顶点 private double weight;//边的权重 public Edge(int v,int w,double weight)&#123; this.v=v; this.w=w; this.weight=weight; &#125; public double weight()&#123; return weight; &#125; public int either()&#123; return v; &#125; public int other(int vertex)&#123; if(vertex==v)&#123; return w; &#125;else if(vertex==w)&#123; return v; &#125;else&#123; throw new RuntimeException("Inconsistent edge"); &#125; &#125; @Override public int compareTo(Edge that)&#123; if(this.weight()&lt;that.weight())&#123; return -1; &#125;else if(this.weight()&gt;that.weight())&#123; return 1; &#125;else&#123; return 0; &#125; &#125;&#125;无向加权图的表示：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 public class EdgeWeightGraph &#123; private int V; private int E; private Bag&lt;Edge&gt;[] adj; public EdgeWeightGraph(int V)&#123; this.V=V; this.E=0; adj=(Bag&lt;Edge&gt;[])new Bag[V]; for(int v=0;v&lt;V;v++)&#123; adj[v]=new Bag&lt;Edge&gt;(); &#125; &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; //添加边 public void addEdge(Edge e)&#123; int v=e.either(); int w=e.other(v); adj[v].add(e); adj[w].add(e); E++; &#125; public Iterable&lt;Edge&gt; adj(int v)&#123; return adj[v]; &#125; //返回图中所有的边 public Iterable&lt;Edge&gt; edges()&#123; Bag bag=new Bag&lt;Edge&gt;(); for(int v=0;v&lt;V;v++)&#123; for(Edge e:adj[v])&#123; if(e.other(v)&gt;v)&#123; bag.add(e); &#125; &#125; &#125; return bag; &#125; //显示图表 public String toString()&#123; StringBuilder s=new StringBuilder(); s.append(V+"Vertexs"+E+"Edges\n"); for(int v=0;v&lt;V;v++)&#123; s.append(v+":"); for(Edge e:adj[v])&#123; s.append(e+" "); &#125; s.append("\n"); &#125; return s.toString(); &#125;&#125; 生成树：一幅图的生成树是它的一棵含有其所有顶点的无环连通子图最小生成树(MST)：一幅图的最小生成树是它的一棵所有边权值和最小的生成树(生成树+所有边权值和最小) 切分定理图的切分：将图中所有的顶点分为两个非空且不重叠的两个集合，横切边(crossing edge)是一条连接两个属于不同集合中顶点的边切分定理：一幅加权图中，对于图的任意切分的横切边中的权重最小的边一定属于改图的最小生成树切分定理会把加权图所有的顶点分为两个集合，检查每次切分的横切边并识别属于最小生成树的边最小生成树的贪心算法： 生成最小生成树的基础是切分定理，对于一个V个顶点的加权图，使用切分定理找到最小生成树的一条边，不断重复直到找到最小生成树所有的V-1条边 最小生成树Prim算法prim算法的核心是选取一个顶点，每一次向树中添加一条边，知道添加V-1条边；每次添加的边是连接树中的顶点和不在树中的顶点所连接的边中权重值最小的。注：连接树：最小生成树的一部分横切边:为连接树中的顶点和不在连接树中的顶点之间的所有边失效边:如果一条边的两个顶点都在连接树中，则为失效边不去管它 prim算法延时实现过程： 选取一个起始顶点作为生成树的第一个顶点，将此时所有的横切边加入优先队列（MinPQ） 检查队列while(队列不空)： 取出并删除队列中的权重值最小的边 if(这条边失效) contuine结束此次循环 if(这条边有一个顶点不在连接树上)将这个顶点添加到树中，并将新的横切边添加到优先队列中 算法改进：prim算法即时实现延时实现是一些失效的横切边保存在优先队列中(当向连接树添加一个新的顶点v时，所有和v相关联的横切边都会被加入到优先队列中)，只有要删除的时候才检查它的有效性Prim实时实现是不去保存所有的横切边，它只保存连接树顶点和非树顶点中权重最小的边试想：当我们向连接树中添加了一个新的顶点v，那么非树顶点w可能距离连接树的距离更近了，我们只保存非树顶点w和树顶点距离最近的那条边。可能队列中保存着w到连接树的权重最小的边w-&gt;k,当连接树中加入了v之后，w-&gt;v这条边的权重值比w-&gt;k的权重值要小，那么在优先队列中对于顶点w，它和连接树距离最短的边更新为w-&gt;v。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class PrimMST&#123; private Edge[] edgeTo;//用来存储非树顶点距离树最近的边 private double[] distTo;//用来存储边的权重，distTo[i]=edgeTo[i].weight() private boolean[] marked;//用来标记顶点是否在树中 private IndexMinPQ&lt;Double&gt; pq;//存储有效的横切边 public PrimMST(EdgeWeightGraph G)&#123; edgeTo=new Edge[G.V()]; distTo=new double[G.V()]; marked=new boolean[G.V()]; pq=new IndexMinPQ&lt;Double&gt;(G.V()); for(int i=0;i&lt;G.V();i++)&#123; distTo[i]=Double.POSITIVE_INFINITY; &#125; //从顶点0开始 distTo[0]=0.0; pq.insert(0, 0.0); while(!pq.isEmpty())&#123; visit(G,pq.deleteMin()); &#125; //当向最初的树中添加V-1条边后，最小生成树完成而优先队列变为空 &#125; private void visit(EdgeWeightGraph G,int v)&#123; //将v添加至树中，更新相关数据 marked[v]=true; //遍历和v相连的每一个顶点 for(Edge e:G.adj(v))&#123; int w=e.other(v); if(marked[w])&#123; continue; &#125; //检查distTo中存储的是否是w距树最小的距离 if(e.weight()&lt;distTo[w])&#123; edgeTo[w]=e; distTo[w]=e.weight(); //添加或更新优先队列中的相关顶点的数据 if(pq.contains(w))&#123; pq.changeKey(w, distTo[w]); &#125;else&#123; pq.insert(w, distTo[w]); &#125; &#125; &#125; &#125; //遍历最小生成树中的所有边 public Iterable&lt;Edge&gt; edges()&#123; Queue&lt;Edge&gt; q=new Queue&lt;Edge&gt;(); for(int v=0;v&lt;edgeTo.length;v++)&#123; Edge e=edgeTo[v]; if(e!=null)&#123; q.enqueue(e); &#125; &#125; return q; &#125;&#125; Kruskal算法Kruskal算法的核心是将图中所有的边按权重由小到大的顺序加入最小生成树，新加入的边不能与已经加入的边构成环。12345678910111213141516171819202122232425262728 public class KruskalMST &#123; private Queue&lt;Edge&gt;mst; public KruskalMST(EdgeWeightGraph G)&#123; mst=new Queue&lt;Edge&gt;(); //创建最小优先队列，并存储图中所有的边 MinPQ&lt;Edge&gt; pq=new MinPQ&lt;Edge&gt;(G.E()); for(Edge e:G.edges())&#123; pq.insert(e); &#125; //创建并查集Union_Find中的一个形式Quick_find Quick_find uf=new Quick_find(G.V()); while(!pq.isEmpty() &amp;&amp; mst.size()&lt;G.V()-1)&#123; Edge e=pq.deleteMin(); int v=e.either(); int w=e.other(v); //判断这条边的两个顶点是否连通，如果已经连通那么再加入这条边就会形成一个环 if(uf.connected(v, w))&#123; continue; &#125; uf.union(v, w); mst.enqueue(e); &#125; &#125; public Iterable&lt;Edge&gt; edges()&#123; return mst; &#125;&#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-图]]></title>
    <url>%2F2018%2F10%2F10%2FJava%E7%AE%97%E6%B3%95-%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[无向图图的定义：A graph is a set of vertices and a collections of edges that each connect a pair of vertices.graph = edge + vertex 图的表示邻接矩阵假设图有V个顶点，使用一个V*V的布尔矩阵a来表示图，顶点v和顶点w相连那么a[v,w]和a[w,v]都设置为true，相连设置为false。 邻接矩阵在存储一个较大的图时是不可行的，所需要的巨大的空间无法满足。 邻接表邻接表是一个一顶点vertex为索引的列表数组，每一个索引代表一个顶点，数组在该索引处的元素是和该顶点相连接的顶点列表。使用邻接表实现的图有如下特点： 创建图使用的空间和V+E成正比 添加一条边时间为常数 遍历顶点v相邻的顶点所需时间和v的度数成正比 用邻接表创建的Graph数据结构：12345678910111213141516171819202122232425262728293031323334353637383940414243public class Graph &#123; private int V; //顶点数目 private int E; //边的条数 private Bag&lt;Integer&gt;[] adj; //邻接表 public Graph()&#123;&#125; //初始化顶点为V的邻接表 public Graph(int V)&#123; this.V=V; this.E=0; adj=(Bag&lt;Integer&gt;[]) new Bag[V]; for(int i=0;i&lt;V;i++)&#123; adj[i]=new Bag&lt;Integer&gt;(); &#125; &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; public void addEdg(int v,int w)&#123; adj[v].add(w); adj[w].add(v); E++; &#125; public Iterable&lt;Integer&gt; adj(int v)&#123; return adj[v]; &#125; public int degree(int v)&#123; return adj[v].size(); &#125; public String toString()&#123; String s=V+" vertices"+E+" edges\n"; for(int i=0;i&lt;V;i++)&#123; s+=i+":"; for(int j:this.adj[i])&#123; s+=j+" "; &#125; s+="\n"; &#125; return s; &#125;&#125; 深度优先搜索深度优先搜索类似于走迷宫的Tremaux搜索。从一个没有走过的路口开始，走过的路铺一条绳子；标记走过的路口；当来到标记的路口，一直回退到有没被标记的路口继续走，如果回退时一直无路可走就一直回退到起点。 深度优先搜索类似于走迷宫，一直寻找没有被访问的节点深度优先搜索需要用递归的方法遍历图中所有的顶点 将访问的节点标记 递归的访问它的所有没有被标记的邻居节点深度优先代码如下： 12345678910111213141516171819202122public class DFS&#123; private boolean[] marked; private int count; public DFS(Graph G,int s)&#123; marked=new boolean[G.V()]; dfs(G,s); &#125; private void dfs(Graph G,int s)&#123; marked[s]=true; for(int v:G.adj[s])&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; public boolean marked(int w)&#123; return marked[m]; &#125; public int count()&#123; return count; &#125;&#125; 下面是DFS的搜索轨迹图： 深度优先搜索可以遍历图中所有的顶点和边，利用DFS可以解决图中的一些问题： 连通性问题：给定的两个顶点是否相连 单点问题，路径问题：某一起点与任意联通顶点的路径下面为利用DFS查找图中的路径的算法程序 12345678910111213141516171819202122232425262728293031323334353637 public class DepthFirstPaths &#123; private boolean[] marked;//用于标记顶点是否被访问过 private int[] edgeTo; //记录从起点到一个顶点的路径上的最后一个顶点 private int s; public DepthFirstPaths(Graph G,int s)&#123; this.s=s; marked=new boolean[G.V()]; edgeTo=new int[G.V()]; dfs(G,s); &#125; //深度优先算法DFS private void dfs(Graph G,int v)&#123; marked[v]=true; for(int w:G.adj(v))&#123; if(!marked[w])&#123; edgeTo[w]=v; dfs(G,w); &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return marked[v]; &#125; //返回起点到某个顶点的路径 public Iterable&lt;Integer&gt; pathTo(int v)&#123; if(!hasPathTo(v))&#123; return null; &#125; Stack&lt;Integer&gt; path=new Stack&lt;Integer&gt;(); for(int x=v;x!=s;x=edgeTo[x])&#123; path.push(x); &#125; path.push(s); return path; &#125;&#125; 下图为DFS搜索路径的轨迹实例图 广度优先搜索我们常要解决的问题是图中两个点之间最短的路径问题，DFS可以找出两点间的联通路径，却没办法找到最短的路径，但广度优先搜索可以解决这个问题。 在广度优先搜索中我们是按照与起点的距离的顺序遍历所有结点，这里用到了队列（先进先出，就近遍历）；首先将起点标记并加入队列，重复以下步骤直到队列为空： 将队列中的下一个顶点v出队，并将其标记； 将与v相邻且未被标记的顶点按顺序依次入队；BFS搜索路径算法： 12345678910111213141516171819202122232425262728293031323334353637383940414243 public class BreadthFirstPaths &#123; private boolean[] marked;//用于标记顶点是否被访问过 private int[] edgeTo; //记录从起点到一个顶点的路径上的最后一个顶点 private int s; public BreadthFirstPaths(Graph G,int s)&#123; this.s=s; marked=new boolean[G.V()]; edgeTo=new int[G.V()]; bfs(G,s); &#125; //广度优先算法BFS private void bfs(Graph G,int s)&#123; Queue&lt;Integer&gt; queue=new Queue&lt;Integer&gt;(); marked[s]=true; queue.enqueue(s); while(!queue.isEmpty())&#123; int v=queue.dequeue(); for(int w:G.adj(v))&#123; if(!marked[w])&#123; edgeTo[w]=v; marked[w]=true; queue.enqueue(w); &#125; &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return marked[v]; &#125; //返回起点到某个顶点的路径 public Iterable&lt;Integer&gt; pathTo(int v)&#123; if(!hasPathTo(v))&#123; return null; &#125; Stack&lt;Integer&gt; path=new Stack&lt;Integer&gt;(); for(int x=v;x!=s;x=edgeTo[x])&#123; path.push(x); &#125; path.push(s); return path; &#125;&#125; 下图为BFS实例中搜索轨迹图： 用BFS检测给定的图是无环的吗。用BFS检测是否是二分图（即任意一条边的两个顶点都不属于同一连通集） DFS和BFS具有不同的搜索路径： 深度优先搜索是不断深入图中，探索距离起点越来越远的顶点，只有碰到访问过的顶点或者死胡同时才返回到最近的顶点；广度优先搜索像扇面一样前进，它只有访问了一个顶点附近相邻的所有顶点之后才继续向前探索；DFS的路径通常长而曲折，而BFS路径短而整齐直接。 如下图所示两种搜索方式的路径对比： 连通分量DFS解决连通性问题用深度优先搜索来查找图中所有的连通分量的算法123456789101112131415161718192021222324252627282930313233343536public class CC&#123; private boolean[] marked; //用来标记顶点是否被访问过 private int[] id; //用来标记所属的连通集 private int count; //表示连通集 public CC(Graph G)&#123; marked=new boolean(G.V()); id=new int(G.V()); for(int s=0;s&lt;G.V();s++)&#123; if(!marked[s])&#123; dfs(G,s); count++; &#125; &#125; &#125; public dfs(Graph G,int v)&#123; marked[v]=true; id[v]=count; for(int s:G.adj[v])&#123; if(!marked[s])&#123; dfs(G,s); &#125; &#125; &#125; //判断两个顶点是否属于同一个连通分量 public boolean connect(int v,int w)&#123; return id[v]==id[w]; &#125; //返回顶点所在的连通集 public int id(int v)&#123; return id[v]; &#125; //返回有几个连通分量 public int count()&#123; return count; &#125;&#125;下图为搜索图中所有连通分量的轨迹： 并查集解决连通性问题Union_Find：并查集能解决动态连通性问题，union()会将两个分量合并到同一连通分量，fins()会返回给定点所在的连通分量的标识符，connect()会判断两个点是否在同一连通分量，count()会返回连通分量的数量。123456789101112131415161718192021 //并查集抽象类，关键的是抽象的方法find和union abstract class Union_Find &#123; protected int[] id; protected int count; public Union_Find(int N)&#123; count=N; id=new int[N]; for(int i=0;i&lt;N;i++)&#123; id[i]=i; &#125; &#125; public int count()&#123; return count; &#125; public boolean connected(int p,int q)&#123; return find(p)==find(q); &#125; public abstract int find(int p); public abstract void union(int p,int q); &#125; Quick Find快速查找算法：id[]这个数组标记着结点所在的连通集，将在同一连通集的结点的id[]值设置为同一个值，当将两个连通集合并的时候，将一个连通集内的所有结点的id[]值改为另一个连通集的id[]值。 这种算法不适合处理大型问题，以为find速度很快，但是union速度非常慢，需要将其中一个连通分量中的所有节点 id 值都修改为另一个节点的 id 值 1234567891011121314151617181920212223 //快速查找算法public class Quick_find extends Union_Find &#123; public Quick_find(int N)&#123; super(N); &#125; public int find(int p)&#123; return id[p]; &#125; public void union(int p,int q)&#123; int pID=find(p); int qID=find(q); if(pID==qID)&#123; return; &#125; for(int i=0;i&lt;id.length;i++)&#123; if(id[i]==pID)&#123; id[i]=qID; &#125; &#125; count--; &#125;&#125; Quick Union需要一种快速union的算法，只需要修改一下id[]数组的结构，每个点对应的id[]元素都是同一连通分量的其它点，这叫做链接。一个结点由链接找到指向它的另一个结点，这个节点再继续查找，以此类推知道找到这个连通集的根节点，类似以树结构。 union操作时只需将一个连通集的根节点指向另一个连通集的根节点 这种算法union操作很高效，find操作时间复杂度和树的高度成正比，最坏情况下树的高度为结点个数 quick-union算法123456789101112131415161718192021//快速合并算法public class Quick_Union extends Union_Find &#123; public Quick_Union(int N) &#123; super(N); &#125; public int find(int p)&#123; while(p!=id[p])&#123; p=id[p]; &#125; return p; &#125; public void union(int p,int q)&#123; int pID=find(p); int qID=find(q); if(pID==qID)&#123; return; &#125; id[pID]=qID; count--; &#125;&#125; 加权Quick Union为了防止quick-union最坏情况的发生，改进quick-union为加权quick-union算法 做法是记录被一个连通集的大小，union时将小的连通集指向大的连通集，这样生成的连通集会很平衡 加权的quick-union算法能够实现lgN对数级别的性能 123456789101112131415161718192021222324252627282930313233343536373839404142434445 //加权快速合并算法public class WeightedQuickUnion &#123; private int[] id; private int[] sz; private int count; public WeightedQuickUnion(int N)&#123; count=N; id=new int[N]; for(int i=0;i&lt;N;i++)&#123; id[i]=i; &#125; sz=new int[N]; for(int i=0;i&lt;N;i++)&#123; sz[i]=1; &#125; &#125; public int count()&#123; return count; &#125; public boolean connected(int p,int q)&#123; return find(p)==find(q); &#125; public int find(int p)&#123; while(p!=id[p])&#123; p=id[p]; &#125; return p; &#125; public void union(int p,int q)&#123; int pID=find(p); int qID=find(q); if(pID==qID)&#123; return; &#125; if(sz[pID]&lt;sz[qID])&#123; id[pID]=qID; sz[qID]+=sz[pID]; &#125;else&#123; id[qID]=pID; sz[pID]+=sz[qID]; &#125; count++; &#125;&#125; 有向图有向图：由一组顶点和一组有向的边组成的。 有向图也用邻接表表示，与无向图不同的是无向图制定了a通向b，即a-&gt;b,那么同时就有b-&gt;a;但有向图不一样，当指定了a-&gt;b没有b-&gt;a。 有向图的数据结构只有addEdg()方法不同，去掉注释的语句：12345public void addEdg(int v,int w)&#123; adj[v].add(w); #adj[w].add(v); E++;&#125; 有向图的可达性单点可达性：一个图和一个起点s–&gt;是否存在从s到v的有向路径多点可达性： 一个图和一个顶点集合–&gt;是否存在从集合任意顶点到达给定顶点的有向路径 12345678910111213141516171819202122232425262728293031 public class DirectedDFS &#123; private boolean[] marked; //单点可达判断 public DirectedDFS(Digraph G,int s)&#123; marked=new boolean[G.V()]; dfs(G,s); &#125; //多点可达判断 public DirectedGFS(Digraph G,Iterable&lt;Integer&gt; sources)&#123; marked=new boolean[G.V()]; for(int s:sources)&#123; if(!marked[s])&#123; dfs(G,s); &#125; &#125; &#125; //深度优先搜索 private void dfs(Digraph G,int v)&#123; marked[v]=true; for(int w:G.adj[v])&#123; if(!marked[w])&#123; dfs(G,w); &#125; &#125; &#125; //判断一个点是否可达 public boolean marked(int v)&#123; return marked[v]; &#125;&#125; 图中的环和有向无环图有些问题是不允许图中有有向环的可以用DFS检测一个图是否是有向无环图代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class DirectedCycle &#123; private boolean[] marked; //标记顶点 private int[] edgeTo; //标记指向的顶点 private Stack&lt;Integer&gt; cycle; //存储有向环中的顶点 private boolean[] onStack; //标记递归调用的栈上的所有顶点 public DirectedCycle(Digraph G)&#123; marked=new boolean[G.V()]; edgeTo=new int[G.V()]; onStack=new boolean[G.V()]; for(int v=0;v&lt;G.V();v++)&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; private void dfs(Digraph G,int v)&#123; marked[v]=true; onStack[v]=true; for(int w:G.adj(v))&#123; if(this.hasCycle())&#123; return; &#125;else if(!marked[w])&#123; edgeTo[w]=v; dfs(G,w); &#125;else if(onStack[w])&#123; cycle=new Stack&lt;Integer&gt;(); for(int x=v;v!=w;v++)&#123; cycle.push(x); &#125; cycle.push(w); cycle.push(v); &#125; &#125; onStack[v]=false; &#125; public boolean hasCycle() &#123; // TODO Auto-generated method stub return cycle!=null; &#125; public Iterable&lt;Integer&gt; cycle()&#123; return cycle; &#125;&#125; 拓扑排序对于有向图深度优先搜索只会访问图中每个顶点一次将DFS访问的顶点存储在一个数据结构，遍历这个数据结构就能按一定顺序得到图中所有的顶点根据数据结构的不同和保存节点的时间不同分成三种顺序： 前序：队列-&gt;在递归调用前将点入队 后序：队列-&gt;在递归调用之后将顶点入队 逆后序:栈-&gt;在递归之后将顶点入栈 代码如下：1234567891011121314151617181920212223242526272829303132333435363738 public class DepthFirstOrder &#123; private boolean[] marked; private Queue&lt;Integer&gt; pre; //所有顶点的前序排列 private Queue&lt;Integer&gt; post; //所有顶点的后序排列 private Stack&lt;Integer&gt; reverpost; //所有顶点的逆后排序 public DepthFirstOrder(Digraph G)&#123; pre=new Queue&lt;Integer&gt;(); post=new Queue&lt;Integer&gt;(); reverpost=new Stack&lt;Integer&gt;(); marked=new boolean[G.V()]; for(int v=0;v&lt;G.V();v++)&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; private void dfs(Digraph G,int v)&#123; pre.enqueue(v); //递归之前入队 marked[v]=true; for(int w:G.adj(v))&#123; if(!marked[w])&#123; dfs(G,w); &#125; &#125; post.enqueue(v); //低估后入队 reverpost.push(v); &#125; public Iterable&lt;Integer&gt; pre()&#123; return pre; &#125; public Iterable&lt;Integer&gt; post()&#123; return post; &#125; public Iterable&lt;Integer&gt; reverpost()&#123; return reverpost; &#125;&#125; 拓扑排序：是对有向无环图的排序，给定一幅图，将所有顶点排序，使所有的有向边从排在前面的元素指向排在后面的元素，如果有一条路径从v-&gt;w，那么排序后v就要在w的前面拓扑排序主要用来对有依赖关系的事物排序一个有向无环图的拓扑排序顺序即所有顶点逆后序排列给定的一个图先判断是否无环，然后利用DepthFirstOrder返回逆后序顶点就是拓扑排序的结果1234567891011121314 public class Topological &#123; private Iterable&lt;Integer&gt; order; public Topological(Digraph G)&#123; DirectedCycle dc=new DirectedCycle(G); //判断是否是有向无环图 if(!dc.hasCycle())&#123; DepthFirstOrder dfs=new DepthFirstOrder(G); order=dfs.reverpost(); &#125; &#125; public Iterable&lt;Integer&gt; order()&#123; return order; &#125;&#125; 有向图的强连通性强连通：有向图中如果两个顶点互相可达则这两个点是强连通的强连通分量：有向图中的一个强连通分量是图中的一个最大的顶点集合C，对于C中的每一对顶点u和v，u和v是强连通的 识别计算有向图中的强连通分量：Kosaraju算法 对于一个有向图G，使用DepthFirstOrder来计算它的反向图GR的逆后序排序列 按照的到的GR的逆后序列的顺序在G中进行深度优先搜索 下列代码可以判断两个顶点是否强连通，查找并计算所有的强连通分量1234567891011121314151617181920212223242526272829303132333435363738public class KosarajuSCC &#123; private boolean[] marked; //用来标记顶点是否被访问过 private int[] id;//记录强连通分量的标识 private int count;//记录强连通分量的数量 public KosarajuSCC(Digraph G)&#123; marked=new boolean[G.V()]; id=new int[G.V()]; DepthFirstOrder order=new DepthFirstOrder(G.reverse());//计算GR的逆后序列 for(int s:order.reverpost())&#123; if(!marked[s])&#123; dfs(G,s); count++; &#125; &#125; &#125; private void dfs(Digraph G, int v) &#123; marked[v]=true; id[v]=count; for(int w:G.adj(v))&#123; if(!marked[w])&#123; dfs(G,w); &#125; &#125; &#125; //判断两顶点是否强连通 public boolean stronglyConnected(int v,int w)&#123; return id[v]==id[w]; &#125; //返回顶点所在的强连通分量 public int id(int v)&#123; return id[v]; &#125; //返回强连通分量的数量 public int count()&#123; return count; &#125;&#125;]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-查找（散列表）]]></title>
    <url>%2F2018%2F09%2F29%2FJava%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE%EF%BC%88%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[散列查找在查找算法中如果利用数组将要存储的键作为数组索引下标，将对应的值作为数组的内容，在预先知道所要查找的内容在数组的下标可以实现快速查找，实现时间复杂度为O(1)的算法。由于键值可能是各种类型的，可能是整数、可能是字符串类型不能直接作为数组的索引，所以第一步就是要通过散列函数将键转化为数组的索引值。由于散列函数在转化过程中不同的键可能变成相同的索引值，出现碰撞冲突，所以第二步就要处理碰撞冲突。 散列函数如果保存键值的数组大小为M，那么键值通过散列函数就要转化在[0,M-1]的索引范围内，我们需要的散列函数能够将键值均匀的分布在[0,M-1]内，每个键都有相同的可能与0~M-1红的每个整数对应。 我们所使用的散列函数能够均匀并独立的将所有的键分布于0到M-1之间 由于键值的数据类型不同，所需要的散列函数也不同，每种类型都有与之对应的散列函数 整数类型对于整数类型常用的方法是除留余数法:k%M最好使用不是2的幂的质数 浮点数将键表示为二进制然后使用除留余数法 字符串下面为String类型中计算hash值得算法 1234567891011public int hashCode() &#123; int h = hash; //hash是初始值，一般为0 if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; 组合键下面为自定义类的hashcode算法，它将类中的所有成员变量综合起来计算hash值 默认的hashcode函数返回对象的地址 123456789101112131415public class Person &#123; private String name; private int age; private String sex; private String city; public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((city == null) ? 0 : city.hashCode()); result = prime * result + ((name == null) ? 0 : name.hashCode()); result = prime * result + ((sex == null) ? 0 : sex.hashCode()); return result; &#125;&#125; 将hashcode()的返回值转化为数组索引 1234 public int hash(Key k)&#123; return (k.hashCode() &amp; 0x7fffffff) % M;&#125; &amp;的作用是将计算出的hashCode值得符号位屏蔽 基于拉链法的散列表拉链法：保存数组的大小为M，将数组的每一个元素指向一个链表，每个链表中都存储键值相同的元素。 12345678910111213141516171819202122232425262728293031323334 public class SeparateChainingHashST&lt;Key,Value&gt; &#123; private int N;//键值对总数 private int M;//散列表大小 private SequentialSearchST&lt;Key,Value&gt;[] st;//存储链表的数组 public SeparateChainingHashST(int M) &#123; this.M = M; st=(SequentialSearchST&lt;Key,Value&gt;[]) new SequentialSearchST[M]; for(int i=0;i&lt;M;i++)&#123; st[i]=new SequentialSearchST(); &#125; &#125; private int hash(Key key)&#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; public Value get(Key key)&#123; return st[hash(key)].get(key); &#125; public void put(Key key,Value val)&#123; st[hash(key)].put(key, val); &#125; public void delete(Key key)&#123; st[hash(key)].delete(key); &#125; public Iterable&lt;Key&gt; keys()&#123; Queue&lt;Key&gt; queue=new Queue&lt;Key&gt;(); for(int i=0;i&lt;M;i++)&#123; for(Key key:st[i].keys())&#123; queue.enqueue(key); &#125; &#125; return queue; &#125;&#125; 拉链法的散列表性能分析： 一张含有M个链表和N个键的散列表中，未命中的查找和插入所需要的比较次数大约为N/M 需要选择合适的M：如果M过大会空链表多浪费空间资源，但查找速度快；M过小链表平均长度变长，查找效率低；应该选择足够大的M能够将性能提高M倍。也可以选择动态调整数组大小 基于线性探测法的散列表（开放地址散列表）线性探测法：通过哈希函数将键值k转化成数组索引值n，检查数组索引为n的位置会出现三种情况 该位置键值为空，将键值对插入该位置 该位置的键和被查找的键相同，如果查找操作返回查找内容，如果插入操作将键所对应的值换成新值 该位置的键和被查找的键不同，则增大索引继续检查下一个键值，知道找到该键或者遇到一个空元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class LinearProbingHashST&lt;Key,Value&gt; &#123; private int N; private int M; private Key[] keys; private Value[] vals; public LinearProbingHashST(int M)&#123; this.M=M; keys=(Key[]) new Object[M]; vals=(Value[]) new Object[M]; &#125; private int hash(Key key)&#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; public boolean contains(Key key)&#123; return get(key)!=null; &#125; private void resize(int cap)&#123; LinearProbingHashST&lt;Key,Value&gt; t=new LinearProbingHashST&lt;Key,Value&gt;(cap); for(int i=0;i&lt;M;i++)&#123; if(keys[i]!=null)&#123; t.put(keys[i], vals[i]); &#125; &#125; keys=t.keys; vals=t.vals; M=t.M; &#125; public void put(Key key,Value val)&#123; //N/M&gt;=1/2调整到1/4，使N/M保持在(1/8~1/2) if(N&gt;=M/2)&#123; resize(2*M); &#125; for(int i=hash(key);keys[i]!=null;i=(i+1)%M)&#123; if(key.equals(keys[i]))&#123; vals[i]=val; return; &#125; keys[i]=key; vals[i]=val; N++; &#125; &#125; public Value get(Key key)&#123; for(int i=hash(key);keys[i]!=null;i=(i+1)%M)&#123; if(keys[i].equals(key))&#123; return vals[i]; &#125; &#125; return null; &#125; public void delete(Key key)&#123; if(!contains(key))&#123; return; &#125; int i=hash(key); while(!keys[i].equals(key))&#123; i=(i+1)%M; &#125; keys[i]=null; vals[i]=null; i=(i+1)%M; while(keys[i]!=null)&#123; Key k=keys[i]; Value v=vals[i]; keys[i]=null; vals[i]=null; N--; put(k,v); i=(i+1)%M; &#125; N--; if(N&gt;0 &amp;&amp; N&lt;=M/8)&#123; resize(M/2); &#125; &#125; public Iterable&lt;Key&gt; keys()&#123; Queue&lt;Key&gt; queue=new Queue&lt;Key&gt;(); for(int i=0;i&lt;M;i++)&#123; if(keys[i]!=null)&#123; queue.enqueue(keys[i]); &#125; &#125; return queue; &#125; &#125; 线性探测法的性能分析：开放地址类的散列表的性能依赖于散列表的使用率p=N/M，我们一般会动态调整数组的大小是p保持在1/8~1/2之间。 在一张大小为M并包含有N=pM个键的基于线性探测的散列表中，命中和非命中查找所需要的探测次数为：~1/2(1+1/(1-p))和~1/2(1+1/(1-p)*(1-p)) 当p趋近1时，查找次数趋近于无穷；当p=1/2时，查找次数在[1.5,2.5]的范围呃内；所以动态调整数组大小减小p避免连列表过满，散列表快满时所需要的查找次数非常大。 散列表能够使查找和插入操作在时间复杂度上为常数级，理论上是最优的性能. 但它也有几个问题: 散列函数 :每种数据类型都需要优秀的散列函数，散列函数的计算可能复杂昂贵，一个好的散列函数直接影响着散列表的性能。 散列表不支持有序性操作：散列表中的键是无序的，如果你想快速找到最大最小值或者某个范围的键，散列表不合适因为这些操作都是线性级别的。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-Comparable和Comparator的区别]]></title>
    <url>%2F2018%2F09%2F24%2FJava-Comparable%E5%92%8CComparator%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[ComparableComparable接口是排序接口，实现了这个借口的数据类型或者类可以通过Collection.sort()和Arrays.sort()自动排序，此接口中有一个方法compareTo(). public int compareTo(T p); Comparable是内部比较器，需要在一个类的内部实现,在类中需要重写compareTo方法，在此方法中需要实现所要比较的方式，比如如下代码，比较两个对象的方式是先比较姓名，如果一样在比较年龄。 定义一个实现了Comparable接口的Person类12345678910111213141516171819202122232425262728public class Person implements Comparable&lt;Person&gt; &#123; private String name; private int age; public Person(String name,int age)&#123; this.name=name; this.age=age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int compareTo(Person p)&#123; int rest=this.name.compareTo(p.name); if(rest!=0)&#123; return rest; &#125;else&#123; return this.age-p.age; &#125; &#125;&#125; 测试Person类的排序123456789101112131415161718public class test &#123; public static void main(String[] args)&#123; Person p1=new Person("keluosi",27); Person p2=new Person("nuoyier",30); Person p3=new Person("luoyisi",26); System.out.println(p1.compareTo(p2)); Person[] people=new Person[]&#123;p1,p2,p3&#125;; System.out.println("before sort:"); for(Person p:people)&#123; System.out.println(p.getName()+"---"+p.getAge()); &#125; Arrays.sort(people); System.out.println("after sort:"); for(Person p:people)&#123; System.out.println(p.getName()+"---"+p.getAge()); &#125; &#125;&#125; ComparatorComparator是比较接口，如果一个类没有实现Comparable接口需要对该类排序，则可以设计一个实现Comparator接口的比较器，通过这个类的比较器就可以对该类排序。Comparator是外部比较器，和Comparale不同不需要在类中实现，在对一个类实现比较排序时可以不用修改该类的源代码，只需创建该类的比较器利用这个比较器就可以对该类进行排序。使用Comparator有两种方式：一种是创建实现Compartor接口的比较器，使用时直接创建该比较器的对象；另一种是直接在使用到比较器的地方创建一个匿名内部类。如下代码：实现了Person类的比较器：123456public class PersonComparator implements Comparator&lt;Person&gt; &#123; public int compare(Person p1,Person p2)&#123; int rest=p1.getName().compareTo(p2.getName()); return rest!=0 ? rest:p1.getAge()-p2.getAge(); &#125;&#125;使用测试：1234567891011121314151617181920212223242526public class test &#123; public static void main(String[] args)&#123; Person p1=new Person("keluosi",27); Person p2=new Person("nuoyier",30); Person p3=new Person("luoyisi",26); System.out.println(p1.compareTo(p2)); Person[] people=new Person[]&#123;p1,p2,p3&#125;; System.out.println("before sort:"); for(Person p:people)&#123; System.out.println(p.getName()+"---"+p.getAge()); &#125; //使用比较器，创建比较器的对象 PersonComparator pc=new PersonComparator(); Arrays.sort(people,pc); //创建匿名内部类，直接在使用Comparator的地方创建一个Comparator对象并重写compare方法 Arrays.sort(people,new Comparator&lt;Person&gt;()&#123; public int compare(Person p1,Person p2)&#123; return p1.getAge()-p2.getAge(); &#125; &#125;); System.out.println("after sort:"); for(Person p:people)&#123; System.out.println(p.getName()+"---"+p.getAge()); &#125; &#125;&#125; 对比：Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。 Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。 两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-查找（平衡查找树）]]></title>
    <url>%2F2018%2F09%2F22%2FJava%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE%EF%BC%88%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[2-3查找树https://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html 红黑树https://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-查找（二叉搜索树）]]></title>
    <url>%2F2018%2F09%2F22%2FJava%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE%EF%BC%88%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[二叉查找树是一棵二叉树，每个节点的键都大于左子树的任意节点的键，小于右子树的任意节点的键 二叉树的遍历方式分为先序，中序，后序，如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Traversal&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123; private Node root; public class Node&#123; private Key key; private Value val; private Node left; private Node right; private int N; public Node(Key key,Value val,int N)&#123; this.key=key; this.val=val; this.N=N; &#125; &#125; //先序遍历(根节点-&gt;左子树-&gt;右子树) public void PreOrderTraversal()&#123; PreOrderTraversal(root); &#125; //递归实现 private void PreOrderTraversal(Node x) &#123; if(x!=null)&#123; System.out.println(x.key+"---&gt;"+x.val); PreOrderTraversal(x.left); PreOrderTraversal(x.right); &#125; &#125;/* //非递归实现 private void PreOrderTraversal(Node x)&#123; &#125;*/ //中序遍历(左子树-&gt;根节点-&gt;右子树) //递归实现 private void InOrderTraversal(Node x) &#123; if(x!=null)&#123; PreOrderTraversal(x.left); System.out.println(x.key+"---&gt;"+x.val); PreOrderTraversal(x.right); &#125; &#125; //后序遍历(左子树-&gt;右子树-&gt;根节点 ) //递归实现 private void PostOrderTraversal(Node x) &#123; if(x!=null)&#123; PreOrderTraversal(x.left); PreOrderTraversal(x.right); System.out.println(x.key+"---&gt;"+x.val); &#125; &#125; &#125; 基本操作算法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198public class BST&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123; private Node root; public class Node&#123; private Key key; private Value val; private Node left; private Node right; private int N; public Node(Key key,Value val,int N)&#123; this.key=key; this.val=val; this.N=N; &#125; &#125; public int size(Node x)&#123; if(x==null)&#123; return 0; &#125;else&#123; return x.N; &#125; &#125; public void put(Key key,Value val)&#123; root=put(root,key,val); &#125; private Node put(Node x,Key key,Value val)&#123; if(x==null)&#123; return new Node(key,val,1); &#125; int cmp=key.compareTo(x.key); if(cmp&gt;0)&#123; x.right=put(x.right,key,val); &#125;else if(cmp&lt;0)&#123; x.left=put(x.left,key,val); &#125;else&#123; x.val=val; &#125; x.N=size(x.left)+size(x.right)+1; return x; &#125; public Value get(Key key)&#123; return get(root,key); &#125; private Value get(Node x,Key key)&#123; if(x==null)&#123; return null; &#125; int cmp=key.compareTo(x.key); if(cmp&gt;0)&#123; return get(x.right,key); &#125;else if(cmp&lt;0)&#123; return get(x.left,key); &#125;else&#123; return x.val; &#125; &#125; public Key min()&#123; return min(root).key; &#125; private Node min(Node x)&#123; if(x.left==null)&#123; return x; &#125; return min(x.left); &#125;/* //非递归实现 private Key min(Node x)&#123; if(x!=null)&#123; while(x.left!=null)&#123; x=x.left; &#125; &#125; return x; &#125;*/ //max()同理 public Key floor(Key key)&#123; Node x=floor(root,key); if(x==null)&#123; return null; &#125; return x.key; &#125; private Node floor(Node x,Key key)&#123; if(x==null)&#123; return null; &#125; int cmp=key.compareTo(x.key); if(cmp==0)&#123; return x; &#125;else if(cmp&lt;0)&#123; return floor(x.left,key); &#125;else&#123; //注意在右侧查找时可能找不到，这是应返回根节点，而不是在右侧直接返回 Node t=floor(x.right,key); if(t==null)&#123; return x; &#125;else&#123; return t; &#125; &#125; &#125; //ceiling同理 public Key select(int k)&#123; return select(root,k).key; &#125; private Node select(Node x,int k)&#123; if(x==null)&#123; return null; &#125; int t=size(x.left); if(t==k)&#123; return x; &#125;else if(t&gt;k)&#123; return select(x.left,k); &#125;else&#123; //注意右子树查找的数量 k-t-1 return select(x.right,k-t-1); &#125; &#125; public int rank(Key key)&#123; return rank(root,key); &#125; private int rank(Node x,Key key)&#123; if(x==null)&#123; return 0; &#125; int cmp=key.compareTo(x.key); if(cmp==0)&#123; return size(x.left); &#125;else if(cmp&lt;0)&#123; return rank(x.left,key); &#125;else&#123; //注意在右侧查找后返回的元素包括根节点和左子树元素 return rank(x.right,key)+size(x.left)+1; &#125; &#125; public void deleteMin()&#123; root=deleteMin(root); &#125; private Node deleteMin(Node x)&#123; if(x.left==null)&#123; return x.right; &#125; x.left=deleteMin(x.left); x.N=size(x.left)+size(x.right)+1; return x; &#125; //deleteMax()同理 //删除操作，删除一个元素时用这个节点右子树的最小值或者左子树的最大值代替 public void delete(Key key)&#123; root=delete(root,key); &#125; private Node delete(Node x,Key key)&#123; if(x==null)&#123; return null; &#125; int cmp=key.compareTo(x.key); if(cmp&lt;0)&#123; delete(x.left,key); &#125;else if(cmp&gt;0)&#123; delete(x.right,key); &#125;else&#123; if(x.left==null)&#123; return x.right; &#125; if(x.right==null)&#123; return x.left; &#125; Node t=x; x=min(t.right); x.right=deleteMin(t.right); x.left=t.left; &#125; x.N=size(x.left)+size(x.right)+1; return x; &#125; //范围查找 public Iterable&lt;Key&gt; keys(Key lo,Key hi)&#123; Queue&lt;Key&gt; queue=new Queue&lt;Key&gt;(); keys(root,queue,lo,hi); return queue; &#125; private void keys(Node x,Queue&lt;Key&gt; queue,Key lo,Key hi)&#123; if(x==null)&#123; return; &#125; int cmplo=lo.compareTo(x.key); int cmphi=hi.compareTo(x.key); if(cmplo&lt;=0 &amp;&amp; cmphi&gt;=0)&#123; queue.enqueue(x.key); &#125; if(cmphi&gt;0)&#123; keys(x.right,queue,lo,hi); &#125; if(cmplo&lt;0)&#123; keys(x.left,queue,lo,hi); &#125; &#125;&#125; 二叉查找树实现的符号表的时间复杂度是lgN,最坏情况下为N]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms, Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-查找(符号表)]]></title>
    <url>%2F2018%2F09%2F08%2FJava%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE-%E7%AC%A6%E5%8F%B7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[符号表定义定义：符号表是一种存储键值对的数据结构，支持两种操作：插入(put)，将一组新的键值对存入表中;查找(get),根据给定的键值的到对应的值。 一种有序的泛型符号表的API实现的对字符表的操作 字符表的实现无序链表实现无序字符表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 public class SequentialSearchST&lt;Key, Value&gt; &#123; private int n; // number of key-value pairs private Node first; // the linked list of key-value pairs // a helper linked list data type private class Node &#123; private Key key; private Value val; private Node next; public Node(Key key, Value val, Node next) &#123; this.key = key; this.val = val; this.next = next; &#125; &#125; public SequentialSearchST() &#123;&#125; public int size() &#123; return n; &#125; public boolean isEmpty() &#123; return size() == 0; &#125; public boolean contains(Key key) &#123; if (key == null) throw new IllegalArgumentException("argument to contains() is null"); return get(key) != null; &#125; public Value get(Key key) &#123; if (key == null) throw new IllegalArgumentException("argument to get() is null"); for (Node x = first; x != null; x = x.next) &#123; if (key.equals(x.key)) return x.val; &#125; return null; &#125; public void put(Key key, Value val) &#123; if (key == null) throw new IllegalArgumentException("first argument to put() is null"); if (val == null) &#123; delete(key); return; &#125; for (Node x = first; x != null; x = x.next) &#123; if (key.equals(x.key)) &#123; x.val = val; return; &#125; &#125; first = new Node(key, val, first); n++; &#125; /** * Removes the specified key and its associated value from this symbol table * (if the key is in this symbol table). * * @param key the key * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125; */ public void delete(Key key) &#123; if (key == null) throw new IllegalArgumentException("argument to delete() is null"); first = delete(first, key); &#125; // delete key in linked list beginning at Node x // warning: function call stack too large if table is large private Node delete(Node x, Key key) &#123; if (x == null) return null; if (key.equals(x.key)) &#123; n--; return x.next; &#125; x.next = delete(x.next, key); return x; &#125; /** * Returns all keys in the symbol table as an &#123;@code Iterable&#125;. * To iterate over all of the keys in the symbol table named &#123;@code st&#125;, * use the foreach notation: &#123;@code for (Key key : st.keys())&#125;. * * @return all keys in the symbol table */ public Iterable&lt;Key&gt; keys() &#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); for (Node x = first; x != null; x = x.next) queue.enqueue(x.key); return queue; &#125; 基于链表的实现及顺序查找是非常低效的向一个空表中插入N个不同的键需要~N*N/2次比较 基于有序数组的二分查找实现有序字符表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public class BinarySearchST&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123; private Key[] keys; private Value[] vals; private int N=0; //构造方法，初始化 public BinarySearchST(int capacity)&#123; keys=(Key[]) new Comparable[capacity]; vals=(Value[]) new Object[capacity]; &#125; public int size()&#123; return N; &#125; public boolean isEmpty()&#123; return N==0; &#125; public boolean contains(Key key)&#123; if(key==null)&#123; throw new IllegalArgumentException("argument to contains() is null"); &#125; return get(key)!=null; &#125; //二分查找 //迭代法 private int rank(Key key)&#123; int lo=0; int hi=N-1; while(lo&lt;=hi)&#123; int mid=lo+(hi-lo)/2; int cmp=keys[mid].compareTo(key); if(cmp&gt;0)&#123; hi=mid-1; &#125;else if(cmp&lt;0)&#123; lo=mid+1; &#125;else&#123; return mid; &#125; &#125; return lo; &#125; /* 递归法实现二分查找 public int rank(Key key,int lo,int hi)&#123; if(hi&lt;lo)&#123; return lo; &#125; int mid=lo+(hi-lo)/2; int cmd=keys[mid].compareTo(key); if(cmd&gt;0)&#123; return rank(key,lo,mid-1); &#125;else(cmd&lt;0)&#123; return rank(key,mid+1,hi); &#125;else&#123; return mid; &#125; &#125;*/ public Value get(Key key)&#123; if(key==null)&#123; throw new IllegalArgumentException("argument to get() is null"); &#125; if(isEmpty())&#123; return null; &#125; int i=rank(key); if(i&lt;N &amp;&amp; keys[i].compareTo(key)==0)&#123; return vals[i]; &#125;else&#123; return null; &#125; &#125; public void put(Key key,Value val)&#123; if(key==null)&#123; throw new IllegalArgumentException("argument to put() is null"); &#125; if(val==null)&#123; delete(key); return; &#125; int i=rank(key); if(i&lt;N &amp;&amp; keys[i].compareTo(key)==0)&#123; vals[i]=val; return; &#125; for(int j=N;j&gt;i;j--)&#123; keys[j]=keys[j-1]; vals[j]=vals[j-1]; &#125; keys[i]=key; vals[i]=val; N++; &#125; public void delete(Key key)&#123; if(key==null)&#123; throw new IllegalArgumentException("argument to delete() is null"); &#125; if(isEmpty())&#123; return; &#125; int i=rank(key); if(i==N || keys[i].compareTo(key)!=0)&#123; return; &#125; for(int j=i;j&lt;N-1;j++)&#123; keys[j]=keys[j+1]; vals[j]=vals[j+1]; &#125; N--; keys[N]=null; vals[N]=null; &#125; public Key min()&#123; return keys[0]; &#125; public Key max()&#123; return keys[N-1]; &#125; public Key select(int k)&#123; return keys[k]; &#125; public Key ceiling(Key key)&#123; int i=rank(key); return keys[i]; &#125; public Key floor(Key key)&#123; if (key == null) throw new IllegalArgumentException("argument to floor() is null"); int i = rank(key); if (i &lt; N &amp;&amp; key.compareTo(keys[i]) == 0) &#123; return keys[i]; &#125;else&#123; return keys[i-1]; &#125; &#125; public Iterable&lt;Key&gt; keys(Key lo,Key hi)&#123; Queue&lt;Key&gt; queue=new Queue&lt;Key&gt;(); for(int i=rank(lo);i&lt;rank(hi);i++)&#123; queue.enqueue(keys[i]); &#125; if(contains(keys[rank(hi)]))&#123; queue.enqueue(keys[rank(hi)]); &#125; return queue; &#125;&#125; 算法分析： 有序数组二分查找的各个操作的成本: BinarySearchST的算法实现了最优的查找效率~lgN，但是插入操作很慢~N，无法保证高效的查找和插入操作。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-排序（堆排序）]]></title>
    <url>%2F2018%2F09%2F04%2FJava%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%EF%BC%88%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[堆的定义堆这种数据结构是一种完全二叉树，堆分为最大堆和最小堆 最大堆：二叉树中的任一顶点大于等于它的左右子节点 最小堆：二叉树中的任一顶点小于等于它的左右子节点堆可以用数组来存储表示 优先队列优先队列（Priority Queue）：特殊的队列，取出元素的顺序按照元素的优先权或关键字的大小，不是元素入队的先后顺序。优先队列（堆）的使用场景： 1. 任何时候返回最值元素； 2. 数据太大存不下，要找出一定的最值元素； 3. 合并若干不同来源的已经排序的源（索引优先队列） 优先队列的实现方式： 基于堆的优先队列用堆实现优先队列的方法：注：以下代码存储数据时从数组的下标1开始代码实现：最大堆实现的最大优先队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 public class MaxPQ&lt;T extends Comparable&lt;T&gt;&gt;&#123; private T[] pq; //存队列数据的数组 private int N=0; //最终元素的个数 //构造函数 public MaxPQ(int maxN)&#123; pq=(T[])new Comparable[maxN+1]; &#125; //判断队列是否为空 public boolean isEmpty()&#123; return N==0; &#125; //返回队列元素个数 public int size()&#123; return N; &#125; //插入数据 public void insert(T v)&#123; pq[++N]=v; swim(N); &#125; //删除队列中最大元素并返回最大值 public T delMax()&#123; T max=pq[1]; exch(1,N--); pq[N+1]=null; sink(1); return max; &#125; //上浮 private void swim(int k)&#123; while(k&gt;1 &amp;&amp; less(k/2,k))&#123; exch(k/2,k); k=k/2; &#125; &#125; //下沉 private void sink(int k)&#123; while(2*k&lt;=N)&#123; int t=2*k; if(t&lt;N &amp;&amp; less(t,t+1))&#123; t++; &#125; if(less(k,t))&#123; exch(k,t); &#125;else&#123; break; &#125; k=t; &#125; &#125; private boolean less(int i,int j)&#123; return pq[i].compareTo(pq[j])&lt;0; &#125; private void exch(int i,int j)&#123; T temp=pq[i]; pq[i]=pq[j]; pq[j]=temp; &#125; public static void main(String[] args)&#123; MaxPQ&lt;Integer&gt; p=new MaxPQ&lt;Integer&gt;(10); int n=5; p.insert(88); p.insert(2); p.insert(56); p.insert(3); p.insert(42); while(n&gt;0)&#123; System.out.println(p.delMax()); n--; &#125; &#125;&#125; 代码实现的最主要的功能是实现元素的优先级，快速找到并删除最大元素，插入元素（自动调整）算法分析： 一颗大小为N的完全二叉树的高度为lgN； 含有N个元素的基于堆的优先队列，插入元素需要不超过lgN+1次比较，删除最大元素需要不超过2lgN次比较；最小堆实现的最小优先队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MinPQ&lt;T extends Comparable&lt;T&gt;&gt; &#123; private T[] pq; private int N; public MinPQ(int maxN)&#123; pq=(T[])new Comparable[maxN+1]; &#125; public boolean isEmpty()&#123; return N==0; &#125; public int size()&#123; return N; &#125; public void insert(T v)&#123; pq[++N]=v; swim(N); &#125; private void swim(int k)&#123; while(k&gt;1 &amp;&amp; less(k,k/2))&#123; exch(k,k/2); k=k/2; &#125; &#125; public T deleteMin()&#123; T min=pq[1]; exch(1,N--); sink(1); return min; &#125; private void sink(int k)&#123; while(2*k&lt;N)&#123; int t=2*k; if(t&lt;k &amp;&amp; less(t+1,t))&#123; t++; &#125; if(less(t,k))&#123; exch(t,k); &#125;else&#123; break; &#125; k=t; &#125; &#125; private boolean less(int v,int w)&#123; return pq[v].compareTo(pq[w])&lt;0; &#125; private void exch(int v,int w)&#123; T temp=pq[v]; pq[v]=pq[w]; pq[w]=temp; &#125;&#125; 索引优先队列优先队列的一个缺点是无法直接访问队列中的元素(除了直接找到最大或最小的元素)，对其更新修改。用过建立索引优先队列来实现快速索引。创建两个数组：elements[]用来存储队列中的对象(不需要按连续存储)，pq[]用来存储队列中每个对象在elements[]中的索引。 通过这两个数组建立的映射关系，在构建优先队列的时候，不需要变动elements[]，只需要维护改变pq中的元素即可。当向队列中插入一个新的对象时，在elements中存储该对象，将其索引存储在pq中，并对这个索引值进行上浮操作维护优先队列在操作队列时，如果想更改队列中某个对象，比如像将索引为3的位置改为”b”，那么直接操作elements[3]=”b”，这时需要重新调整维护优先队列，在pq数组中队值为3的元素操作，但是并不知道pq中那个位置的值是3，只能通过顺序遍历查找。为了方便查找pq中的元素，创建一个qp数组，将pq中元素作为索引在qp中存储该元素在pq中的索引。在队列的操作中经常要交换两个元素，交换pq中的两个元素的同事也要交换qp中相应位置的元素。索引最小优先队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class IndexMinPQ&lt;Key extends Comparable&lt;Key&gt;&gt; &#123; private int pq[]; private int qp[]; private Key keys[]; private int maxN; private int N; public IndexMinPQ(int maxN)&#123; this.maxN=maxN; N=0; pq=new int[maxN+1];//这些数组中0索引处不存储值 qp=new int[maxN+1]; keys=(Key[])new Comparable[maxN]; for(int i=0;i&lt;=maxN;i++)&#123; qp[i]=-1; &#125; &#125; public boolean isEmpty()&#123; return N==0; &#125; public int size()&#123; return N; &#125; public boolean contains(int i)&#123; //这里的i检查的是keys在索引i处是否有值 if(i&lt;0 || i&gt;maxN)&#123; throw new IllegalArgumentException(); &#125; return qp[i]!=-1; &#125; public void insert(int k,Key key)&#123; if ( k&lt; 0 || k&gt; maxN) throw new IllegalArgumentException(); if (contains(k)) throw new IllegalArgumentException("index is already in the priority queue"); keys[k]=key; pq[++N]=k; qp[k]=N; swim(N); &#125; //返回队列中的最小值 public Key minKey()&#123; return keys[pq[1]]; &#125; //删除并返回队列中的最小值 public Key deleteMin()&#123; if (N == 0) throw new NoSuchElementException("Priority queue underflow"); Key min=keys[pq[1]]; pq[1]=pq[N--]; sink(1); return min; &#125; //删除并返回队列中的某个值 public void delete(int k)&#123; if (k &lt; 0 || k &gt; maxN) throw new IllegalArgumentException(); if (!contains(k)) throw new NoSuchElementException("index is not in the priority queue"); int index=qp[k]; pq[index]=pq[N--]; swim(index); sink(index); keys[k]=null; qp[k]=-1; &#125; //改变队列中某个对象的值 public void changeKey(int k,Key key)&#123; if (k &lt; 0 || k &gt; maxN) throw new IllegalArgumentException(); if (!contains(k)) throw new NoSuchElementException("index is not in the priority queue"); keys[k]=key; swim(qp[k]); sink(qp[k]); &#125; //上浮调整 private void swim(int k)&#123; while(k&gt;1)&#123; if(less(k,k/2))&#123; exch(k,k/2); &#125; k=k/2; &#125; &#125; //下沉调整 private void sink(int k)&#123; while(2*k&lt;=N)&#123; int t=2*k; if(t&lt;N &amp;&amp; less(t+1,t))&#123; t=t+1; &#125; if(less(k,t))&#123; exch(k,t); &#125;else&#123; break; &#125; k=t; &#125; &#125; private boolean less(int k,int v)&#123; return keys[pq[k]].compareTo(keys[pq[v]])&lt;0; &#125; private void exch(int k,int v)&#123; int temp=pq[k]; pq[k]=pq[v]; pq[v]=temp; qp[pq[k]]=k; qp[pq[v]]=v; &#125;&#125; 堆排序堆排序分为两个阶段，给定一个无序的数组，首先要做的事构造堆。a.将无需序列构建成一个堆，根据升序降序需求选择最大堆或最小堆;b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端，N–将最大的元素固定,再次调整不在去管它;c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。对于给定的无序构造堆的一个高效方法就是从右向左进行sink下沉操作，不需要管叶子结点（叶子结点已经算作一个有堆，无法进行下沉操作），所以只需要扫描一半的数组元素。示意图：堆排序算法实现：123456789101112131415161718192021222324252627282930313233343536373839 public class HeapSort&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; @Override public void sort(T[] a)&#123; //数组a[0]不存储哨兵，a[0]的值一般用作，从a[1]开始 int N=a.length-1; //构建堆 for(int k=N/2;k&gt;=1;k--)&#123; sink(a,k,N); &#125; //堆排序 while(N&gt;1)&#123; exch(a,1,N--); sink(a,1,N); &#125; &#125; private void sink(T[] a,int k,int N)&#123; while(2*k&lt;=N)&#123; int j=2*k; if(j&lt;N &amp;&amp; less(a[j],a[j+1]))&#123; j++; &#125; if(less(a[k],a[j]))&#123; exch(a,k,j); &#125;else&#123; break; &#125; k=j; &#125; &#125; public static void main(String[] args)&#123; HeapSort&lt;String&gt; b=new HeapSort&lt;String&gt;(); String[] str=&#123;"q","sss","aaa","ccc","qqq","bbb"&#125;; b.sort(str); for(int i=1;i&lt;=str.length-1;i++)&#123; System.out.println(str[i]); &#125; &#125;&#125; 算法分析： 用下沉法构建堆（N个元素）只需少于2N次比较和少于N次的交换； 对N个元素的堆排序，需要少于（2NlgN+2N)次比较，一半次数的交换； 多种算法比较快速排序是最快的通用排序方法因为快速排序内循环指令少，他还能利用缓存（因为总是顺序访问数组），时间复杂度都是~cNlgN,使用三向切分后可能将某些时间复杂度变为线性级的。 Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql]]></title>
    <url>%2F2018%2F09%2F04%2FMysql%2F</url>
    <content type="text"><![CDATA[Mysql基本操作登陆数据库： mysql -u root -p 退出数据库： exit; 数据库操作创建数据库 create database 数据库名; create database 数据库名 character set 字符集（utf8) collate 校对规则; 删除数据库 drop database 数据库名; 查看数据库 show databases -查看所有数据库 show create database 数据库名 -查看创建的数据库的信息 修改数据库 alter database 数据库名 选中使用数据库 use 数据库名 表的操作创建表 create table 表名{ 列名1 数据类型（长度）约束； 列名2 数据类型（长度） 约束； ...... } 数据类型：https://www.cnblogs.com/Caveolae/p/7058890.htmlhttps://www.cnblogs.com/-xlp/p/8617760.html 约束：主键：primary key （唯一，一个表只有一个主键） 第一种–单一主键：id int primary key（列级）第二种–复合主键：primary key（id，name）设置多个主键（表级）在主键中设置自增：id int primary key auto_increment 外键：foreign key （一个表可以有多个外键） foreign key(外键） references 另一个表名（要关联的键）给外键起名：constraint dpt_fk foreign key(外键名） conferences 表名（关联的键） 默认值：default 非空：not null age int not null; 唯一约束：unique 第一种：email varchar(32) unique （列级）第二种：unique（id，email） —组合约束 （表级）第三种：constraint 约束名 unique（email） —约束起名字（表级） 操作表表重命名： rename table old to new； 删除表： drop table 表名； 增加列： alter table 表名 add 列名 数据类型 约束 after 列名; 可以指定新增列的位置 删除列： alter table 表名 drop 列名; 修改列： alter table 表名 modify 列名 数据类型 约束 改变表中数据 插入数据 insert into 表名(列1，列2，...) values(值1，值2...) or insert into 表名(列1，2...) values(值1，值2...),(v1,v2..),(v1,v2...)... 修改数据： update 表名 set 列1=值1，列2=值2 where 条件 删除数据： delete from 表名 where 条件 查询select语句 select * from 表名; select 列1，列2，... from 表名; select c1,c2,... from 表名 as 另一名; select c1 as p1,c2 as p2,... from 表名; select distinct c from 表名; ---去掉重复值 运算查询： select *,列的运算 as 名 from 表名; 条件查询： where 条件 select 查询内容 from 表名 where 条件 关系运算符 逻辑运算符 模糊查询 like where c like &apos;条件&apos; -：代表单个字符 %：代表多个字符 范围查询 in where c in (a1,a2,a3...) 排序查询： order by c asc/desc asc:ascend 升序 desc:descend 降序 聚合函数： select sum(number) from 表名; sum() avg() count() max() min() 分组： group by having:在group后，可以接聚合函数 where:在group之前，不可以接聚合函数 select ... from ... where ... group by ... having ... order by ...]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-排序（简单排序）]]></title>
    <url>%2F2018%2F08%2F20%2FJava%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[算法模板Comparable接口 Interface Comparable&lt;T&gt; 该接口对实现它的每个类的对象强加一个整体排序，这个排序被称为类的自然排序，类的compareTo方法被称为其自然比较方法 **int compareTo(T o)** 将此对象与指定的对象进行比较以进行排序 返回一个负整数，零或正整数，因为该对象小于，等于或大于指定对象 compareTo() 必须实现一个完整的比较序列，即： 自反性，对于所有的 v ， v=v ； 反对称性，对于所有的 v&lt;w 都有 v&gt;w ，且 v=w 时 w=v ； 传递性，对于所有的 v 、 w 和 x ，如果 v&lt;=w 且 w&lt;=x ，则 v&lt;=x 。 算法模板： 1234567891011121314151617181920212223242526272829public abstract class Sort&lt;T extends Comparable&lt;T&gt;&gt;&#123; public static void sort(T[] a)&#123; &#125; //比较数据大小 protected static boolean less (Tv,T w)&#123; return v.compareTo(w)&lt;0; &#125; //交换数据 protected static void exch(T[] a,int i,int j)&#123; T temp=a[i]; a[i]=a[j]; a[j]=temp; &#125; //输出显示排序好的数据 protected static void show(T[] a)&#123; for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]+" "); &#125; System.out.println(); &#125; //判断是否排序 public static boolean isSorted(T[] a)&#123; for(int i=1;i&lt;a.length;i++)&#123; if(less(a[i],a[i-1])) return false; &#125; return true; &#125;&#125; 注意：只要是实现了Comparable（自己定义的数据类型要重写compareTo方法）的数据类型都可以用次模板排序 选择排序12345678910111213public class Selection&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; @Override public static void sort(T[] a)&#123; int N=a.length; for(int i=0;i&lt;N;i++)&#123; int min=i; for(int j=i+1;j&lt;N;j++)&#123; if(less(a[j],a[min])) min=j; &#125; exch(a,i,min); &#125; &#125;&#125; 选择排序： 首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。 算法分析： 选择排序的效率取决于交换的次数：对于长度为 N 的数组，选择排序需要大约 N 2 /2 次比较和 N 次交换时间复杂度 T(N)=O(N*N); 运行时间和输入无关:已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间一样长 数据移动是最少的:选择排序用了 N 次交换,交换次数和数组的大小是线性关系 冒泡排序冒泡排序：从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。在一轮循环中，如果没有发生交换，就说明数组已经是有序的，此时可以直接退出。 12345678910111213141516public class Bubble&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; @Override public static void sort(T[] a)&#123; int N=a.length; boolean flag=false; for(int i=N-1;i&gt;0 &amp;&amp; !flag;i--)&#123; flag=true; for(int j=0;j&lt;i;j++)&#123; if(less(a[j+1],a[j]))&#123; exch(a,j,j+1); flag=false; &#125; &#125; &#125; &#125;&#125;``` 插入排序12345678910public class Insertion&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; public static &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] a)&#123; int N=a.length; for(int i=1;i&lt;N;i++)&#123; for(int j=i;j&gt;0 &amp;&amp; less(a[j],a[j-1]);j--)&#123; exch(a,j,j-1); &#125; &#125; &#125;&#125; 算法分析： 对于随机排列的长度为 N 且主键不重复的数组，平均情况下插入排序需要～ N 2 /4 次比较以及～ N 2 /4 次交换。最坏情况下需要～ N 2 /2 次比较和～ N 2 /2 次交换，最好情况下需要 N-1次比较和 0 次交换时间复杂度 T(N)=O(N*N) 插入排序所需的时间取决于输入中元素的初始顺序 插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一 插入排序对于实际应用中常见的某些类型的非随机数组很有效插入排序对于部分有序的数组十分高效，也很适合小规模数组 比较：对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数 希尔排序希尔排序：对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。 1234567891011121314151617public class Shell&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; public static &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] a)&#123; int N=a.length; int h=1; while(h&lt;N/3)&#123; h=h*3+1; &#125; while(h&gt;=1)&#123; for(int i=h;i&lt;N;i++)&#123; for(int j=i;j&gt;0 &amp;&amp; less(a[j],a[j-h]);j-=h)&#123; exch(a,j,j-h); &#125; &#125; h=h/3; &#125; &#125;&#125; 算法的性能不仅取决于 h，还取决于 h 之间的数学性质 目前最重要的结论是希尔排序的运行时间达不到平方级别 希尔排序比插入排序和选择排序要快得多，并且数组越大，优势越大 MergeSort(归并排序)In-place merge(原地归并)1234567891011121314151617181920public class Merge&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; protected T[] aux; protected void merge(T[] a,int lo,int mid,int hi)&#123; int i=lo; //左边数组的起始位置 int j=mid+1; ////右边数组的起始位置 for(int k=lo;k&lt;=hi;k++)&#123; aux[k] =a[k]; &#125; for(int k=lo;k&lt;=hi;k++)&#123; if(i&gt;mid)&#123; a[k]=aux[j++]; //左边的子数组用尽 &#125;else if(j&gt;hi)&#123; a[k]=aux[i++]; //右边的子数组用尽 &#125;else if(less(aux[j],aux[i]))&#123; a[k]=aux[j++]; &#125;else&#123; a[k]=aux[i++]; &#125; &#125; &#125; This method merges by first copying into the auxiliary array aux[] then merging back to a[]. In the merge (the second for loop), there are four conditions: left half exhausted (take from the right), right half exhausted (take from the left), current key on right less than current key on left (take from the right), current key on right greater than or equal to current key on left (take from the left). Top-down mergesort(自顶向下的归并排序)123456789101112131415public class UptoDpwnMergeSort&lt;T extends Comparable&lt;T&gt;&gt; extends Merge&#123; public void sort(T[] a)&#123; aux=(T[]) new Comparable[a.length]; sort(a,0,a.length-1); &#125; private void sort(T[] a,int lo,int hi)&#123; if(hi&lt;=lo)&#123; return; &#125; int mid=lo+(hi-lo)/2; sort(a,0,mid); sort(a,mid+1,hi); merge(a,lo,mid,hi); &#125;&#125; A: The code is a recursive(递归) mergesort implementation based on this abstract inplace merge. B: It is one of the best-known examples of the utility of the divide-and-conquer(分而治之) paradigm for efficient algorithm design C: the sort code simply provides an organized way to sequence the calls to the merge() method 算法分析： A: Top-down mergesort uses between ½ N lg N and N lg N compares to sort any array of length N时间复杂度：T(N)=O(N lg N) B: Top-down mergesort uses at most 6N lg N array accesses to sort an array of length N Bottom-up mergesort(自底向上的排序)1234567891011public class BottomtoUpMergeSort&lt;T extends Comparable&lt;T&gt;&gt; extends Merge&lt;T&gt; &#123; public void sort(T[] a)&#123; int N=a.length; aux = (T[]) new Comparable[a.length]; for(int sz=1;sz&lt;N;sz=sz+sz)&#123; for(int lo=0;lo&lt;N-sz;lo+=sz+sz)&#123; merge(a,lo,lo+sz-1,Math.min(lo+sz+sz-1, N-1)); &#125; &#125; &#125;&#125; 算法分析：Bottom-up mergesort uses between ½ N lg N and N lg N compares and at most 6N lg N array accesses to sort an array of length N. both the number of compares usedby mergesort in the worst case and the minimum number of compares that any compare-basedsorting algorithm can guarantee are ~N lg N 归并排序在最坏的情况下的比较次数和任意基于比较的排序算法所需的最少比较次数都是~ NlgN]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-排序（快速排序）]]></title>
    <url>%2F2018%2F08%2F18%2FJava%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%EF%BC%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[QuickSort（快速排序）The basic algorithm（基本算法）归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Quick&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; public void sort(T[] a)&#123; shuffe(a); //消除对输入的依赖 sort(a,0,a.length-1); &#125; private void sort(T[] a, int lo, int hi) &#123; if(hi&lt;=lo)&#123; return; &#125; int j=partition(a,lo,hi); //切分 sort(a,lo,j-1); //将左半边排序 sort(a,j+1,hi); //将右半边排序 &#125; //切分方法 private int partition(T[] a, int lo, int hi) &#123; int i=lo; int j=hi+1; T v=a[lo]; //选取lo处的元素作为分界元素 while(true)&#123; //从左向右扫描找到比v大的元素 while(less(a[++i],v))&#123; if(i==hi)&#123; break; &#125; &#125; //从右向左扫描找到比v小的元素 while(less(v,a[--j]))&#123; if(j==lo)&#123; break; &#125; &#125; if(i&gt;=j)&#123; break; &#125; exch(a,i,j);y &#125; exch(a,lo,j); return j; &#125; //打乱数组 private void shuffe(T[] a)&#123; List&lt;T&gt; list=Arrays.asList(a); Collections.shuffle(list); list.toArray(a); &#125;&#125; Performance characteristics（性能分析）A: advantagea: it is in-place (uses only a small auxiliary stack) (原地排序)b: it requires time proportional to N log N on the average to sort an array of length N (时间复杂度T(N)=O(NlgN))c: the inner loop of quicksort (in the partitioning method) increments an index and compares an array entry against a fixed value.(内循环短小) B: The best case for quicksort is when each partitioning stage divides the array exactlyin half. This circumstance would make the number of compares used by quicksort satisfy the divide-and-conquer recurrence CN = 2CN/2 + N，this recurrence has the solution CN ~ N lg N C: Quicksort uses ~ 2N ln N compares (and one-sixth that many exchanges)on the average to sort an array of length N with distinct keys. D: Quicksort uses ~ N * N/2 compares in the worst case, but random shuffling protects against this case.(最坏情况) Algorithmic improvements(算法改进)Cutoff to insertion sort (切换到插入排序)对小数组排序时插入排序的效率比快速排序的效率高，以为快速排序递归在小数组中调用自己耗费时间改进方法：将 if(hi&lt;=lo) return; 改为 if(hi&lt;=lo+M){ Insertion(a,lo,hi); return; } The optimum value of the cutoff M is system-dependent, but any value between 5 and 15 is likely to work well in most situations 这种方法主要用于提高对小型数组排序的速度问题 Median-of-three partitioning（三取样切分）Entropy-optimal sorting（三向切分的快速排序）这种算法是为了提高有大量重复元素的数组的排序效率，通过选定特定的切分元素v将数组切分为三个部分，小于v的元素、大于v的元素和小于v的元素123456789101112131415161718192021222324252627282930313233public class Quick3way&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; @Override public void sort(T[] a)&#123; shuffe(a); sort(a,0,a.length-1); &#125; private void sort(T[]a,int lo,int hi)&#123; if(hi&lt;=lo)&#123; return; &#125; int lt=lo; int i=lo+1; int gt=hi; T v=a[lo]; while(i&lt;=gt)&#123; int tep=a[i].compareTo(v); if(tep&lt;0)&#123; exch(a,i++,lt++); &#125;else if(tep&gt;0)&#123; exch(a,i,gt--); &#125;else&#123; i++; &#125; &#125; sort(a,lo,lt-1); sort(a,gt+1,hi); &#125; private void shuffe(T[] a)&#123; List&lt;T&gt; list=Arrays.asList(a); Collections.shuffle(list); list.toArray(a); &#125;&#125; 算法分析： 对于包含大量重复元素的数组，三向切分的快速算法比标准的快速算法效率高的多，排序时间从线性对数级降低到了线性级别。对于一个数组，它的所有主键的香农信息量 H=-(p1lgp1+p2lgp2 +…+pnlgpn) 大小为N的数组，三向切分需要~（2ln2)NH次比较 三向切分最坏的情况是当所有的主键不重复时，H=lgN，时间复杂度为NlgN，是线性对数级别的；一般情况下，三向切分的运行时间和输入的信息量的N倍成正比，是线性级别的。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-基本数据结构]]></title>
    <url>%2F2018%2F08%2F18%2FJava%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基本数据结构数组链表链表的节点表示1234public class Node&lt;Item&gt;&#123; Item item; Node next; &#125; 栈用链表实现栈 public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt;{ //栈顶指针 private Node first; //栈中元素数量 private int N; //定义节点 private class Node{ Item item; Node next; } //判断栈是否为空 public boolean isEmpty(){ return first==null; } //返回栈中元素数量 public int size(){ return N; } //压栈 public void push(Item item){ Node oldfirst=first; first=new Node(); first.item=item; first.next=oldfirst; N++; } //出栈 public Item pop(){ if(isEmpty()){ try { throw new Exception("stack is empty"); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } } Item item=first.item; first=first.next; N--; return item; } public Iterator&lt;Item&gt; iterator(){ return new Iterator&lt;Item&gt;(){ private Node current=first; @Override public boolean hasNext(){ return current!=null; } @Override public Item next(){ Item item=current.item; current=current.next; return item; } public void remove(){} }; } } 队列用链表实现队列 public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt; { private Node first; private Node last; private int N; private class Node{ Item item; Node next; } //判断队列是否为空 public boolean isEmpty(){ return N==0; } //返回队列中元素个数 public int size(){ return N; } //入队 public void enqueue(Item item){ Node oldlast=last; last=new Node(); last.item=item; last.next=null; if(isEmpty()){ first=last; }else{ oldlast.next=last; } N++; } //出队 public Item dequeue(){ if(isEmpty()){ try { throw new Exception("queue is empty"); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } } Item item=first.item; first=first.next; N--; if(isEmpty()){ last=null; } return item; } public Iterator&lt;Item&gt; iterator(){ return new Iterator&lt;Item&gt;(){ private Node current=first; @Override public boolean hasNext(){ return current!=null; } @Override public Item next(){ Item item=current.item; current=current.next; return item; } public void remove(){} }; } }]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-集合（容器）]]></title>
    <url>%2F2018%2F08%2F17%2FJava-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Collection网上博客教程：https://blog.csdn.net/feiyanaffection/article/details/81394745 public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; Collection接口的常用方法 添加功能 boolean add(E e) boolean addAll(Collection&lt;? extends E&gt; c) 添加一个集合的元素 删除功能 void clear() 从此集合中删除所有元素 boolean remove(Object o) boolean removeAll(Collection&lt;?&gt; c) 删除指定集合中包含的所有此集合的元素 判断功能 boolean contains(Object o) 如果此集合包含指定的元素，则返回true boolean containsAll(Collection&lt;?&gt; c) 如果此集合包含指定 集合中的所有元素，则返回true boolean isEmpty() 如果此集合不包含元素，则返回 true 长度功能 int size() 返回此集合中的元素数 交集功能 boolean retainAll(Collection&lt;?&gt; c) 两个集合都有的元素 a.retainAll(b) a和b做交集，结果保存在a中，b不变，返回的boolean值表示a是否发生变化 一、List public interface List&lt;E&gt; extends Collection&lt;E&gt; List-有序集合（存储和取出的元素一致）（也称为序列 ），可以精确控制列表中每个元素的插入位置，通过整数索引（列表中的位置）访问元素，并搜索列表中的元素，列表通常允许重复的元素 List的特有方法 void add(int index,E element) 将指定的元素插入此列表中的指定位置 E get(int index) 返回此列表中指定位置的元素 ListIterator&lt;E&gt; listIterator() 返回列表中的列表迭代器（按适当的顺序） E remove(int index) 删除该列表中指定位置的元素 E set(int index, E element) 用指定的元素替换此列表中指定位置的元素 List的类型分类各类型特点对比： ArrarList：底层数据结构是数组，查询快，增删慢 线程不安全，效率高 Vector： 底层数据结构是数组，查询快，增删慢 线程安全，效率低 LinkedList：低层数据结构是链表，查询慢（只能顺序访问），增删快 线程不安全，效率高 LinkedList还可以用作栈、队列、双向队列 LinkedListLinkedList的基本方法： public void addFirst(E e) 在列表的头部插入元素 public void addLast(E e) 在列表尾部插入元素 public E getFirst() 返回此列表中的第一个元素。 public E getLast() 返回此列表中的最后一个元素 public E removeFirst() 从此列表中删除并返回第一个元素 public E removeLast() 从此列表中删除并返回最后一个元素 二、迭代器 迭代器是一种对象，它的功能是遍历并选择序列中的对象。 Iterator迭代器Collection 实现了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。 Collection获取迭代器的方法： Iterator&lt;E&gt; iterator() 返回此集合中的元素的迭代器 Iterator接口的常用方法： boolean hasNext() 判断集合里是否有元素 E next() 获取元素并移动到下一个元素 集合的使用步骤： A:创建集合对象 Collection c = new ArrayList(); B:创建元素对象 Object obj=..... C：元素添加到集合 c.add(obj) D：遍历集合元素 a:用过集合获取迭代器对象 Iterator it = c.iterator() b:通过迭代器对象的hasNext()方法判断是否有元素 boolean flag = it.hasNext() c:通过迭代器next()方法获取元素 Object obje = it.next() 集合的遍历（以List类型为例，Set同理）第一种：迭代器遍历 //部分伪代码，E代表某种类型 List&lt;E&gt; list=new List&lt;E&gt;(); list.add(E a); list.add(E b); //假设list里已经添加多个E类型的对象，可以遍历 Iterator it=list.iterator(); while(it.hasNext()){ E e=it.next(); print(e); } 第二种：foreach方法（增强for循环） List&lt;E&gt; list=new List&lt;E&gt;(); list.add(E a); list.add(E b); ....... for(E e:list){ print(e); } ------------------- List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); for (String item : list) { System.out.println(item); } ListIteratorListIterator是Iterator的子类，只用于List类集合，Iterator只能单向移动，而ListIterator可以双向移动主要方法： 继承了Iterator的功能（hasNext(),next()) boolean hasPrevious() 返回true如果遍历反向列表，列表迭代器有多个元素 E previous() 返回列表中的上一个元素，并向后移动光标位置 int nextIndex() 返回由后续调用返回的元素的索引next() int previousIndex() 返回由后续调用previous()返回的元素的索引 三、Set与List集合不同的是，Set集合不保存重复的元素 TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素&gt;的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1),TreeSet 则为 O(logN) HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的 LinkedHashSet：具有 HashSet的查找效率，且内部使用双向链表维护元素的插入顺序 HashSet提供最快的查询速度，TreeSet保持元素处于排序状态，LinkedHashSet以插入顺序保存元素 HashSet保证集合元素唯一性的原理： 主要取决于HashSet的add()方法， add()方法中主要依赖于String.hashCode()和String.equals()方法, 定义类时应该重写这两个方法 TreeSet（排序，唯一不重复）: 基于TreeMap实现，使用元素的自然顺序对元素进行排序，或者使用set提供的comparator方法排序， 具体使用时取决于使用的构造方法 A:自然排序：真正依赖于compareTo()方法， 这个方法定义在Comparable中，所以想重写该方法，就要实现Comparable接口，这个接口表示自然排序 例如：定义学生类时实现Comparable接口 public class Student implements Comparable&lt;T&gt;{ @override public int compareTo(T t){ .......... 主要条件 次要条件 } } B:比较器排序:comparator方法, TreeSet的add()方法，是基于TreeMap方法的put()方法 public TreeSet(Comparator&lt;? super E&gt; comparator ) 构造一个新的，空的树集，根据指定的比较器进行排序 TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;(){ public int compare(Student s1,Student s2){ ........... } };) Mappublic interface Map&lt;K,V&gt; Map将键映射到值的对象。 地图不能包含重复的键; 每个键可以映射到最多一个值 Map的基本类型 TreeMap：基于红黑树实现，保证唯一性和排序 HashMap：基于哈希表实现 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。ConcurrentHashMap：现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序HashMap用来快速访问，TreeMap保持键排序，LinkedHashMap保持元素插入的顺序，也通过散列提供快速访问能力 Map基本方法功能 添加 V put(K key,V value) 将指定的值与该映射中的指定键相关联 如果键是第一次存储，直接存储元素，返回null； 如果不是第一次添加键值，就用新的值替换旧的值，并返回旧的值。 删除 void clear() 从该地图中删除所有的映射 V remove(Object key) 删除并返回 删除集合里存在的键，返回建的值，如果不存在返回null 判断 boolean containsKey(Object key) 如果此映射包含指定键的映射，则返回true boolean containsValue(Object value) 如果此映射将一个或多个键映射到指定的值，则返回true boolean isEmpty() 判断集合是否为空 获取 V get(Object key) 返回到指定键所映射的值 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此地图中包含的映射的Set视图 Set&lt;K&gt; keySet() 返回此地图中包含的键的Set视图 Collection&lt;V&gt; values() 返回此地图中包含的值的Collection视图 长度 int size() 返回此地图中键值映射的数量 Map集合的遍历 //创建集合 Map&lt;String,String&gt; map=new Map&lt;String,String&gt;(); //添加数据 map.put(&quot;德国&quot;,&quot;克罗斯&quot;); map.put(&quot;法国&quot;,&quot;格列兹曼&quot;); map.put(&quot;比利时&quot;,&quot;德布劳内&quot;); 方式一： //获取键值集合 Set&lt;String&gt; set=map.keySet(); for(String s:set){ v=map.get(s); System.out.println(s+&quot;---&gt;&quot;+v); } 方式二： //获取映射Set集合 Set&lt;Map.Entry&lt;String,String&gt; set=map.entrySet(); for(Map.Entry&lt;String,String&gt; m:set){ key=m.getKey(); value=m.getValue(); System.out.println(key+&quot;---&gt;&quot;+value); }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-网络编程]]></title>
    <url>%2F2018%2F08%2F11%2FJava-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[网络编程的三要素IP地址 概念：IP地址是网络中计算机的唯一标识 IP的组成：网络号+主机号 java提供了InetAddress类来对IP地址解析和操作 确定主机名称的IP地址public static InetAddress getByName(String host)获取此IP地址的主机名 public String getHostName() 端口 端口是正在运行程序的标识 协议 UDP 将数据源和目的地封装在数据包中，无连接，是不可靠协议，不需要建立连接，速度快 TCP 建立连接，形成传输数据的通道，在连接中进行大数据量的传输，通过三次握手完成连接，是可靠地，效率会低 Socket网络编程Socket包含了IP地址和端口号Socket原理机制：通信的两端都有Socket，网络通信其实是Socket间的通信，数据在两个Socket间通过IO传输 UDP UDP使用DatagramSocket类用于发送和接收数据报数据包 构造方法：public DatagramSocket()—发送数据使用的构造方法public DatagramSocket(int port)—接收数据使用的构造方法主要成员方法：public void close()关闭此数据报套接字public void send(DatagramPacket p)从此套接字发送数据报包public void receive(DatagramPacket p)从此套接字接收数据报包 发送和接收的数据是DatagramPacket类的，该类表示数据报包，send方法中需要传递DatagramPacket对象 构造方法：public DatagramPacket(byte[] buf,int length,InetAddress address,int port)–发送数据使用的构造方法public DatagramPacket(byte[] buf,int length) –接收数据使用的构造方法buf - 分组数据length - 包长度address - 目的地址port - 目的端口号主要成员方法：public byte[] getData()返回数据缓冲区public int getLength()返回要发送的数据的长度或接收到的数据的长度public InetAddress getAddress()返回该数据报发送或接收数据报的计算机的IP地址 UDP协议发送数据 1.创建发送端Socket对象 2.创建数据并打包 3.调用Socket对象的发送方法发送数据 4.释放资源 下面为实现UDP协议发送数据 public class send{ public static void main(String[] args){ //创建发送端Socket DatagramSocket ds=new DatagramSocket(); //创建数据并打包 byte[] bys=&quot;UDP协议发送的数据&quot;.getBytes(); int length=bys.length; //发送数据的目的IP地址 InetAddress address=InetAddress.getByName(&quot;主机名&quot;)； //发送端计算机的端口 int port=10086; DatagramPacket dp=new DatagramPacket(bys,length,address,port); //发送数据 ds.send(dp); //释放资源 ds.close(); } } UDP协议接收数据1.创建接收端Socket2.创建数据包接收数据（接受容器）3.用Socket接受方法接收数据4.解析数据输出5.释放资源 下面为实现UDP协议接收数据 public class Receive { public static void main(String[] args) throws IOException { // TODO Auto-generated method stub //创建接收端Socket DatagramSocket ds=new DatagramSocket(10086); //创建数据包接收 byte[] bys=new byte[1024]; int length=bys.length; DatagramPacket dp=new DatagramPacket(bys,length); //接收数据 ds.receive(dp); //解析数据 InetAddress address=dp.getAddress(); String ip=address.getHostAddress(); byte[] bys2=dp.getData(); int len=dp.getLength(); String s=new String(bys2,0,len); System.out.println(ip+&quot;:&quot;+s); //释放资源 ds.close(); } } TCPTCP协议发送数据 （客户端）1.创建发送端Socket2.获取输出流写数据3.释放资源 TCP发送客户端使用的是Socket类 构造方法：public Socket(InetAddress address,int port)public Socket(String host,int port)主要成员方法：public void close()关闭public OutputStream getOutputStream()返回此套接字的输出流 public class TSend { public static void main(String[] args) throws IOException { //创建Socket Socket s=new Socket(&quot;daw-PC&quot;,10086); //获取输出流写数据 OutputStream os=s.getOutputStream(); os.write(&quot;TCP发送数据&quot;.getBytes()); //释放资源 s.close(); } } TCP协议接收数据（服务器）1.创建接收端Socket2.监听客户端连接，返回对应的Socket对象3.获取输入流读数据4.释放资源 TCP接收客户端使用的是ServeSocket类 构造方法：public ServerSocket(int port)成员方法：public Socket accept()监听 ，返回的是Scoket类，所以需要Socket类的方法Socket类的—public InputStream getInputStream()返回此套接字的输入流 public class TReceive { public static void main(String[] args) throws IOException { //创建接收端Socket ServerSocket ss=new ServerSocket(10086); //监听客户端 Socket s=ss.accept(); //获取输入流写数据 InputStream is=s.getInputStream(); byte[] bys=new byte[1024]; int len=is.read(bys); String str=new String(bys,0,len); System.out.println(str); //释放资源，注意不关闭服务器 s.close(); } }]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chenwang Zheng]]></title>
    <url>%2F2018%2F01%2F21%2FChenwang%20Zheng%2F</url>
    <content type="text"><![CDATA[Welcome to Chenwang Zheng’s Homepage! Personal Information I am currently a graduate student with School of Electronic and Information Engineering, Beijing Jiaotong University, China. My research interests include data mining and recommendation system. Research Chenwang Zheng, Dan Tao. A User Dynamic Preference and Attention Mechanism based POI Recommendation Method [P]. Patent No.201911420233.6]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
</search>
