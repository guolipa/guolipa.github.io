<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Leetcode-Linked List]]></title>
    <url>%2F2019%2F01%2F11%2FLeetcode-Linked-List%2F</url>
    <content type="text"><![CDATA[Remove Nth Node From End of ListDescription Given a linked list, remove the n-th node from the end of list and return its head. Example Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Solution 方法一：两次扫描第一次扫描确定链表的长度，第二遍扫描删除指定的节点 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ //***********自己实现的方法*****************// class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode t = head; int len=0; int point=1; while(t != null) { len++; t = t.next; } if(len - n == 0) { return head.next; } t=head; while(point &lt; len-n){ t = t.next; point++; } t.next=t.next.next; return head; } } 方法优化提升 首先设置一个指向head的“dumpy”结点，设置这个结点是为了简化一些特殊的情况，比如链表只有一个结点点或者要删除的节点是第一个结点。第一次扫描链表得到链表的长度L第二次扫描先指向dumpy，从开始移动到第 L-n 个结点，使第 L-n 个结点指向第 L-n+2 个结点。 public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0); dummy.next = head; int length = 0; ListNode first = head; while (first != null) { length++; first = first.next; } length -= n; first = dummy; while (length &gt; 0) { length--; first = first.next; } first.next = first.next.next; return dummy.next; } 算法分析 时间复杂度：O(L) L为链表的长度 空间复杂度：O(1) 方法二：一次扫描法一次扫描的方法是通过设置两个指针 first 和 second，首先 first 指针从开始移动 n+1 次，second 指针在起始的位置。这样使两个指针始终保持 n 个节点的距离向前移动，当 first 指针指向节点为空的时候，second 指针处在倒数第 n+1 的位置，此时可以删除目标位置的节点。 public ListNode removeNthFormEnd(ListNode head,int n) { ListNode dumpy = new ListNode(0); dumpy.next = head; ListNode first = head; ListNode second = head; for(int i=1;i&lt;n+1;i++) { first=first.next; } while(first != null) { first = first.next; second = second.next; } second.next = second.next.next; return dumpy.next; } 算法分析 时间复杂度：O(L) L为链表的长度 空间复杂度：O(1) Merge Two Sorted ListsDescription Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4 Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 Solution 方法一：迭代法/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode cur = new ListNode(0); ListNode relt = cur; while(l1!=null &amp;&amp; l2!=null) { if(l1.val &lt; l2.val) { cur.next = l1; l1 = l1.next; }else { cur.next = l2; l2 = l2.next; } cur = cur.next; } if(l1==null) cur.next=l2; if(l2==null) cur.next=l1; return relt.next; } } 方法二：递归法/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if(l1==null) return l2; if(l2==null) return l1; if(l1.val &lt; l2.val) { l1.next=mergeTwoLists(l1.next,l2); return l1; }else { l2.next=mergeTwoLists(l1,l2.next); return l2; } } }]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Math Problem]]></title>
    <url>%2F2019%2F01%2F10%2FLeetcode-Math-Problem%2F</url>
    <content type="text"><![CDATA[Palindrome Number 判断一个整数是否是回文的 方法：将这个整数的后半段反转，将它和前半段比较是否相同 特殊情况： x&lt;0 不是回文的 x是以0结尾的整数 不是回文的 public class PalindromeNumber { public boolean isPalindrome(int x) { if(x &lt; 0 || x % 10 == 0 &amp;&amp; x != 0) { return false; } int reverseNumber = 0; while(x &gt; reverseNumber) { reverseNumber = reverseNumber * 10 + x % 10; x = x / 10; } return x == reverseNumber || x== reverseNumber / 10; } }]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Array Problem]]></title>
    <url>%2F2018%2F12%2F21%2FLeetcode-Array-Problem%2F</url>
    <content type="text"><![CDATA[Two SumDescription Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Solution 方法一：暴力遍历12345678910111213public int[] twoSum(int[] nums, int target) &#123; int[] res=new int[2]; int n=0; for(int i=0;i&lt;nums.length-1;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums[i]+nums[j]==target)&#123; res[n++]=i; res[n++]=j; &#125; &#125; &#125; return res; &#125; 时间复杂度：O(n^2) 方法二： 利用哈希表12345678910111213public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123; return new int[] &#123; i, map.get(complement) &#125;; &#125; &#125; throw new IllegalArgumentException("No two sum solution");&#125; 时间复杂度：O(n)空间复杂度：O(n) 方法三：对方法二的改进1234567891011public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException("No two sum solution");&#125; 时间复杂度：O(n)空间复杂度：O(n) 3SumDescription Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note The solution set must not contain duplicate triplets Example Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is:[ [-1, 0, 1], [-1, -1, 2]] Solution1234567891011121314151617181920212223242526272829public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums)&#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList(); Arrays.sort(nums); for(int i=0;i&lt;nums.length;i++) &#123; if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) &#123; continue; &#125; int left=i+1; int right=nums.length-1; while(left&lt;right) &#123; if(nums[i]+nums[left]+nums[right]==0) &#123; list.add(Arrays.asList(nums[i],nums[left],nums[right])); left++; right--; while(left&lt;right &amp;&amp; left&gt;0 &amp;&amp; nums[left]==nums[left-1]) &#123; left++; &#125; while(left&lt;right &amp;&amp; right&lt;nums.length-1 &amp;&amp; nums[right]==nums[right+1]) &#123; right--; &#125; &#125;else if(nums[i]+nums[left]+nums[right]&lt;0) &#123; left++; &#125;else &#123; right--; &#125; &#125; &#125; return list;&#125; 时间复杂度：O(n^2) 3Sum ClosestDescription Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Solution解法思路类似于3Sum123456789101112131415161718192021222324252627public int threeSumClosest(int[] nums,int target) &#123; int sum=0,cox=Integer.MAX_VALUE; int[] rest = new int[3]; Arrays.sort(nums); for(int i=0;i&lt;nums.length;i++) &#123; int l=i+1; int r=nums.length-1; while(l&lt;r) &#123; sum=nums[i]+nums[l]+nums[r]; int temp=Math.abs(target-sum); if(temp&lt;cox) &#123; cox=temp; rest[0]=nums[i]; rest[1]=nums[l]; rest[2]=nums[r]; &#125; if(sum==target) &#123; return sum; &#125;else if(sum&lt;target) &#123; l++; &#125;else &#123; r--; &#125; &#125; &#125; return rest[0]+rest[1]+rest[2]; &#125; 时间复杂度O(n^2) 4SumSolution12345678910111213141516171819202122232425262728293031323334353637public class FourSum &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums,int target)&#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList(); Arrays.sort(nums); for(int i=0;i&lt;nums.length;i++) &#123; if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) &#123; continue; &#125; for(int j=i+1;j&lt;nums.length;j++) &#123; if(j&gt;i+1 &amp;&amp; nums[j]==nums[j-1]) &#123; continue; &#125; int l=j+1; int r=nums.length-1; while(l&lt;r) &#123; int sum=nums[i]+nums[j]+nums[l]+nums[r]; if(sum == target) &#123; list.add(Arrays.asList(nums[i],nums[j],nums[l],nums[r])); l++; r--; while(l&lt;r &amp;&amp; l&gt;0 &amp;&amp; nums[l] == nums[l-1]) &#123; l++; &#125; while(l &lt; r &amp;&amp; r &lt; nums.length &amp;&amp; nums[r] == nums[r+1]) &#123; r--; &#125; &#125;else if(sum &gt; target)&#123; r--; &#125;else &#123; l++; &#125; &#125; &#125; &#125; return list; &#125;&#125; 时间复杂度：O(n^3) Median of Two Sorted ArraysDescription There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays.The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty. Example nums1 = [1, 3] nums2 = [2] median is 2.0 Solution123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int m=nums1.length; int n=nums2.length; if(m&gt;n)&#123; int[] temp=nums1;nums1=nums2;nums2=temp; int tmp=m;m=n;n=tmp; &#125; int iMin=0,iMax=m,hl=(m+n+1)/2; while(iMin&lt;=iMax)&#123; int i=(iMin+iMax)/2; int j=hl-i; if(i&lt;iMax &amp;&amp; nums2[j-1]&gt;nums1[i])&#123; iMin=i+1; &#125;else if(i&gt;iMin &amp;&amp; nums1[i-1]&gt;nums2[j])&#123; iMax=i-1; &#125;else&#123; int maxLeft=0; if(i==0)&#123; maxLeft=nums2[j-1]; &#125;else if(j==0)&#123; maxLeft=nums1[i-1]; &#125;else&#123; maxLeft=Math.max(nums1[i-1],nums2[j-1]); &#125; if((m+n)%2==1)&#123; return maxLeft; &#125; int minRight=0; if(i==m)&#123; minRight=nums2[j]; &#125;else if(j==n)&#123; minRight=nums1[i]; &#125;else&#123; minRight=Math.min(nums1[i],nums2[j]); &#125; return (maxLeft+minRight)/2.0; &#125; &#125; return 0.0; &#125; &#125;]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-IO概述]]></title>
    <url>%2F2018%2F12%2F13%2FJava-IO%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Java IO概述Java IO是一套提供输入输出（读写数据）功能的API，提供了java.io 包 Java IO的构成概述java.io包中主要包括了五个类和一个接口： File:文件类，用于文件的管理 InputStream:字节输入流类，二进制格式操作，基于字节的输入，是所有字节输入流类的父类 OutputStream:字节输出流类，二进制格式操作，基于字节的输出，是所有字节输出流类的父类 Reader:字符输入流类，文件格式操作，基于字符的输入操作，是所有字符输入流类的父类 Writer:字符输出流类，文件格式操作，基于字符的输出操作，是所有字符输入流类的父类 RandomAccessFile:可以在文件的任意位置进行存取操作 Serializable: 下面是一张通过输入、输出、基于字节或者字符、以及其他比如缓冲、解析之类的特定用途划分的大部分Java IO类的表格 Java IO关注的是从原始数据源读取数据输出原始数据到目标介质 ，主要的数据源和目标介质有 文件 管道 Java中的管道是为运行在同一个JVM中的两个线程提供通信能力 在Java中使用管道时，通信的双方应该是运行在同一进程中的不同线程 网络连接 内存缓存 System.in,System.out,System.error(Java标准的输入输出) 一个程序需要InputStream或者Reader从数据源读取数据，需要OutputStream或者Writer将数据写入到目标媒介中 Java IO的分类根据数据流向： 输入流-读取数据 输出流-写数据 根据处理的数据类型： 字节流：数据流中最小的数据单元是字节 字符流：数据流中最小的数据单元是字符，Java中的字符是Unicode编码，一个字符占用两个字节，因为数据编码的不同，而有了对字符进行高效操作的流对象，本质其实就是基于字节流读取时，去查了指定的码表。 注解： 采用数据流的目的是使输入输出独立于设备，不用关心设备 对于程序来说，输出流是往存储介质或数据通道写入数据，而输入流是从存储介质或数据通道中读取数据 只读或只写，每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流 File类-文件管理File类用于管理文件的类，包括创建文件，删除文件，获取文件路径、文件名等，做判断过滤等功能 构造方法 public File(String pathname) 通过将给定的路径名字符串转换为抽象路径名来创建新的File实例 public File(String parent,String child) 从父路径名字符串和子路径名字符串创建新的File实例 public File(File parent,String child) 从父抽象路径名和子路径名字符串创建新的File实例 成员方法： 创建功能： public boolean createNewFile() throws IOException 当且仅当具有该名称的文件尚不存在时，原子地创建一个由该抽象路径名命名的新的空文件 public boolean mkdir() 创建文件夹 public boolean mkdirs() 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目 删除功能： public boolean delete() 删除由此抽象路径名表示的文件或目录 重命名： public boolean renameTo(File dest) 判断： public boolean isDirectory() 判断是否是目录 public boolean isFile() 判断是否是文件 public boolean exists() 判断是否存在 public boolean canRead() 判断是否可读 public boolean canWrite() 判断是否可写 public boolean isHidden() 判断是否隐藏 获取： public String getAbsolutePath() 获取绝对路径 public String getPath() 获取相对路径 public String getName() 获取名称 public long length() 获取长度，字节数 public long lastModified() 获取最后一次修改时间 public String[] list() 获取指定目录下所有文件夹或文件名称的数组 public File[] listFiles() 获取指定目录下所有文件夹或文件的File的数组 文件名称过滤器FilenameFilter public String[] list(FilenameFilter filter) public File[] listFiles(FilenameFilter filter) 字节流InputStream InputStream FileInputStream BufferedInputStream]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Dynamic Programming]]></title>
    <url>%2F2018%2F12%2F13%2FLeetcode-dynamic%20programming%2F</url>
    <content type="text"><![CDATA[Longest Palindromic Substring 回文字符串：正读反读都一样 方法一：暴力法 遍历所有的子字符串，判断它是不是回文字符串 class Solution { public String longestPalindrome(String s) { if(s.length()==1){ return s; } if(s.isEmpty()){ return ""; } int maxn=0; int iMin=0; //遍历每个子字符串并判断是不是回文的 for(int i=0;i&lt;s.length();i++){ for(int j=s.length()-1;j&gt;=i;j--) if(s.charAt(i)==s.charAt(j)){ if(check(s,i,j)){ if(j-i+1&gt;maxn){ maxn=j-i+1; iMin=i; } break; } } } return s.substring(iMin,maxn); } //检测一个字符串是不是回文 public boolean check(String s,int i,int j){ while(i&lt;=j){ if(s.charAt(i)!=s.charAt(j)){ return false; } i++; j--; } return true; } } 算法分析：时间复杂度O(n^3) 方法二：动态规划 暴力法时间复杂度高的原因是去检查每一个子字符串是不是回文的，降低时间复杂度就要减少对子字符串是不是回文的判断 假设一个字符串”ababa”,当我已经确认了”bab”是回文字符串，由于它左右两边的字符都是a，那么这个完整的字符串本身就是回文的，就可以不用对整个字符串再进行完整的判断。 假设一个字符串的长度为n，那么建立一个n*n数组P。在矩阵中P[i][j]=l，若l&gt;0：表示以字符S[i]开始和以S[j]结尾的字符串是回文字符串，字符串的长度为l;若l=0，表示此字符串不是回文字符串 只需要对矩阵中j&gt;=i的部分赋值即可，就j&lt;i部分为0； 1.一个字符的情况：将矩阵的对角线赋值为1，因为每个字符本身是回文的 2.两个字符的情况：j-i=1 P[i][j]=2,if S[i]=S[j] 3.多个字符的情况：j-i&gt;=2 if S[i]!=S[j] P[i][j]=0; if S[i]=S[j] if P[i+1][j-1]&gt;0 P[i][j]=p[i+1][j-1]+2; else P[i][j]=0; 字符串有多个字符组成时，如果两边的字符相等，那么这个字符串可能是回文的，这时将字符串去掉首末字符得到子字符串，如果子字符串回文的，那么这个字符串也是回文的。 public static String longestPalindrome(String s){ if(s.length()==0){ return ""; } if(s.length()==1){ return s; } int[][] p=new int[s.length()][s.length()]; int indexMin=0,maxn=1; //初始化二维数组P for(int i=0;i&lt;s.length();i++){ for(int j=0;j&lt;s.length();j++){ if(i==j) p[i][j]=1; } } for(int j=0;j&lt;s.length();j++){ for(int i=j-1;i&gt;=0;i--){ if(s.charAt(i)==s.charAt(j)){ if(j-i==1){ p[i][j]=2; } if(j-i&gt;=2){ if(p[i+1][j-1]&gt;0){ p[i][j]=p[i+1][j-1]+2; }else{ p[i][j]=0; } } }else{ p[i][j]=0; } if(p[i][j]&gt;maxn){ maxn=p[i][j]; indexMin=i; } } } return s.substring(indexMin, indexMin+maxn); } 算法分析： 时间复杂度：O(n^2) 空间复杂度：O(n^2),需要一个n*n的矩阵来存储数据 方法三：Expand Around Center 对于动态规划算法时间复杂度为O(n^2)，空间复杂度为O(n^2)，可以进一步优化只用O(1)的空间实现O(n^2)的时间复杂度 一个回文字符串它是成中心对称的，比如”baab”,”bab”,但是回文字符串分为两种：奇数字符数，偶数字符数 class Solution { public String longestPalindrome(String s) { if(s.length()==0){ return ""; } if(s.length()==1){ return s; } int indexMin=0,maxn=1; for(int i=0;i&lt;s.length();i++){ int len1=expandAroundCenter(s,i,i); int len2=expandAroundCenter(s,i,i+1); int len=Math.max(len1,len2); if(len&gt;maxn){ indexMin=i-(len-1)/2; maxn=len; } } return s.substring(indexMin,indexMin+maxn); } private int expandAroundCenter(String s,int L,int R){ while(L&gt;=0 &amp;&amp; R&lt;s.length() &amp;&amp; s.charAt(L)==s.charAt(R)){ L--; R++; } return R-L-1; } } 算法分析 时间复杂度：O(n^2) 空间复杂苏：O(1) 方法四：最长公共字符串** 将字符串S翻转为S’,检查S和S’的最长公共字符串就是S的最长回文子字符串此方法中存在一种问题，就是当字符串中某一个子串存在一个镜像子串本身并不是回文的，翻转之后会被检测为回文的。 下面是一种基于动态规划的求解最长公共字符串的方法。 Longest Common Substring 最长公共子字符串 动态规划问题 问题：因为有重叠子问题，当前计算的过程中可能有的问题在之前的计算已经计算过了，现在又要计算一遍，导致大量重复的计算 动态规划的解决方法：动态规划通过找到解决问题的递推关系，将已经完成计算的存储起来，当开始新的计算时如果包含之前计算的子问题时，不需要再次计算，只需要访问已经存储的计算结果就可以 动态规划解决问题的方法一般减少了时间复杂度，增加了存储空间。 动态规划问题的两个特点： 最优子结构 重叠子问题 对于这个问题，假设有两个字符串s[0,...m],t[0,...,n],求两个字符串的最长公共子字符串 定义矩阵mXn的矩阵L,L[i][j]表示以s[i]开始和t[j]结尾的公共子字符串长度的最大值，那么对于L[i+1][j+1]只是比L[i][j]增加了s[i+1]和t[j+1] 因此可以构造出最长公共子字符串的递归式： if s[i]==t[j] L[i][j]=L[i-1][j-1]+1 if s[i]!=t[j] L[i][j]=0 假设有两个字符串：”ABAB”和”BABA” ,构造出了上述的矩阵代码实现 public static String LCS(String s1,String s2){ if(s1.isEmpty() || s2.isEmpty()){ return ""; } int indexMax=0,maxn=0; int[][] L=new int[s1.length()][s2.length()]; for(int i=0;i&lt;s1.length();i++){ for(int j=0;j&lt;s2.length();j++){ if(s1.charAt(i)==s2.charAt(j)){ if(i==0 || j==0){ L[i][j]=1; }else{ L[i][j]=L[i-1][j-1]+1; } } if(L[i][j]&gt;maxn){ maxn=L[i][j]; indexMax=i; } } } return s1.substring(indexMax+1-maxn, indexMax+1); } 算法分析： 时间复杂度：O(mn) 空间复杂度：O(mn) 算法优化从上面动态查找最长公共子字符串的过程中发现，在循环查找的过程中只会用到矩阵L中的两行，即正在计算的一行和完成计算的上一行，之前计算的和带计算的都用不到，所以只需要维护两行数据就足够了，不需要使用mxn的数组 代码实现： public class LCS_improve { public static String LCS_improve(String s1,String s2){ if(s1.isEmpty() || s2.isEmpty()){ return ""; } int indexMax=0,maxn=0; int [][] L=new int[2][s1.length()]; for(int i=0;i&lt;s1.length();i++){ int cur=(i+2)%2; int pre=(i+1)%2; for(int j=0;j&lt;s2.length();j++){ if(s1.charAt(i)==s2.charAt(j)){ if(i==0 || j==0){ L[cur][j]=1; }else{ L[cur][j]=L[pre][j-1]+1; } }else{ L[cur][j]=0; } if(L[cur][j]&gt;maxn){ maxn=L[cur][j]; indexMax=i; } } } return s1.substring(indexMax+1-maxn, indexMax+1); } } 算法分析： 时间复杂度：O(mn) 空间复杂度：O(min(m,n))]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb-Http与Servlet概述]]></title>
    <url>%2F2018%2F12%2F07%2FHttp%E4%B8%8EServlet%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Servlet Servlet的概述 Servlet的定义及其作用：Servlet是运行在Web服务器(eg.Tomcat)上的java程序，通过HTTP协议接收好响应来自Web客户端的请求。 Servlet的实现 Servlet接口定义了初始化servlet的方法、为请求提供服务的方法和从服务器移除servlet的方法,这些方法成为生命周期方法 Servlet实现方法：定义一个类implements Servlet 或者 Extends GenericServlet/HttpServlet(最常用) Servlet中的生命周期方法是按以下顺序调用的： 构造Servlet，使用init方法初始化 创建Servlet实例的时候回执行init方法 一个Servlet只会初始化一次，init方法只会被执行一次 处理客户端的请求对service方法的调用 当客户端有请求的时候回调用service方法 一次请求对应着service的执行，所以它可以被多次执行 从服务器中一处Servlet，并用destroy销毁它，最后垃圾回收终止它 Servlet销毁时会执行： 当Servlet从服务器移除时执行； 当关闭服务器时执行 下面是实现了Servlet的代码： 12345678public class Sever_servlet extends HttpServlet&#123; @Override public void init(ServletConfig arg0) throws ServletException &#123;&#125; @Override public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException &#123;&#125; @Override public void destroy() &#123;&#125;&#125; Servlet的配置 在一个Web工程中当我们实现了一个Servlet的时候，我们应该在Web工程中将这的Servlet加入到配置文件Web。xml文件中，配置Servlet。 下面是在web.xml天剑一个Servlet的写法 获取Servlet配置信息 //1. 得到servlet配置对象 专门用于在配置servlet的信息 ServletConfig config = getServletConfig(); //获取到的是配置servlet里面servlet-name 的文本内容 String servletName = config.getServletName(); System.out.println(&quot;servletName=&quot;+servletName); //2. 可以获取具体的某一个参数。 String address = config.getInitParameter(&quot;address&quot;); System.out.println(&quot;address=&quot;+address); //3. 获取所有的参数名称 Enumeration&lt;String&gt; names = config.getInitParameterNames(); //遍历取出所有的参数名称 while (names.hasMoreElements()) { String key = (String) names.nextElement(); String value = config.getInitParameter(key); System.out.println(&quot;key===&quot;+key + &quot; value=&quot;+value); } ServletContext 每个web工程都只有一个ServletContext对象。 在同一个Web工程中不管是哪个servlet，获取到的这个类的对象都是同一个 ServletContext主要有三个作用： 获取Web工程的全局配置参数 获得Web工程中的资源（properities） 存取数据，Servlet间共享数据，即域对象 获取全局配置参数在web.xml文件中有定义全局参数，每个Servlet都可以访问，而Servlet内部的参数只可以由自己访 icon 通过调用getServletContext()方法可以获得Web工程的ServletContext对象，通过这个对象来访问全局参数 icon 获取Web工程中的资源Web工程里的properities文件资源 //获取Web工程的ServletContext对象 ServletContext context=getServletContext(); //获得对去加载读取资源的对象property Properities property=new Properities(); //获取输入流，就是资源 InputStream in=null; //加载资源并读取 property.load(in); String city=property.getProperty(); 这里的关键是如何读入资源，获得资源的输入流InputStream，有三种方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//获得Servlet对象ServletContext context=getServletContext();Properties properity=new Properties();//方法一：通过ServletContext的getRealpath()方法获得资源输入流，只需要传入资源的相对路径/* * getRealPath("")这个得到的是运行在服务器TomCat中Web项目的根路径 * D:\tomcat\apache-tomcat-7.0.52\apache-tomcat-7.0.52\wtpwebapps\Web\ * getRealPath("file/file.properties")这个会将传入的相对路径拼接到上面的项目根路径的后面 * D:\tomcat\apache-tomcat-7.0.52\apache-tomcat-7.0.52\wtpwebapps\Web\file/file.properties* */String path= context.getRealPath("file/file.properties");InputStream in=new FileInputStream(path);//方式二：通过context.getResourceAsStream("file/file.properties")直接过得资源的输入流InputStream in=context.getResourceAsStream("file/file.properties");//方式三：通过类加载器直接获得资源的输入流InputStream in=this.getClass().getClassLoader().getResourceAsStream("../../file/file.properities");properity.load(in);String city=properity.getProperty("city");System.out.println("city:"+city); ``` ## HttpServletRequest ### 获取客户端的信息&gt;HttpServletRequest中封装了客户端所有的信息 &gt;通过request可以获得客户端请求头的全部信息和客户端传递的参数```javapublic class Request extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //取出客户端请求里面的所有头信息(名称-值) Enumeration&lt;String&gt;headers=request.getHeaderNames(); while(headers.hasMoreElements()) &#123; String name=headers.nextElement(); String value=request.getHeader(name); System.out.println(name+":"+value); &#125; //获得客户端上传的参数 //1.利用枚举方法获得参数 Enumeration&lt;String&gt;parameter=request.getParameterNames(); while(parameter.hasMoreElements()) &#123; String name=parameter.nextElement(); String value=request.getParameter(name); System.out.println(name+":"+value); &#125; //2.利用Map来获取参数 Map&lt;String,String[]&gt;parameter=request.getParameterMap(); Set&lt;String&gt; paras=parameter.keySet(); Iterator&lt;String&gt; it=paras.iterator(); while(it.hasNext()) &#123; String name=it.next(); String value=parameter.get(name)[0]; System.out.println(name+":"+value); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;&#125;&#125; 中文乱码 当客户端提交的数据中有中文的时候会出现乱码的现象，Get和POST方式的解决方法不同 Get请求方式 由于Get请求方式上传提交的数据是在Url地址中的，所以服务器接收的时候已经过编码了，服务器端直接获得的数据是乱码的 //tomcat收到了这批数据，getParameter 默认使用ISO-8859-1去解码 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); //先让文字回到ISO-8859-1对应的字节数组 ， 然后再按utf-8组拼字符串 username = new String(username.getBytes(&quot;ISO-8859-1&quot;) , &quot;UTF-8&quot;); System.out.println(&quot;userName=&quot;+username+&quot;==password=&quot;+password); 直接在tomcat里面做配置，以后get请求过来的数据永远都是用UTF-8编码。 可以在tomcat里面做设置处理 conf/server.xml 加上URIEncoding=&quot;utf-8&quot; &lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt; Post请求 在getParameter之前加入这行代码，是在设置请求体的编码方式 request.setCharacterEncoding(&quot;UTF-8&quot;); HttpServletResponse 它的作用是响应返回数据给客户端输出数据到页面上 //以字符流的方式写数据 response.getWriter().write(&quot;&lt;h1&gt;hello response...&lt;/h1&gt;&quot;); //以字节流的方式写数据 response.getOutputStream().write(&quot;hello&quot;.getBytes()); 中文乱码 以字符流输出 response.getWriter() //1. 指定输出到客户端的时候，这些文字使用UTF-8编码 response.setCharacterEncoding(&quot;UTF-8&quot;); //2. 直接规定浏览器看这份数据的时候，使用什么编码来看。 response.setHeader(&quot;Content-Type&quot;, &quot;text/html; charset=UTF-8&quot;); response.getWriter().write(&quot;北京&quot;); 以字节流输出 response.getOutputStream() //1. 指定浏览器看这份数据使用的码表 response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;); //2. 指定输出的中文用的码表 response.getOutputStream().write(&quot;我爱北京&quot;.getBytes(&quot;UTF-8&quot;)); 不管是字节流还是字符流，直接使用一行代码，然后再写数据 response.setContentType(&quot;text/html;charset=UTF-8&quot;);]]></content>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-String Problem]]></title>
    <url>%2F2018%2F11%2F19%2FLeetcode-String%20problem%2F</url>
    <content type="text"><![CDATA[Longest Substring Without Repeating CharactersDescription Given a string, find the length of the longest substring without repeating character. example Input: &quot;abcabcbb&quot; Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. solution1). 方法一：暴力法检查每一个子字符串是否有重复的字符12345678910111213141516171819public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); int ans = 0; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt;= n; j++) if (allUnique(s, i, j)) ans = Math.max(ans, j - i); return ans; &#125; public boolean allUnique(String s, int start, int end) &#123; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (int i = start; i &lt; end; i++) &#123; Character ch = s.charAt(i); if (set.contains(ch)) return false; set.add(ch); &#125; return true; &#125;&#125; 算法分析：时间复杂度：O(n3)；空间复杂度：O(min(m,n)) 2). 方法二：滑动窗口 滑动窗口经常用在数组和字符串的问题中，滑动窗口是数组和字符串中的一些元素，它用两个索引来表示滑动窗口的起始位置[i,j),滑动窗口通过滑动左右的两个索引来改变滑动窗口滑动的方向以及窗口内的元素. 本题用HashSet来存储现在的滑动窗口内的元素[i,j),通过检查第j个元素，如果不在集合中就存储到集合并继续增加滑动窗口右侧可值j，如果第j个元素已经在集合中了，那么就滑动左侧的索引i，从集合中删除第i个元素，直到此时第j个元素不在集合中了。 代码实现12345678910111213141516171819 public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int ans = 0, i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; n) &#123; // try to extend the range [i, j] if (!set.contains(s.charAt(j)))&#123; set.add(s.charAt(j++)); ans = Math.max(ans, j - i); &#125; else &#123; set.remove(s.charAt(i++)); &#125; &#125; return ans; &#125;&#125; 算法分析：时间复杂度：O(2n)=O(n) 3). 方法三:滑动窗口的优化利用HashMap来代替HashSet123456789101112131415class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n=s.length(); int maxn=0; Map&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(); for(int i=0,j=0;j&lt;n;j++)&#123; if(map.contains(s.charAt(j)))&#123; i=Math.max(map.get(s.charAt(j)),i); &#125; amxn=Math.max(maxn,j-i+1); map.put(s.charAt(j),j+1); &#125; return maxn; &#125;&#125; 算法分析：时间复杂度O(n) Longest Palindromic Substring 回文字符串：正读反读都一样 1).方法一：暴力法 遍历所有的子字符串，判断它是不是回文字符串 1234567891011121314151617181920212223242526272829303132333435363738 class Solution &#123; public String longestPalindrome(String s) &#123; if(s.length()==1)&#123; return s; &#125; if(s.isEmpty())&#123; return ""; &#125; int maxn=0; int iMin=0; //遍历每个子字符串并判断是不是回文的 for(int i=0;i&lt;s.length();i++)&#123; for(int j=s.length()-1;j&gt;=i;j--) if(s.charAt(i)==s.charAt(j))&#123; if(check(s,i,j))&#123; if(j-i+1&gt;maxn)&#123; maxn=j-i+1; iMin=i; &#125; break; &#125; &#125; &#125; return s.substring(iMin,maxn); &#125; //检测一个字符串是不是回文 public boolean check(String s,int i,int j)&#123; while(i&lt;=j)&#123; if(s.charAt(i)!=s.charAt(j))&#123; return false; &#125; i++; j--; &#125; return true; &#125;&#125; 算法分析： 时间复杂度O(n^3)2). 方法二：动态规划 暴力法时间复杂度高的原因是去检查每一个子字符串是不是回文的，降低时间复杂度就要减少对子字符串是不是回文的判断 假设一个字符串”ababa”,当我已经确认了”bab”是回文字符串，由于它左右两边的字符都是a，那么这个完整的字符串本身就是回文的，就可以不用对整个字符串再进行完整的判断。 假设一个字符串的长度为n，那么建立一个n*n数组P。在矩阵中P[i][j]=l，若l&gt;0：表示以字符S[i]开始和以S[j]结尾的字符串是回文字符串，字符串的长度为l;若l=0，表示此字符串不是回文字符串 只需要对矩阵中j&gt;=i的部分赋值即可，就j&lt;i部分为0； 1.一个字符的情况：将矩阵的对角线赋值为1，因为每个字符本身是回文的 2.两个字符的情况：j-i=1 P[i][j]=2,if S[i]=S[j] 3.多个字符的情况：j-i&gt;=2 if S[i]!=S[j] P[i][j]=0; if S[i]=S[j] if P[i+1][j-1]&gt;0 P[i][j]=p[i+1][j-1]+2; else P[i][j]=0; 字符串有多个字符组成时，如果两边的字符相等，那么这个字符串可能是回文的，这时将字符串去掉首末字符得到子字符串，如果子字符串回文的，那么这个字符串也是回文的。 12345678910111213141516171819202122232425262728293031323334353637383940 public static String longestPalindrome(String s)&#123; if(s.length()==0)&#123; return ""; &#125; if(s.length()==1)&#123; return s; &#125; int[][] p=new int[s.length()][s.length()]; int indexMin=0,maxn=1; //初始化二维数组P for(int i=0;i&lt;s.length();i++)&#123; for(int j=0;j&lt;s.length();j++)&#123; if(i==j) p[i][j]=1; &#125; &#125; for(int j=0;j&lt;s.length();j++)&#123; for(int i=j-1;i&gt;=0;i--)&#123; if(s.charAt(i)==s.charAt(j))&#123; if(j-i==1)&#123; p[i][j]=2; &#125; if(j-i&gt;=2)&#123; if(p[i+1][j-1]&gt;0)&#123; p[i][j]=p[i+1][j-1]+2; &#125;else&#123; p[i][j]=0; &#125; &#125; &#125;else&#123; p[i][j]=0; &#125; if(p[i][j]&gt;maxn)&#123; maxn=p[i][j]; indexMin=i; &#125; &#125; &#125; return s.substring(indexMin, indexMin+maxn);&#125; 算法分析： 时间复杂度：O(n^2) 空间复杂度：O(n^2)需要一个n*n的矩阵来存储数据 3).方法三：Expand Around Center 对于动态规划算法时间复杂度为O(n^2)，空间复杂度为O(n^2)，可以进一步优化只用O(1)的空间实现O(n^2)的时间复杂度 一个回文字符串它是成中心对称的，比如”baab”,”bab”,但是回文字符串分为两种：奇数字符数，偶数字符数 1234567891011121314151617181920212223242526272829 class Solution &#123; public String longestPalindrome(String s) &#123; if(s.length()==0)&#123; return ""; &#125; if(s.length()==1)&#123; return s; &#125; int indexMin=0,maxn=1; for(int i=0;i&lt;s.length();i++)&#123; int len1=expandAroundCenter(s,i,i); int len2=expandAroundCenter(s,i,i+1); int len=Math.max(len1,len2); if(len&gt;maxn)&#123; indexMin=i-(len-1)/2; maxn=len; &#125; &#125; return s.substring(indexMin,indexMin+maxn); &#125; private int expandAroundCenter(String s,int L,int R)&#123; while(L&gt;=0 &amp;&amp; R&lt;s.length() &amp;&amp; s.charAt(L)==s.charAt(R))&#123; L--; R++; &#125; return R-L-1; &#125; &#125; 算法分析 时间复杂度：O(n^2) 空间复杂苏：O(1) 4).方法四：最长公共字符串 将字符串S翻转为S’,检查S和S’的最长公共字符串就是S的最长回文子字符串此方法中存在一种问题，就是当字符串中某一个子串存在一个镜像子串本身并不是回文的，翻转之后会被检测为回文的。 Longest Common Substring 最长公共子字符串 动态规划问题 动态规划问题的两个特点： 1.最优子结构 2.重叠子问题 因为有重叠子问题，当前计算的过程中可能有的问题在之前的计算已经计算过了，现在又要计算一遍，导致大量重复的计算动态规划通过找到解决问题的递推关系，将已经完成计算的存储起来，当开始新的计算时如果包含之前计算的子问题时，不需要再次计算，只需要访问已经存储的计算结果就可以动态规划解决问题的方法一般减少了时间复杂度，增加了存储空间。 对于这个问题，假设有两个字符串s[0,…m],t[0,…,n],求两个字符串的最长公共子字符串定义矩阵mXn的矩阵L,L[i][j]表示以s[i]开始和t[j]结尾的公共子字符串长度的最大值，那么对于L[i+1][j+1]只是比L[i][j]增加了s[i+1]和t[j+1] 因此可以构造出最长公共子字符串的递归式： if s[i]==t[j] L[i][j]=L[i-1][j-1]+1 if s[i]!=t[j] L[i][j]=0 假设有两个字符串：”ABAB”和”BABA” ,构造出了上述的矩阵代码实现123456789101112131415161718192021222324 public static String LCS(String s1,String s2)&#123; if(s1.isEmpty() || s2.isEmpty())&#123; return ""; &#125; int indexMax=0,maxn=0; int[][] L=new int[s1.length()][s2.length()]; for(int i=0;i&lt;s1.length();i++)&#123; for(int j=0;j&lt;s2.length();j++)&#123; if(s1.charAt(i)==s2.charAt(j))&#123; if(i==0 || j==0)&#123; L[i][j]=1; &#125;else&#123; L[i][j]=L[i-1][j-1]+1; &#125; &#125; if(L[i][j]&gt;maxn)&#123; maxn=L[i][j]; indexMax=i; &#125; &#125; &#125; return s1.substring(indexMax+1-maxn, indexMax+1);&#125; 算法分析： 时间复杂度：O(m*n) 空间复杂度：O(m*n) 算法优化从上面动态查找最长公共子字符串的过程中发现，在循环查找的过程中只会用到矩阵L中的两行，即正在计算的一行和完成计算的上一行，之前计算的和带计算的都用不到，所以只需要维护两行数据就足够了，不需要使用mxn的数组 代码实现：123456789101112131415161718192021222324252627282930 public class LCS_improve &#123; public static String LCS_improve(String s1,String s2)&#123; if(s1.isEmpty() || s2.isEmpty())&#123; return ""; &#125; int indexMax=0,maxn=0; int [][] L=new int[2][s1.length()]; for(int i=0;i&lt;s1.length();i++)&#123; int cur=(i+2)%2; int pre=(i+1)%2; for(int j=0;j&lt;s2.length();j++)&#123; if(s1.charAt(i)==s2.charAt(j))&#123; if(i==0 || j==0)&#123; L[cur][j]=1; &#125;else&#123; L[cur][j]=L[pre][j-1]+1; &#125; &#125;else&#123; L[cur][j]=0; &#125; if(L[cur][j]&gt;maxn)&#123; maxn=L[cur][j]; indexMax=i; &#125; &#125; &#125; return s1.substring(indexMax+1-maxn, indexMax+1); &#125;&#125; 算法分析时间复杂度：O(mn)空间复杂度：O(min(m,n)) Longest Common PrefixDescription Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “” Example Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] Output: &quot;fl&quot; Solution 1. 方法一：横向比较 这是一种迭代的方法，假设字符串数组的长度为n，先将第一个字符串和第二个字符串比较得到最长公共前缀prefix，再将得到的prefix和第三个字符串比较得到新的prefix，依次向后比较，直到最后一个字符串。如果比较的过程中有prefix为空时，直接返回” “,LCP(S1,S2,.....,SN)=LCP(LCP(LCP(S1,S2),S3),.....SN)。 public String longestCommonPrefix(String[] strs) { if (strs.length == 0) return ""; String prefix = strs[0]; for (int i = 1; i &lt; strs.length; i++) while (strs[i].indexOf(prefix) != 0) { prefix = prefix.substring(0, prefix.length() - 1); if (prefix.isEmpty()) return ""; } return prefix; } 算法分析时间复杂度：在最坏的情况下为O(S),S为字符串数组中所有字符的总数空间复杂度：O(1) 2. 方法二：纵向比较 横向比较需要从第一个字符串比较到最后一个，如果数组中最短的字符串再最后的位置，那么在整个算法执行的过程中会有很多不必要的比较运算，增加了时间复杂度。因此采用纵向的比较，以最短字符串的长度l为标准，最多只比较到每个字符串的l位。从所有字符串的第一个字符开始比较，对位比较所有的字符串，直到在某一位的字符不相同或者已经到了最短的字符串的末尾字符，就结束运算。 public class Longest_Common_Prefix { public String longestCommonPrefix(String[] strs) { if(strs.length == 0) { return ""; } for(int i=0;i&lt;strs[0].length();i++) { char t = strs[0].charAt(i); for(int j=1;j&lt;strs.length;j++) { if(i == strs[j].length() || strs[j].charAt(i) != t) { return strs[0].substring(0, i); } } } return strs[0]; } } 算法分析时间复杂度：最坏情况下(所有字符串相同)O(S),一般情况下n*min(Si)空间复杂度：O(1) 3. 方法三：分而治之 将字符数组分为两组，分别对两组查找最长公共前缀sl,sr，最后再计算sl和sr的公共前缀。 public class Longest_Common_Prefix { //分而治之的方法 public String longestCommonPrefix(String[] strs) { if(strs.length==0) { return ""; } return longestCommonPrefix(strs,0,strs.length-1); } private String longestCommonPrefix(String[] strs,int l,int r) { if(l==r) { return strs[l]; } int mid = (l+r)/2; String lcpLeft=longestCommonPrefix(strs,l,mid); String lcpRight=longestCommonPrefix(strs,mid+1,r); return commonPrefix(lcpLeft,lcpRight); } private String commonPrefix(String s1,String s2) { int len=Math.min(s1.length(), s2.length()); for(int i=0;i&lt;len;i++) { if(s1.charAt(i) != s2.charAt(i)) { return s1.substring(0, i); } } return s1.substring(0,len); } } 算法分析时间复杂度：最坏情况下为O(S),(S=mn,m为每个字符串的长度，n为字符串的个数)空间复杂度：O(mlogn),算法logn次的递归调用，每次都需要m个存储空间 4. 方法四：二分法 首先找到字符串数组中最短字符串的长度minLen,它也是公共前缀的最大的长度，那么查找最长公共前缀的范围就缩小到每个字符串[0,minLen]之间。 将查找范围分为等长的两部分，[0,mid]和[mid+1,minLen]，取第一个字符串的前半部分的子字符串substr1 = str1.subString(0,mid),去和其他的字符串比较判断substr1是不是公共前缀，这时会有两种情况： 如果substr1是公共前缀，那么就将substr1增加判断更长的子字符串是不是公共前缀 如果substr1不是公共前缀，那么对于长度大于substr1的字符串都不是公共前缀，这时减小substr1去判断更小的子字符串是不是公共前缀 class Solution { public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return ""; int minLen = Integer.MAX_VALUE; for (String str : strs) minLen = Math.min(minLen, str.length()); int low = 1; int high = minLen; while (low &lt;= high) { int middle = (low + high) / 2; if (isCommonPrefix(strs, middle)) low = middle + 1; else high = middle - 1; } return strs[0].substring(0, (low + high) / 2); } private boolean isCommonPrefix(String[] strs, int len){ String str1 = strs[0].substring(0,len); for (int i = 1; i &lt; strs.length; i++) if (!strs[i].startsWith(str1)) return false; return true; } } 算法分析时间复杂度：O(S * logn)空间复杂度：O(1) Valid ParenthesesDescription Given a string containing just the characters &apos;(&apos;, &apos;)&apos;, &apos;{&apos;, &apos;}&apos;, &apos;[&apos; and &apos;]&apos;, determine if the input string is valid. An input string is valid if: 1.Open brackets must be closed by the same type of brackets. 2.Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example Example 1: Input: &quot;()&quot; Output: true Example 2: Input: &quot;()[]{}&quot; Output: true Example 3: Input: &quot;(]&quot; Output: false Example 4: Input: &quot;([)]&quot; Output: false Example 5: Input: &quot;{[]}&quot; Output: true Solution 方法概述-堆栈法 对于一个有效的字符表达式，字符串中的括号都是成对出现的。正如题中所说，打开的括号必须有相同形式的关闭括号，并且所有打开的括号必须以正确的顺序关闭。 从起始位置开始检查字符串，如果第一个字符是关闭字符，那么这个字符串一定不是有效的；如果第一个是某种打开字符，将它压入堆栈 stack.push(char c)，每遇到一个打开字符就做相同的操作；如果遍历字符串中遇到的关闭字符，看栈顶的字符是不是和此关闭字符相匹配的打开字符，如果是，将字符出栈并继续遍历，如果不是，那么就不是有效的字符串；顺利遍历完整个字符串时，检查栈是否为空，如果是空，那么字符串时有效的，否则无效。 class Solution { public boolean isValid(String s) { if(s.isEmpty()) { return true; } char[] stack = new char[s.length()]; int top = 0; for(int i=0;i&lt;s.length();i++) { char c = s.charAt(i); if(c=='{' || c=='[' || c=='(') { stack[top++] = c; } if(c=='}') { if(top==0 || stack[--top]!='{') { return false; } } if(c==']') { if(top==0 || stack[--top]!='[') { return false; } } if(c==')') { if(top==0 || stack[--top]!='(') { return false; } } } return top==0; } }]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-图(最短路径)]]></title>
    <url>%2F2018%2F11%2F13%2FJava%E7%AE%97%E6%B3%95-%E5%9B%BE-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[最短路径最短路径应用的图是加权有向图加权有向图的数据结构：首先定义的是加权有向边的数据类型：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class DirectEdge &#123; private int v;//边的起点 private int w;//边的终点 private double weight;//边的权重 public DirectEdge(int v,int w,double weight)&#123; this.v=v; this.w=w; this.weight=weight; &#125; public double weight()&#123; return weight; &#125; public int from()&#123; return v; &#125; public int to()&#123; return w; &#125; public String toString()&#123; return String.format("%d-&gt;%d %.2f", v,w,weight); &#125;&#125; ``` 在加权有向边的基础上定义加权有向图 ```javapublic class EdgeWeightDigraph &#123; private int V; private int E; private Bag&lt;DirectEdge&gt;[] adj; public EdgeWeightDigraph(int V)&#123; this.V=V; this.E=0; adj=(Bag&lt;DirectEdge&gt;[])new Bag[V]; for(int v=0;v&lt;V;v++)&#123; adj[v]=new Bag&lt;DirectEdge&gt;(); &#125; &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; public void addEdge(DirectEdge e)&#123; int v=e.from(); adj[v].add(e); E++; &#125; public Iterable&lt;DirectEdge&gt; adj(int v)&#123; return adj[v]; &#125; public Iterable&lt;DirectEdge&gt; edges()&#123; Bag&lt;DirectEdge&gt; bag=new Bag&lt;DirectEdge&gt;(); for(int v=0;v&lt;V;v++)&#123; for(DirectEdge e:adj[v])&#123; bag.add(e); &#125; &#125; return bag; &#125;&#125; 最短路径：从图的一个顶点到达另一个顶点的成本最小(权重和最小)的路径，这里的最短路径是单点最短路径最短路径树： 给定一幅加权有向图和顶点s，可以找到一个以s为起点的最小路径树，他是图的一幅子图，包含了顶点s和所有s可达的顶点。树的根节点是s，树的每一条路径都是有向图中的一条最短路径 最短路径算法原理边的松弛顶点的松弛最短路径的最优条件：一幅有向加权图G,顶点s为起点，distTo[]保存着起点s到任意顶点v的路径长度，若s到v不可达，该值为无穷大。当且仅当对于从v到w的任意一条边e，满足distTo[w]&lt;=distTo[v]+e.weight()条件时，才是最短路径 Dijkstra算法 算法思想1) 首先Dijkstra算法只适用在权值非负的加权有向图 如下图所示，E(v2,v5)为负值，如果想找到v5到v4的最短路径，那么这一条路径：v5-&gt;v4-&gt;v2-&gt;v5-&gt;v4的权值之和为-6，如此一直沿着这条路径循环，那么v5到v4的路径权重之和会越来越小，趋近于负无穷，那么这两个顶点之间的最短路径无法确定。我们称图中这样的循环为负值圈，有向图中出现负值圈时，最短路径的问题就无法确定。 2）Dijkstra算法的思想 首先确定源点s，dist[v]表示的是从s到v的最短路径距离 Dijkstra算法每次从没有确定最短路径的顶点中选择dist[]值最小的顶点v，对v的所有边进行松弛，如此操作直到确定所有顶点的最短路径 算法实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Dijkstra &#123; private DirectEdge[] edgeTo; private double[] distTo; private IndexMinPQ&lt;Double&gt; pq; public Dijkstra(EdgeWeightDigraph G,int s)&#123; edgeTo=new DirectEdge[G.V()]; distTo=new double[G.V()]; pq=new IndexMinPQ&lt;Double&gt;(G.V()); //初始化distTo所有项为正无穷 for(int v=0;v&lt;G.V();v++)&#123; distTo[v]=Double.POSITIVE_INFINITY; &#125; //起始点设置为0 distTo[s]=0.0; //将起始点入队 pq.insert(s, 0.0); while(!pq.isEmpty())&#123; relax(G,pq.deleteMin()); &#125; &#125; private void relax(EdgeWeightDigraph G,int v)&#123; for(DirectEdge e:G.adj(v))&#123; int w=e.to(); if(distTo[w]&gt;distTo[v]+e.weight())&#123; distTo[w]=distTo[v]+e.weight(); edgeTo[w]=e; if(pq.contains(w))&#123; pq.changeKey(w, distTo[w]); &#125;else&#123; pq.insert(w, distTo[w]); &#125; &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return distTo[v]&lt;Double.POSITIVE_INFINITY; &#125; public double distTo(int v)&#123; return distTo[v]; &#125; public Iterable&lt;DirectEdge&gt; pathTo(int v)&#123; Stack&lt;DirectEdge&gt; stack=new Stack&lt;DirectEdge&gt;(); while(edgeTo[v]!=null)&#123; stack.push(edgeTo[v]); v=edgeTo[v].from(); &#125; return stack; &#125;&#125; 算法分析 Dijkstra算法时间复杂度取决于存储顶点的数据结构 上面算法的实现使用的是最小优先队列，每次删除最小距离顶点时间复杂度为logV，整个算法需要对每条边松弛，所以基于最小优先队列的Dijkstra算法的时间复杂度为ElogV 基于拓扑排序的最短路径算法 算法原理 将图按照拓扑排序的顺序放松顶点 这种算法只能应用在无环有向图中，并且它允许图的边的权重是负值，他还能解决相关的问题比如最长路径 算法实现 12345678910111213141516171819202122232425262728293031323334353637383940//利用拓扑排序实现的最短路径算法 public class AcyclicSP &#123; private DirectEdge[] edgeTo; private double[] distTo; public AcyclicSP(EdgeWeightDigraph G,int s)&#123; edgeTo=new DirectEdge[G.V()]; distTo=new double[G.V()]; for(int v=0;v&lt;G.V();v++)&#123; distTo[v]=Double.POSITIVE_INFINITY; &#125; distTo[s]=0.0; TopoEdgeWeight top=new TopoEdgeWeight(G); for(int v:top.order())&#123; relax(G,v); &#125; &#125; private void relax(EdgeWeightDigraph G,int v)&#123; for(DirectEdge e:G.adj(v))&#123; int w=e.to(); if(distTo[w]&gt;distTo[v]+e.weight())&#123; distTo[w]=distTo[v]+e.weight(); edgeTo[w]=e; &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return distTo[v]&lt;Double.POSITIVE_INFINITY; &#125; public double distTo(int v)&#123; return distTo[v]; &#125; public Iterable&lt;DirectEdge&gt; pathTo(int v)&#123; Stack&lt;DirectEdge&gt; stack=new Stack&lt;DirectEdge&gt;(); while(edgeTo[v]!=null)&#123; stack.push(edgeTo[v]); v=edgeTo[v].from(); &#125; return stack; &#125; &#125; 在查找最短路径之前需要对图进行拓扑排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class TopoEdgeWeight &#123; private boolean marked[]; private Stack&lt;Integer&gt; stack; public TopoEdgeWeight(EdgeWeightDigraph G)&#123; marked=new boolean[G.V()]; stack=new Stack&lt;Integer&gt;(); EdgeWeightDigraphCycle cycle=new EdgeWeightDigraphCycle(G); if(!cycle.hasCycle())&#123; TopoSort(G); &#125; &#125; private void TopoSort(EdgeWeightDigraph G)&#123; for(int v=0;v&lt;G.V();v++)&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; private void dfs(EdgeWeightDigraph G,int v)&#123; marked[v]=true; for(DirectEdge e:G.adj(v))&#123; if(!marked[e.to()])&#123; dfs(G,e.to()); &#125; &#125; stack.push(v); &#125; public Iterable&lt;Integer&gt; order()&#123; return stack; &#125;&#125;``` 在拓扑排序之前需要检查图是不是无环图 ```javapublic class EdgeWeightDigraphCycle &#123; private boolean[] marked; private DirectEdge[] edgeTo; private Stack&lt;DirectEdge&gt; cycle; private boolean[] onStack; public EdgeWeightDigraphCycle(EdgeWeightDigraph G)&#123; marked=new boolean[G.V()]; edgeTo=new DirectEdge[G.V()]; onStack=new boolean[G.V()]; for(int v=0;v&lt;G.V();v++)&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; private void dfs(EdgeWeightDigraph G,int v)&#123; marked[v]=true; onStack[v]=true; for(DirectEdge e:G.adj(v))&#123; int w=e.to(); if(hasCycle())&#123; return; &#125;else if(!marked[w])&#123; edgeTo[w]=e; dfs(G,w); &#125;else if(onStack[w])&#123; cycle=new Stack&lt;DirectEdge&gt;(); DirectEdge f=e; while(f.from()!=w)&#123; cycle.push(f); f=edgeTo[f.from()]; &#125; cycle.push(f); return; &#125; &#125; onStack[v]=false; &#125; public boolean hasCycle()&#123; return cycle!=null; &#125; public Iterable&lt;DirectEdge&gt; cycle()&#123; return cycle; &#125;&#125; 算法分析基于拓扑排序的最短路径算法是一种比Dijkstra算法更快更简单的在无环加权有向图中找到最短路径的算法基于拓扑排序的最短路径算法的时间复杂度是O(V+E) Floyd算法 算法原理 从任意节点v到节点w最短路径有两种情况：第一种是直接从v到w；第二种是从v经过若干个节点到达w，对图中的每个节点k，检查dist(v,k)+dist(k,w)&lt;dist(v,w)是否成立，如果成立，那么更新v到w的最短路径为dist(v,k)+dist(k,w)，如此当我们遍历完图中所有的节点之后，v到w的最短路径和最短距离就确定了。 此算法就是一任意的顺序放松图中所有的边，重复V轮。 算法实现三重循环实现 for (int k=0; k&lt;n; ++k) { for (int i=0; i&lt;n; ++i) { for (int j=0; j&lt;n; ++j) { if (dist[i][k] + dist[k][j] &lt; dist[i][j] ) { dist[i][j] = dist[i][k] + dist[k][j]; path[i][j] = path[k][j]; } } } } 算法分析 Floyd算法的时间复杂度为：O(V3) Bellman-Ford算法Bellman-ford算法是求含负权图的单源最短路径算法，效率很低，但代码很容易写 算法原理利用队列 算法实现 public class BellmanFord { private double[] distTo; private DirectEdge[] edgeTo; private boolean[] onQ;//该顶点是否在队列中 private Queue&lt;Integer&gt; queue;//用于存放将被放松的顶点 private int cont;//放松的次数 private Iterable&lt;DirectEdge&gt; cycle; public BellmanFord(EdgeWeightDigraph G,int s){ distTo=new double[G.V()]; edgeTo=new DirectEdge[G.V()]; onQ=new boolean[G.V()]; queue=new Queue&lt;Integer&gt;(); for(int v=0;v&lt;G.V();v++){ distTo[v]=Double.POSITIVE_INFINITY; } queue.enqueue(s); onQ[s]=true; distTo[s]=0.0; while(!queue.isEmpty() &amp;&amp; hasNegativeCycle()){ int v=queue.dequeue(); onQ[v]=false; relax(G,v); } } private void relax(EdgeWeightDigraph G,int v){ for(DirectEdge e:G.adj(v)){ int w=e.to(); if(distTo[w]&gt;distTo[v]+e.weight()){ distTo[w]=distTo[v]+e.weight(); edgeTo[w]=e; if(!onQ[w]){ queue.enqueue(w); onQ[w]=true; } } if(cont++ % G.V() ==0){ findNegativeCycle(); } } } public void findNegativeCycle(){ int V=edgeTo.length; EdgeWeightDigraph bf=new EdgeWeightDigraph(V); for(int v=0;v&lt;V;v++){ if(edgeTo[v]!=null){ bf.addEdge(edgeTo[v]); } } EdgeWeightDigraphCycle cf=new EdgeWeightDigraphCycle(bf); cycle=cf.cycle(); } public boolean hasNegativeCycle(){ return cycle!=null; } public Iterable&lt;DirectEdge&gt; negativeCycle(){ return cycle; } public boolean hasPathTo(int v){ return distTo[v]&lt;Double.POSITIVE_INFINITY; } public double distTo(int v){ return distTo[v]; } public Iterable&lt;DirectEdge&gt; pathTo(int v){ Stack&lt;DirectEdge&gt; stack=new Stack&lt;DirectEdge&gt;(); while(edgeTo[v]!=null){ stack.push(edgeTo[v]); v=edgeTo[v].from(); } return stack; } } 算法分析BellmanFord算法的时间复杂度一般情况为O(E+V),最坏情况为O(VE)]]></content>
      <tags>
        <tag>Algorihtms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-图（最小生成树）]]></title>
    <url>%2F2018%2F11%2F04%2FJava%E7%AE%97%E6%B3%95-%E5%9B%BE%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最小生成树定义：加权图：加权图是图中每条边都关联一个权值的图模型(边的权重可以表示距离、时间、费用等不同变量；权中可正可负)带权重边的表示：1234567891011121314151617181920212223242526272829303132333435public class Edge implements Comparable&lt;Edge&gt; &#123; private int v; private int w;//v,w为边连接的两个顶点 private double weight;//边的权重 public Edge(int v,int w,double weight)&#123; this.v=v; this.w=w; this.weight=weight; &#125; public double weight()&#123; return weight; &#125; public int either()&#123; return v; &#125; public int other(int vertex)&#123; if(vertex==v)&#123; return w; &#125;else if(vertex==w)&#123; return v; &#125;else&#123; throw new RuntimeException("Inconsistent edge"); &#125; &#125; @Override public int compareTo(Edge that)&#123; if(this.weight()&lt;that.weight())&#123; return -1; &#125;else if(this.weight()&gt;that.weight())&#123; return 1; &#125;else&#123; return 0; &#125; &#125;&#125;无向加权图的表示：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 public class EdgeWeightGraph &#123; private int V; private int E; private Bag&lt;Edge&gt;[] adj; public EdgeWeightGraph(int V)&#123; this.V=V; this.E=0; adj=(Bag&lt;Edge&gt;[])new Bag[V]; for(int v=0;v&lt;V;v++)&#123; adj[v]=new Bag&lt;Edge&gt;(); &#125; &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; //添加边 public void addEdge(Edge e)&#123; int v=e.either(); int w=e.other(v); adj[v].add(e); adj[w].add(e); E++; &#125; public Iterable&lt;Edge&gt; adj(int v)&#123; return adj[v]; &#125; //返回图中所有的边 public Iterable&lt;Edge&gt; edges()&#123; Bag bag=new Bag&lt;Edge&gt;(); for(int v=0;v&lt;V;v++)&#123; for(Edge e:adj[v])&#123; if(e.other(v)&gt;v)&#123; bag.add(e); &#125; &#125; &#125; return bag; &#125; //显示图表 public String toString()&#123; StringBuilder s=new StringBuilder(); s.append(V+"Vertexs"+E+"Edges\n"); for(int v=0;v&lt;V;v++)&#123; s.append(v+":"); for(Edge e:adj[v])&#123; s.append(e+" "); &#125; s.append("\n"); &#125; return s.toString(); &#125;&#125; 生成树：一幅图的生成树是它的一棵含有其所有顶点的无环连通子图最小生成树(MST)：一幅图的最小生成树是它的一棵所有边权值和最小的生成树(生成树+所有边权值和最小) 切分定理图的切分：将图中所有的顶点分为两个非空且不重叠的两个集合，横切边(crossing edge)是一条连接两个属于不同集合中顶点的边切分定理：一幅加权图中，对于图的任意切分的横切边中的权重最小的边一定属于改图的最小生成树切分定理会把加权图所有的顶点分为两个集合，检查每次切分的横切边并识别属于最小生成树的边最小生成树的贪心算法： 生成最小生成树的基础是切分定理，对于一个V个顶点的加权图，使用切分定理找到最小生成树的一条边，不断重复直到找到最小生成树所有的V-1条边 最小生成树Prim算法prim算法的核心是选取一个顶点，每一次向树中添加一条边，知道添加V-1条边；每次添加的边是连接树中的顶点和不在树中的顶点所连接的边中权重值最小的。注：连接树：最小生成树的一部分横切边:为连接树中的顶点和不在连接树中的顶点之间的所有边失效边:如果一条边的两个顶点都在连接树中，则为失效边不去管它 prim算法延时实现过程： 选取一个起始顶点作为生成树的第一个顶点，将此时所有的横切边加入优先队列（MinPQ） 检查队列while(队列不空)： 取出并删除队列中的权重值最小的边 if(这条边失效) contuine结束此次循环 if(这条边有一个顶点不在连接树上)将这个顶点添加到树中，并将新的横切边添加到优先队列中 算法改进：prim算法即时实现延时实现是一些失效的横切边保存在优先队列中(当向连接树添加一个新的顶点v时，所有和v相关联的横切边都会被加入到优先队列中)，只有要删除的时候才检查它的有效性Prim实时实现是不去保存所有的横切边，它只保存连接树顶点和非树顶点中权重最小的边试想：当我们向连接树中添加了一个新的顶点v，那么非树顶点w可能距离连接树的距离更近了，我们只保存非树顶点w和树顶点距离最近的那条边。可能队列中保存着w到连接树的权重最小的边w-&gt;k,当连接树中加入了v之后，w-&gt;v这条边的权重值比w-&gt;k的权重值要小，那么在优先队列中对于顶点w，它和连接树距离最短的边更新为w-&gt;v。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class PrimMST&#123; private Edge[] edgeTo;//用来存储非树顶点距离树最近的边 private double[] distTo;//用来存储边的权重，distTo[i]=edgeTo[i].weight() private boolean[] marked;//用来标记顶点是否在树中 private IndexMinPQ&lt;Double&gt; pq;//存储有效的横切边 public PrimMST(EdgeWeightGraph G)&#123; edgeTo=new Edge[G.V()]; distTo=new double[G.V()]; marked=new boolean[G.V()]; pq=new IndexMinPQ&lt;Double&gt;(G.V()); for(int i=0;i&lt;G.V();i++)&#123; distTo[i]=Double.POSITIVE_INFINITY; &#125; //从顶点0开始 distTo[0]=0.0; pq.insert(0, 0.0); while(!pq.isEmpty())&#123; visit(G,pq.deleteMin()); &#125; //当向最初的树中添加V-1条边后，最小生成树完成而优先队列变为空 &#125; private void visit(EdgeWeightGraph G,int v)&#123; //将v添加至树中，更新相关数据 marked[v]=true; //遍历和v相连的每一个顶点 for(Edge e:G.adj(v))&#123; int w=e.other(v); if(marked[w])&#123; continue; &#125; //检查distTo中存储的是否是w距树最小的距离 if(e.weight()&lt;distTo[w])&#123; edgeTo[w]=e; distTo[w]=e.weight(); //添加或更新优先队列中的相关顶点的数据 if(pq.contains(w))&#123; pq.changeKey(w, distTo[w]); &#125;else&#123; pq.insert(w, distTo[w]); &#125; &#125; &#125; &#125; //遍历最小生成树中的所有边 public Iterable&lt;Edge&gt; edges()&#123; Queue&lt;Edge&gt; q=new Queue&lt;Edge&gt;(); for(int v=0;v&lt;edgeTo.length;v++)&#123; Edge e=edgeTo[v]; if(e!=null)&#123; q.enqueue(e); &#125; &#125; return q; &#125;&#125; Kruskal算法Kruskal算法的核心是将图中所有的边按权重由小到大的顺序加入最小生成树，新加入的边不能与已经加入的边构成环。12345678910111213141516171819202122232425262728 public class KruskalMST &#123; private Queue&lt;Edge&gt;mst; public KruskalMST(EdgeWeightGraph G)&#123; mst=new Queue&lt;Edge&gt;(); //创建最小优先队列，并存储图中所有的边 MinPQ&lt;Edge&gt; pq=new MinPQ&lt;Edge&gt;(G.E()); for(Edge e:G.edges())&#123; pq.insert(e); &#125; //创建并查集Union_Find中的一个形式Quick_find Quick_find uf=new Quick_find(G.V()); while(!pq.isEmpty() &amp;&amp; mst.size()&lt;G.V()-1)&#123; Edge e=pq.deleteMin(); int v=e.either(); int w=e.other(v); //判断这条边的两个顶点是否连通，如果已经连通那么再加入这条边就会形成一个环 if(uf.connected(v, w))&#123; continue; &#125; uf.union(v, w); mst.enqueue(e); &#125; &#125; public Iterable&lt;Edge&gt; edges()&#123; return mst; &#125;&#125;]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-图]]></title>
    <url>%2F2018%2F10%2F10%2FJava%E7%AE%97%E6%B3%95-%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[无向图图的定义：A graph is a set of vertices and a collections of edges that each connect a pair of vertices.graph = edge + vertex 图的表示邻接矩阵假设图有V个顶点，使用一个V*V的布尔矩阵a来表示图，顶点v和顶点w相连那么a[v,w]和a[w,v]都设置为true，相连设置为false。 邻接矩阵在存储一个较大的图时是不可行的，所需要的巨大的空间无法满足。 邻接表邻接表是一个一顶点vertex为索引的列表数组，每一个索引代表一个顶点，数组在该索引处的元素是和该顶点相连接的顶点列表。使用邻接表实现的图有如下特点： 创建图使用的空间和V+E成正比 添加一条边时间为常数 遍历顶点v相邻的顶点所需时间和v的度数成正比 用邻接表创建的Graph数据结构：12345678910111213141516171819202122232425262728293031323334353637383940414243public class Graph &#123; private int V; //顶点数目 private int E; //边的条数 private Bag&lt;Integer&gt;[] adj; //邻接表 public Graph()&#123;&#125; //初始化顶点为V的邻接表 public Graph(int V)&#123; this.V=V; this.E=0; adj=(Bag&lt;Integer&gt;[]) new Bag[V]; for(int i=0;i&lt;V;i++)&#123; adj[i]=new Bag&lt;Integer&gt;(); &#125; &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; public void addEdg(int v,int w)&#123; adj[v].add(w); adj[w].add(v); E++; &#125; public Iterable&lt;Integer&gt; adj(int v)&#123; return adj[v]; &#125; public int degree(int v)&#123; return adj[v].size(); &#125; public String toString()&#123; String s=V+" vertices"+E+" edges\n"; for(int i=0;i&lt;V;i++)&#123; s+=i+":"; for(int j:this.adj[i])&#123; s+=j+" "; &#125; s+="\n"; &#125; return s; &#125;&#125; 深度优先搜索深度优先搜索类似于走迷宫的Tremaux搜索。从一个没有走过的路口开始，走过的路铺一条绳子；标记走过的路口；当来到标记的路口，一直回退到有没被标记的路口继续走，如果回退时一直无路可走就一直回退到起点。 深度优先搜索类似于走迷宫，一直寻找没有被访问的节点深度优先搜索需要用递归的方法遍历图中所有的顶点 将访问的节点标记 递归的访问它的所有没有被标记的邻居节点深度优先代码如下： 12345678910111213141516171819202122public class DFS&#123; private boolean[] marked; private int count; public DFS(Graph G,int s)&#123; marked=new boolean[G.V()]; dfs(G,s); &#125; private void dfs(Graph G,int s)&#123; marked[s]=true; for(int v:G.adj[s])&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; public boolean marked(int w)&#123; return marked[m]; &#125; public int count()&#123; return count; &#125;&#125; 下面是DFS的搜索轨迹图： 深度优先搜索可以遍历图中所有的顶点和边，利用DFS可以解决图中的一些问题： 连通性问题：给定的两个顶点是否相连 单点问题，路径问题：某一起点与任意联通顶点的路径下面为利用DFS查找图中的路径的算法程序 12345678910111213141516171819202122232425262728293031323334353637 public class DepthFirstPaths &#123; private boolean[] marked;//用于标记顶点是否被访问过 private int[] edgeTo; //记录从起点到一个顶点的路径上的最后一个顶点 private int s; public DepthFirstPaths(Graph G,int s)&#123; this.s=s; marked=new boolean[G.V()]; edgeTo=new int[G.V()]; dfs(G,s); &#125; //深度优先算法DFS private void dfs(Graph G,int v)&#123; marked[v]=true; for(int w:G.adj(v))&#123; if(!marked[w])&#123; edgeTo[w]=v; dfs(G,w); &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return marked[v]; &#125; //返回起点到某个顶点的路径 public Iterable&lt;Integer&gt; pathTo(int v)&#123; if(!hasPathTo(v))&#123; return null; &#125; Stack&lt;Integer&gt; path=new Stack&lt;Integer&gt;(); for(int x=v;x!=s;x=edgeTo[x])&#123; path.push(x); &#125; path.push(s); return path; &#125;&#125; 下图为DFS搜索路径的轨迹实例图 广度优先搜索我们常要解决的问题是图中两个点之间最短的路径问题，DFS可以找出两点间的联通路径，却没办法找到最短的路径，但广度优先搜索可以解决这个问题。 在广度优先搜索中我们是按照与起点的距离的顺序遍历所有结点，这里用到了队列（先进先出，就近遍历）；首先将起点标记并加入队列，重复以下步骤直到队列为空： 将队列中的下一个顶点v出队，并将其标记； 将与v相邻且未被标记的顶点按顺序依次入队；BFS搜索路径算法： 12345678910111213141516171819202122232425262728293031323334353637383940414243 public class BreadthFirstPaths &#123; private boolean[] marked;//用于标记顶点是否被访问过 private int[] edgeTo; //记录从起点到一个顶点的路径上的最后一个顶点 private int s; public BreadthFirstPaths(Graph G,int s)&#123; this.s=s; marked=new boolean[G.V()]; edgeTo=new int[G.V()]; bfs(G,s); &#125; //广度优先算法BFS private void bfs(Graph G,int s)&#123; Queue&lt;Integer&gt; queue=new Queue&lt;Integer&gt;(); marked[s]=true; queue.enqueue(s); while(!queue.isEmpty())&#123; int v=queue.dequeue(); for(int w:G.adj(v))&#123; if(!marked[w])&#123; edgeTo[w]=v; marked[w]=true; queue.enqueue(w); &#125; &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return marked[v]; &#125; //返回起点到某个顶点的路径 public Iterable&lt;Integer&gt; pathTo(int v)&#123; if(!hasPathTo(v))&#123; return null; &#125; Stack&lt;Integer&gt; path=new Stack&lt;Integer&gt;(); for(int x=v;x!=s;x=edgeTo[x])&#123; path.push(x); &#125; path.push(s); return path; &#125;&#125; 下图为BFS实例中搜索轨迹图： 用BFS检测给定的图是无环的吗。用BFS检测是否是二分图（即任意一条边的两个顶点都不属于同一连通集） DFS和BFS具有不同的搜索路径： 深度优先搜索是不断深入图中，探索距离起点越来越远的顶点，只有碰到访问过的顶点或者死胡同时才返回到最近的顶点；广度优先搜索像扇面一样前进，它只有访问了一个顶点附近相邻的所有顶点之后才继续向前探索；DFS的路径通常长而曲折，而BFS路径短而整齐直接。 如下图所示两种搜索方式的路径对比： 连通分量DFS解决连通性问题用深度优先搜索来查找图中所有的连通分量的算法123456789101112131415161718192021222324252627282930313233343536public class CC&#123; private boolean[] marked; //用来标记顶点是否被访问过 private int[] id; //用来标记所属的连通集 private int count; //表示连通集 public CC(Graph G)&#123; marked=new boolean(G.V()); id=new int(G.V()); for(int s=0;s&lt;G.V();s++)&#123; if(!marked[s])&#123; dfs(G,s); count++; &#125; &#125; &#125; public dfs(Graph G,int v)&#123; marked[v]=true; id[v]=count; for(int s:G.adj[v])&#123; if(!marked[s])&#123; dfs(G,s); &#125; &#125; &#125; //判断两个顶点是否属于同一个连通分量 public boolean connect(int v,int w)&#123; return id[v]==id[w]; &#125; //返回顶点所在的连通集 public int id(int v)&#123; return id[v]; &#125; //返回有几个连通分量 public int count()&#123; return count; &#125;&#125;下图为搜索图中所有连通分量的轨迹： 并查集解决连通性问题Union_Find：并查集能解决动态连通性问题，union()会将两个分量合并到同一连通分量，fins()会返回给定点所在的连通分量的标识符，connect()会判断两个点是否在同一连通分量，count()会返回连通分量的数量。123456789101112131415161718192021 //并查集抽象类，关键的是抽象的方法find和union abstract class Union_Find &#123; protected int[] id; protected int count; public Union_Find(int N)&#123; count=N; id=new int[N]; for(int i=0;i&lt;N;i++)&#123; id[i]=i; &#125; &#125; public int count()&#123; return count; &#125; public boolean connected(int p,int q)&#123; return find(p)==find(q); &#125; public abstract int find(int p); public abstract void union(int p,int q); &#125; Quick Find快速查找算法：id[]这个数组标记着结点所在的连通集，将在同一连通集的结点的id[]值设置为同一个值，当将两个连通集合并的时候，将一个连通集内的所有结点的id[]值改为另一个连通集的id[]值。 这种算法不适合处理大型问题，以为find速度很快，但是union速度非常慢，需要将其中一个连通分量中的所有节点 id 值都修改为另一个节点的 id 值 1234567891011121314151617181920212223 //快速查找算法public class Quick_find extends Union_Find &#123; public Quick_find(int N)&#123; super(N); &#125; public int find(int p)&#123; return id[p]; &#125; public void union(int p,int q)&#123; int pID=find(p); int qID=find(q); if(pID==qID)&#123; return; &#125; for(int i=0;i&lt;id.length;i++)&#123; if(id[i]==pID)&#123; id[i]=qID; &#125; &#125; count--; &#125;&#125; Quick Union需要一种快速union的算法，只需要修改一下id[]数组的结构，每个点对应的id[]元素都是同一连通分量的其它点，这叫做链接。一个结点由链接找到指向它的另一个结点，这个节点再继续查找，以此类推知道找到这个连通集的根节点，类似以树结构。 union操作时只需将一个连通集的根节点指向另一个连通集的根节点 这种算法union操作很高效，find操作时间复杂度和树的高度成正比，最坏情况下树的高度为结点个数 quick-union算法123456789101112131415161718192021//快速合并算法public class Quick_Union extends Union_Find &#123; public Quick_Union(int N) &#123; super(N); &#125; public int find(int p)&#123; while(p!=id[p])&#123; p=id[p]; &#125; return p; &#125; public void union(int p,int q)&#123; int pID=find(p); int qID=find(q); if(pID==qID)&#123; return; &#125; id[pID]=qID; count--; &#125;&#125; 加权Quick Union为了防止quick-union最坏情况的发生，改进quick-union为加权quick-union算法 做法是记录被一个连通集的大小，union时将小的连通集指向大的连通集，这样生成的连通集会很平衡 加权的quick-union算法能够实现lgN对数级别的性能 123456789101112131415161718192021222324252627282930313233343536373839404142434445 //加权快速合并算法public class WeightedQuickUnion &#123; private int[] id; private int[] sz; private int count; public WeightedQuickUnion(int N)&#123; count=N; id=new int[N]; for(int i=0;i&lt;N;i++)&#123; id[i]=i; &#125; sz=new int[N]; for(int i=0;i&lt;N;i++)&#123; sz[i]=1; &#125; &#125; public int count()&#123; return count; &#125; public boolean connected(int p,int q)&#123; return find(p)==find(q); &#125; public int find(int p)&#123; while(p!=id[p])&#123; p=id[p]; &#125; return p; &#125; public void union(int p,int q)&#123; int pID=find(p); int qID=find(q); if(pID==qID)&#123; return; &#125; if(sz[pID]&lt;sz[qID])&#123; id[pID]=qID; sz[qID]+=sz[pID]; &#125;else&#123; id[qID]=pID; sz[pID]+=sz[qID]; &#125; count++; &#125;&#125; 有向图有向图：由一组顶点和一组有向的边组成的。 有向图也用邻接表表示，与无向图不同的是无向图制定了a通向b，即a-&gt;b,那么同时就有b-&gt;a;但有向图不一样，当指定了a-&gt;b没有b-&gt;a。 有向图的数据结构只有addEdg()方法不同，去掉注释的语句：12345public void addEdg(int v,int w)&#123; adj[v].add(w); #adj[w].add(v); E++;&#125; 有向图的可达性单点可达性：一个图和一个起点s–&gt;是否存在从s到v的有向路径多点可达性： 一个图和一个顶点集合–&gt;是否存在从集合任意顶点到达给定顶点的有向路径 12345678910111213141516171819202122232425262728293031 public class DirectedDFS &#123; private boolean[] marked; //单点可达判断 public DirectedDFS(Digraph G,int s)&#123; marked=new boolean[G.V()]; dfs(G,s); &#125; //多点可达判断 public DirectedGFS(Digraph G,Iterable&lt;Integer&gt; sources)&#123; marked=new boolean[G.V()]; for(int s:sources)&#123; if(!marked[s])&#123; dfs(G,s); &#125; &#125; &#125; //深度优先搜索 private void dfs(Digraph G,int v)&#123; marked[v]=true; for(int w:G.adj[v])&#123; if(!marked[w])&#123; dfs(G,w); &#125; &#125; &#125; //判断一个点是否可达 public boolean marked(int v)&#123; return marked[v]; &#125;&#125; 图中的环和有向无环图有些问题是不允许图中有有向环的可以用DFS检测一个图是否是有向无环图代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class DirectedCycle &#123; private boolean[] marked; //标记顶点 private int[] edgeTo; //标记指向的顶点 private Stack&lt;Integer&gt; cycle; //存储有向环中的顶点 private boolean[] onStack; //标记递归调用的栈上的所有顶点 public DirectedCycle(Digraph G)&#123; marked=new boolean[G.V()]; edgeTo=new int[G.V()]; onStack=new boolean[G.V()]; for(int v=0;v&lt;G.V();v++)&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; private void dfs(Digraph G,int v)&#123; marked[v]=true; onStack[v]=true; for(int w:G.adj(v))&#123; if(this.hasCycle())&#123; return; &#125;else if(!marked[w])&#123; edgeTo[w]=v; dfs(G,w); &#125;else if(onStack[w])&#123; cycle=new Stack&lt;Integer&gt;(); for(int x=v;v!=w;v++)&#123; cycle.push(x); &#125; cycle.push(w); cycle.push(v); &#125; &#125; onStack[v]=false; &#125; public boolean hasCycle() &#123; // TODO Auto-generated method stub return cycle!=null; &#125; public Iterable&lt;Integer&gt; cycle()&#123; return cycle; &#125;&#125; 拓扑排序对于有向图深度优先搜索只会访问图中每个顶点一次将DFS访问的顶点存储在一个数据结构，遍历这个数据结构就能按一定顺序得到图中所有的顶点根据数据结构的不同和保存节点的时间不同分成三种顺序： 前序：队列-&gt;在递归调用前将点入队 后序：队列-&gt;在递归调用之后将顶点入队 逆后序:栈-&gt;在递归之后将顶点入栈 代码如下：1234567891011121314151617181920212223242526272829303132333435363738 public class DepthFirstOrder &#123; private boolean[] marked; private Queue&lt;Integer&gt; pre; //所有顶点的前序排列 private Queue&lt;Integer&gt; post; //所有顶点的后序排列 private Stack&lt;Integer&gt; reverpost; //所有顶点的逆后排序 public DepthFirstOrder(Digraph G)&#123; pre=new Queue&lt;Integer&gt;(); post=new Queue&lt;Integer&gt;(); reverpost=new Stack&lt;Integer&gt;(); marked=new boolean[G.V()]; for(int v=0;v&lt;G.V();v++)&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; private void dfs(Digraph G,int v)&#123; pre.enqueue(v); //递归之前入队 marked[v]=true; for(int w:G.adj(v))&#123; if(!marked[w])&#123; dfs(G,w); &#125; &#125; post.enqueue(v); //低估后入队 reverpost.push(v); &#125; public Iterable&lt;Integer&gt; pre()&#123; return pre; &#125; public Iterable&lt;Integer&gt; post()&#123; return post; &#125; public Iterable&lt;Integer&gt; reverpost()&#123; return reverpost; &#125;&#125; 拓扑排序：是对有向无环图的排序，给定一幅图，将所有顶点排序，使所有的有向边从排在前面的元素指向排在后面的元素，如果有一条路径从v-&gt;w，那么排序后v就要在w的前面拓扑排序主要用来对有依赖关系的事物排序一个有向无环图的拓扑排序顺序即所有顶点逆后序排列给定的一个图先判断是否无环，然后利用DepthFirstOrder返回逆后序顶点就是拓扑排序的结果1234567891011121314 public class Topological &#123; private Iterable&lt;Integer&gt; order; public Topological(Digraph G)&#123; DirectedCycle dc=new DirectedCycle(G); //判断是否是有向无环图 if(!dc.hasCycle())&#123; DepthFirstOrder dfs=new DepthFirstOrder(G); order=dfs.reverpost(); &#125; &#125; public Iterable&lt;Integer&gt; order()&#123; return order; &#125;&#125; 有向图的强连通性强连通：有向图中如果两个顶点互相可达则这两个点是强连通的强连通分量：有向图中的一个强连通分量是图中的一个最大的顶点集合C，对于C中的每一对顶点u和v，u和v是强连通的 识别计算有向图中的强连通分量：Kosaraju算法 对于一个有向图G，使用DepthFirstOrder来计算它的反向图GR的逆后序排序列 按照的到的GR的逆后序列的顺序在G中进行深度优先搜索 下列代码可以判断两个顶点是否强连通，查找并计算所有的强连通分量1234567891011121314151617181920212223242526272829303132333435363738public class KosarajuSCC &#123; private boolean[] marked; //用来标记顶点是否被访问过 private int[] id;//记录强连通分量的标识 private int count;//记录强连通分量的数量 public KosarajuSCC(Digraph G)&#123; marked=new boolean[G.V()]; id=new int[G.V()]; DepthFirstOrder order=new DepthFirstOrder(G.reverse());//计算GR的逆后序列 for(int s:order.reverpost())&#123; if(!marked[s])&#123; dfs(G,s); count++; &#125; &#125; &#125; private void dfs(Digraph G, int v) &#123; marked[v]=true; id[v]=count; for(int w:G.adj(v))&#123; if(!marked[w])&#123; dfs(G,w); &#125; &#125; &#125; //判断两顶点是否强连通 public boolean stronglyConnected(int v,int w)&#123; return id[v]==id[w]; &#125; //返回顶点所在的强连通分量 public int id(int v)&#123; return id[v]; &#125; //返回强连通分量的数量 public int count()&#123; return count; &#125;&#125;]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-查找（散列表）]]></title>
    <url>%2F2018%2F09%2F29%2FJava%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE%EF%BC%88%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[散列查找在查找算法中如果利用数组将要存储的键作为数组索引下标，将对应的值作为数组的内容，在预先知道所要查找的内容在数组的下标可以实现快速查找，实现时间复杂度为O(1)的算法。由于键值可能是各种类型的，可能是整数、可能是字符串类型不能直接作为数组的索引，所以第一步就是要通过散列函数将键转化为数组的索引值。由于散列函数在转化过程中不同的键可能变成相同的索引值，出现碰撞冲突，所以第二步就要处理碰撞冲突。 散列函数如果保存键值的数组大小为M，那么键值通过散列函数就要转化在[0,M-1]的索引范围内，我们需要的散列函数能够将键值均匀的分布在[0,M-1]内，每个键都有相同的可能与0~M-1红的每个整数对应。 我们所使用的散列函数能够均匀并独立的将所有的键分布于0到M-1之间 由于键值的数据类型不同，所需要的散列函数也不同，每种类型都有与之对应的散列函数 整数类型对于整数类型常用的方法是除留余数法:k%M最好使用不是2的幂的质数 浮点数将键表示为二进制然后使用除留余数法 字符串下面为String类型中计算hash值得算法 1234567891011public int hashCode() &#123; int h = hash; //hash是初始值，一般为0 if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; 组合键下面为自定义类的hashcode算法，它将类中的所有成员变量综合起来计算hash值 默认的hashcode函数返回对象的地址 123456789101112131415public class Person &#123; private String name; private int age; private String sex; private String city; public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((city == null) ? 0 : city.hashCode()); result = prime * result + ((name == null) ? 0 : name.hashCode()); result = prime * result + ((sex == null) ? 0 : sex.hashCode()); return result; &#125;&#125; 将hashcode()的返回值转化为数组索引 1234 public int hash(Key k)&#123; return (k.hashCode() &amp; 0x7fffffff) % M;&#125; &amp;的作用是将计算出的hashCode值得符号位屏蔽 基于拉链法的散列表拉链法：保存数组的大小为M，将数组的每一个元素指向一个链表，每个链表中都存储键值相同的元素。 12345678910111213141516171819202122232425262728293031323334 public class SeparateChainingHashST&lt;Key,Value&gt; &#123; private int N;//键值对总数 private int M;//散列表大小 private SequentialSearchST&lt;Key,Value&gt;[] st;//存储链表的数组 public SeparateChainingHashST(int M) &#123; this.M = M; st=(SequentialSearchST&lt;Key,Value&gt;[]) new SequentialSearchST[M]; for(int i=0;i&lt;M;i++)&#123; st[i]=new SequentialSearchST(); &#125; &#125; private int hash(Key key)&#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; public Value get(Key key)&#123; return st[hash(key)].get(key); &#125; public void put(Key key,Value val)&#123; st[hash(key)].put(key, val); &#125; public void delete(Key key)&#123; st[hash(key)].delete(key); &#125; public Iterable&lt;Key&gt; keys()&#123; Queue&lt;Key&gt; queue=new Queue&lt;Key&gt;(); for(int i=0;i&lt;M;i++)&#123; for(Key key:st[i].keys())&#123; queue.enqueue(key); &#125; &#125; return queue; &#125;&#125; 拉链法的散列表性能分析： 一张含有M个链表和N个键的散列表中，未命中的查找和插入所需要的比较次数大约为N/M 需要选择合适的M：如果M过大会空链表多浪费空间资源，但查找速度快；M过小链表平均长度变长，查找效率低；应该选择足够大的M能够将性能提高M倍。也可以选择动态调整数组大小 基于线性探测法的散列表（开放地址散列表）线性探测法：通过哈希函数将键值k转化成数组索引值n，检查数组索引为n的位置会出现三种情况 该位置键值为空，将键值对插入该位置 该位置的键和被查找的键相同，如果查找操作返回查找内容，如果插入操作将键所对应的值换成新值 该位置的键和被查找的键不同，则增大索引继续检查下一个键值，知道找到该键或者遇到一个空元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class LinearProbingHashST&lt;Key,Value&gt; &#123; private int N; private int M; private Key[] keys; private Value[] vals; public LinearProbingHashST(int M)&#123; this.M=M; keys=(Key[]) new Object[M]; vals=(Value[]) new Object[M]; &#125; private int hash(Key key)&#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; public boolean contains(Key key)&#123; return get(key)!=null; &#125; private void resize(int cap)&#123; LinearProbingHashST&lt;Key,Value&gt; t=new LinearProbingHashST&lt;Key,Value&gt;(cap); for(int i=0;i&lt;M;i++)&#123; if(keys[i]!=null)&#123; t.put(keys[i], vals[i]); &#125; &#125; keys=t.keys; vals=t.vals; M=t.M; &#125; public void put(Key key,Value val)&#123; //N/M&gt;=1/2调整到1/4，使N/M保持在(1/8~1/2) if(N&gt;=M/2)&#123; resize(2*M); &#125; for(int i=hash(key);keys[i]!=null;i=(i+1)%M)&#123; if(key.equals(keys[i]))&#123; vals[i]=val; return; &#125; keys[i]=key; vals[i]=val; N++; &#125; &#125; public Value get(Key key)&#123; for(int i=hash(key);keys[i]!=null;i=(i+1)%M)&#123; if(keys[i].equals(key))&#123; return vals[i]; &#125; &#125; return null; &#125; public void delete(Key key)&#123; if(!contains(key))&#123; return; &#125; int i=hash(key); while(!keys[i].equals(key))&#123; i=(i+1)%M; &#125; keys[i]=null; vals[i]=null; i=(i+1)%M; while(keys[i]!=null)&#123; Key k=keys[i]; Value v=vals[i]; keys[i]=null; vals[i]=null; N--; put(k,v); i=(i+1)%M; &#125; N--; if(N&gt;0 &amp;&amp; N&lt;=M/8)&#123; resize(M/2); &#125; &#125; public Iterable&lt;Key&gt; keys()&#123; Queue&lt;Key&gt; queue=new Queue&lt;Key&gt;(); for(int i=0;i&lt;M;i++)&#123; if(keys[i]!=null)&#123; queue.enqueue(keys[i]); &#125; &#125; return queue; &#125; &#125; 线性探测法的性能分析：开放地址类的散列表的性能依赖于散列表的使用率p=N/M，我们一般会动态调整数组的大小是p保持在1/8~1/2之间。 在一张大小为M并包含有N=pM个键的基于线性探测的散列表中，命中和非命中查找所需要的探测次数为：~1/2(1+1/(1-p))和~1/2(1+1/(1-p)*(1-p)) 当p趋近1时，查找次数趋近于无穷；当p=1/2时，查找次数在[1.5,2.5]的范围呃内；所以动态调整数组大小减小p避免连列表过满，散列表快满时所需要的查找次数非常大。 散列表能够使查找和插入操作在时间复杂度上为常数级，理论上是最优的性能. 但它也有几个问题: 散列函数 :每种数据类型都需要优秀的散列函数，散列函数的计算可能复杂昂贵，一个好的散列函数直接影响着散列表的性能。 散列表不支持有序性操作：散列表中的键是无序的，如果你想快速找到最大最小值或者某个范围的键，散列表不合适因为这些操作都是线性级别的。]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-Comparable和Comparator的区别]]></title>
    <url>%2F2018%2F09%2F24%2FJava-Comparable%E5%92%8CComparator%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[ComparableComparable接口是排序接口，实现了这个借口的数据类型或者类可以通过Collection.sort()和Arrays.sort()自动排序，此接口中有一个方法compareTo(). public int compareTo(T p); Comparable是内部比较器，需要在一个类的内部实现,在类中需要重写compareTo方法，在此方法中需要实现所要比较的方式，比如如下代码，比较两个对象的方式是先比较姓名，如果一样在比较年龄。 定义一个实现了Comparable接口的Person类12345678910111213141516171819202122232425262728public class Person implements Comparable&lt;Person&gt; &#123; private String name; private int age; public Person(String name,int age)&#123; this.name=name; this.age=age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int compareTo(Person p)&#123; int rest=this.name.compareTo(p.name); if(rest!=0)&#123; return rest; &#125;else&#123; return this.age-p.age; &#125; &#125;&#125; 测试Person类的排序123456789101112131415161718public class test &#123; public static void main(String[] args)&#123; Person p1=new Person("keluosi",27); Person p2=new Person("nuoyier",30); Person p3=new Person("luoyisi",26); System.out.println(p1.compareTo(p2)); Person[] people=new Person[]&#123;p1,p2,p3&#125;; System.out.println("before sort:"); for(Person p:people)&#123; System.out.println(p.getName()+"---"+p.getAge()); &#125; Arrays.sort(people); System.out.println("after sort:"); for(Person p:people)&#123; System.out.println(p.getName()+"---"+p.getAge()); &#125; &#125;&#125; ComparatorComparator是比较接口，如果一个类没有实现Comparable接口需要对该类排序，则可以设计一个实现Comparator接口的比较器，通过这个类的比较器就可以对该类排序。Comparator是外部比较器，和Comparale不同不需要在类中实现，在对一个类实现比较排序时可以不用修改该类的源代码，只需创建该类的比较器利用这个比较器就可以对该类进行排序。使用Comparator有两种方式：一种是创建实现Compartor接口的比较器，使用时直接创建该比较器的对象；另一种是直接在使用到比较器的地方创建一个匿名内部类。如下代码：实现了Person类的比较器：123456public class PersonComparator implements Comparator&lt;Person&gt; &#123; public int compare(Person p1,Person p2)&#123; int rest=p1.getName().compareTo(p2.getName()); return rest!=0 ? rest:p1.getAge()-p2.getAge(); &#125;&#125;使用测试：1234567891011121314151617181920212223242526public class test &#123; public static void main(String[] args)&#123; Person p1=new Person("keluosi",27); Person p2=new Person("nuoyier",30); Person p3=new Person("luoyisi",26); System.out.println(p1.compareTo(p2)); Person[] people=new Person[]&#123;p1,p2,p3&#125;; System.out.println("before sort:"); for(Person p:people)&#123; System.out.println(p.getName()+"---"+p.getAge()); &#125; //使用比较器，创建比较器的对象 PersonComparator pc=new PersonComparator(); Arrays.sort(people,pc); //创建匿名内部类，直接在使用Comparator的地方创建一个Comparator对象并重写compare方法 Arrays.sort(people,new Comparator&lt;Person&gt;()&#123; public int compare(Person p1,Person p2)&#123; return p1.getAge()-p2.getAge(); &#125; &#125;); System.out.println("after sort:"); for(Person p:people)&#123; System.out.println(p.getName()+"---"+p.getAge()); &#125; &#125;&#125; 对比：Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。 Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。 两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-查找（平衡查找树）]]></title>
    <url>%2F2018%2F09%2F22%2FJava%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE%EF%BC%88%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[2-3查找树https://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html 红黑树https://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-查找（二叉搜索树）]]></title>
    <url>%2F2018%2F09%2F22%2FJava%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE%EF%BC%88%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[二叉查找树是一棵二叉树，每个节点的键都大于左子树的任意节点的键，小于右子树的任意节点的键 二叉树的遍历方式分为先序，中序，后序，如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Traversal&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123; private Node root; public class Node&#123; private Key key; private Value val; private Node left; private Node right; private int N; public Node(Key key,Value val,int N)&#123; this.key=key; this.val=val; this.N=N; &#125; &#125; //先序遍历(根节点-&gt;左子树-&gt;右子树) public void PreOrderTraversal()&#123; PreOrderTraversal(root); &#125; //递归实现 private void PreOrderTraversal(Node x) &#123; if(x!=null)&#123; System.out.println(x.key+"---&gt;"+x.val); PreOrderTraversal(x.left); PreOrderTraversal(x.right); &#125; &#125;/* //非递归实现 private void PreOrderTraversal(Node x)&#123; &#125;*/ //中序遍历(左子树-&gt;根节点-&gt;右子树) //递归实现 private void InOrderTraversal(Node x) &#123; if(x!=null)&#123; PreOrderTraversal(x.left); System.out.println(x.key+"---&gt;"+x.val); PreOrderTraversal(x.right); &#125; &#125; //后序遍历(左子树-&gt;右子树-&gt;根节点 ) //递归实现 private void PostOrderTraversal(Node x) &#123; if(x!=null)&#123; PreOrderTraversal(x.left); PreOrderTraversal(x.right); System.out.println(x.key+"---&gt;"+x.val); &#125; &#125; &#125; 基本操作算法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198public class BST&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123; private Node root; public class Node&#123; private Key key; private Value val; private Node left; private Node right; private int N; public Node(Key key,Value val,int N)&#123; this.key=key; this.val=val; this.N=N; &#125; &#125; public int size(Node x)&#123; if(x==null)&#123; return 0; &#125;else&#123; return x.N; &#125; &#125; public void put(Key key,Value val)&#123; root=put(root,key,val); &#125; private Node put(Node x,Key key,Value val)&#123; if(x==null)&#123; return new Node(key,val,1); &#125; int cmp=key.compareTo(x.key); if(cmp&gt;0)&#123; x.right=put(x.right,key,val); &#125;else if(cmp&lt;0)&#123; x.left=put(x.left,key,val); &#125;else&#123; x.val=val; &#125; x.N=size(x.left)+size(x.right)+1; return x; &#125; public Value get(Key key)&#123; return get(root,key); &#125; private Value get(Node x,Key key)&#123; if(x==null)&#123; return null; &#125; int cmp=key.compareTo(x.key); if(cmp&gt;0)&#123; return get(x.right,key); &#125;else if(cmp&lt;0)&#123; return get(x.left,key); &#125;else&#123; return x.val; &#125; &#125; public Key min()&#123; return min(root).key; &#125; private Node min(Node x)&#123; if(x.left==null)&#123; return x; &#125; return min(x.left); &#125;/* //非递归实现 private Key min(Node x)&#123; if(x!=null)&#123; while(x.left!=null)&#123; x=x.left; &#125; &#125; return x; &#125;*/ //max()同理 public Key floor(Key key)&#123; Node x=floor(root,key); if(x==null)&#123; return null; &#125; return x.key; &#125; private Node floor(Node x,Key key)&#123; if(x==null)&#123; return null; &#125; int cmp=key.compareTo(x.key); if(cmp==0)&#123; return x; &#125;else if(cmp&lt;0)&#123; return floor(x.left,key); &#125;else&#123; //注意在右侧查找时可能找不到，这是应返回根节点，而不是在右侧直接返回 Node t=floor(x.right,key); if(t==null)&#123; return x; &#125;else&#123; return t; &#125; &#125; &#125; //ceiling同理 public Key select(int k)&#123; return select(root,k).key; &#125; private Node select(Node x,int k)&#123; if(x==null)&#123; return null; &#125; int t=size(x.left); if(t==k)&#123; return x; &#125;else if(t&gt;k)&#123; return select(x.left,k); &#125;else&#123; //注意右子树查找的数量 k-t-1 return select(x.right,k-t-1); &#125; &#125; public int rank(Key key)&#123; return rank(root,key); &#125; private int rank(Node x,Key key)&#123; if(x==null)&#123; return 0; &#125; int cmp=key.compareTo(x.key); if(cmp==0)&#123; return size(x.left); &#125;else if(cmp&lt;0)&#123; return rank(x.left,key); &#125;else&#123; //注意在右侧查找后返回的元素包括根节点和左子树元素 return rank(x.right,key)+size(x.left)+1; &#125; &#125; public void deleteMin()&#123; root=deleteMin(root); &#125; private Node deleteMin(Node x)&#123; if(x.left==null)&#123; return x.right; &#125; x.left=deleteMin(x.left); x.N=size(x.left)+size(x.right)+1; return x; &#125; //deleteMax()同理 //删除操作，删除一个元素时用这个节点右子树的最小值或者左子树的最大值代替 public void delete(Key key)&#123; root=delete(root,key); &#125; private Node delete(Node x,Key key)&#123; if(x==null)&#123; return null; &#125; int cmp=key.compareTo(x.key); if(cmp&lt;0)&#123; delete(x.left,key); &#125;else if(cmp&gt;0)&#123; delete(x.right,key); &#125;else&#123; if(x.left==null)&#123; return x.right; &#125; if(x.right==null)&#123; return x.left; &#125; Node t=x; x=min(t.right); x.right=deleteMin(t.right); x.left=t.left; &#125; x.N=size(x.left)+size(x.right)+1; return x; &#125; //范围查找 public Iterable&lt;Key&gt; keys(Key lo,Key hi)&#123; Queue&lt;Key&gt; queue=new Queue&lt;Key&gt;(); keys(root,queue,lo,hi); return queue; &#125; private void keys(Node x,Queue&lt;Key&gt; queue,Key lo,Key hi)&#123; if(x==null)&#123; return; &#125; int cmplo=lo.compareTo(x.key); int cmphi=hi.compareTo(x.key); if(cmplo&lt;=0 &amp;&amp; cmphi&gt;=0)&#123; queue.enqueue(x.key); &#125; if(cmphi&gt;0)&#123; keys(x.right,queue,lo,hi); &#125; if(cmplo&lt;0)&#123; keys(x.left,queue,lo,hi); &#125; &#125;&#125; 二叉查找树实现的符号表的时间复杂度是lgN,最坏情况下为N]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-查找(符号表)]]></title>
    <url>%2F2018%2F09%2F08%2FJava%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE-%E7%AC%A6%E5%8F%B7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[符号表定义定义：符号表是一种存储键值对的数据结构，支持两种操作：插入(put)，将一组新的键值对存入表中;查找(get),根据给定的键值的到对应的值。 一种有序的泛型符号表的API实现的对字符表的操作 字符表的实现无序链表实现无序字符表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 public class SequentialSearchST&lt;Key, Value&gt; &#123; private int n; // number of key-value pairs private Node first; // the linked list of key-value pairs // a helper linked list data type private class Node &#123; private Key key; private Value val; private Node next; public Node(Key key, Value val, Node next) &#123; this.key = key; this.val = val; this.next = next; &#125; &#125; public SequentialSearchST() &#123;&#125; public int size() &#123; return n; &#125; public boolean isEmpty() &#123; return size() == 0; &#125; public boolean contains(Key key) &#123; if (key == null) throw new IllegalArgumentException("argument to contains() is null"); return get(key) != null; &#125; public Value get(Key key) &#123; if (key == null) throw new IllegalArgumentException("argument to get() is null"); for (Node x = first; x != null; x = x.next) &#123; if (key.equals(x.key)) return x.val; &#125; return null; &#125; public void put(Key key, Value val) &#123; if (key == null) throw new IllegalArgumentException("first argument to put() is null"); if (val == null) &#123; delete(key); return; &#125; for (Node x = first; x != null; x = x.next) &#123; if (key.equals(x.key)) &#123; x.val = val; return; &#125; &#125; first = new Node(key, val, first); n++; &#125; /** * Removes the specified key and its associated value from this symbol table * (if the key is in this symbol table). * * @param key the key * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125; */ public void delete(Key key) &#123; if (key == null) throw new IllegalArgumentException("argument to delete() is null"); first = delete(first, key); &#125; // delete key in linked list beginning at Node x // warning: function call stack too large if table is large private Node delete(Node x, Key key) &#123; if (x == null) return null; if (key.equals(x.key)) &#123; n--; return x.next; &#125; x.next = delete(x.next, key); return x; &#125; /** * Returns all keys in the symbol table as an &#123;@code Iterable&#125;. * To iterate over all of the keys in the symbol table named &#123;@code st&#125;, * use the foreach notation: &#123;@code for (Key key : st.keys())&#125;. * * @return all keys in the symbol table */ public Iterable&lt;Key&gt; keys() &#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); for (Node x = first; x != null; x = x.next) queue.enqueue(x.key); return queue; &#125; 基于链表的实现及顺序查找是非常低效的向一个空表中插入N个不同的键需要~N*N/2次比较 基于有序数组的二分查找实现有序字符表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public class BinarySearchST&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123; private Key[] keys; private Value[] vals; private int N=0; //构造方法，初始化 public BinarySearchST(int capacity)&#123; keys=(Key[]) new Comparable[capacity]; vals=(Value[]) new Object[capacity]; &#125; public int size()&#123; return N; &#125; public boolean isEmpty()&#123; return N==0; &#125; public boolean contains(Key key)&#123; if(key==null)&#123; throw new IllegalArgumentException("argument to contains() is null"); &#125; return get(key)!=null; &#125; //二分查找 //迭代法 private int rank(Key key)&#123; int lo=0; int hi=N-1; while(lo&lt;=hi)&#123; int mid=lo+(hi-lo)/2; int cmp=keys[mid].compareTo(key); if(cmp&gt;0)&#123; hi=mid-1; &#125;else if(cmp&lt;0)&#123; lo=mid+1; &#125;else&#123; return mid; &#125; &#125; return lo; &#125; /* 递归法实现二分查找 public int rank(Key key,int lo,int hi)&#123; if(hi&lt;lo)&#123; return lo; &#125; int mid=lo+(hi-lo)/2; int cmd=keys[mid].compareTo(key); if(cmd&gt;0)&#123; return rank(key,lo,mid-1); &#125;else(cmd&lt;0)&#123; return rank(key,mid+1,hi); &#125;else&#123; return mid; &#125; &#125;*/ public Value get(Key key)&#123; if(key==null)&#123; throw new IllegalArgumentException("argument to get() is null"); &#125; if(isEmpty())&#123; return null; &#125; int i=rank(key); if(i&lt;N &amp;&amp; keys[i].compareTo(key)==0)&#123; return vals[i]; &#125;else&#123; return null; &#125; &#125; public void put(Key key,Value val)&#123; if(key==null)&#123; throw new IllegalArgumentException("argument to put() is null"); &#125; if(val==null)&#123; delete(key); return; &#125; int i=rank(key); if(i&lt;N &amp;&amp; keys[i].compareTo(key)==0)&#123; vals[i]=val; return; &#125; for(int j=N;j&gt;i;j--)&#123; keys[j]=keys[j-1]; vals[j]=vals[j-1]; &#125; keys[i]=key; vals[i]=val; N++; &#125; public void delete(Key key)&#123; if(key==null)&#123; throw new IllegalArgumentException("argument to delete() is null"); &#125; if(isEmpty())&#123; return; &#125; int i=rank(key); if(i==N || keys[i].compareTo(key)!=0)&#123; return; &#125; for(int j=i;j&lt;N-1;j++)&#123; keys[j]=keys[j+1]; vals[j]=vals[j+1]; &#125; N--; keys[N]=null; vals[N]=null; &#125; public Key min()&#123; return keys[0]; &#125; public Key max()&#123; return keys[N-1]; &#125; public Key select(int k)&#123; return keys[k]; &#125; public Key ceiling(Key key)&#123; int i=rank(key); return keys[i]; &#125; public Key floor(Key key)&#123; if (key == null) throw new IllegalArgumentException("argument to floor() is null"); int i = rank(key); if (i &lt; N &amp;&amp; key.compareTo(keys[i]) == 0) &#123; return keys[i]; &#125;else&#123; return keys[i-1]; &#125; &#125; public Iterable&lt;Key&gt; keys(Key lo,Key hi)&#123; Queue&lt;Key&gt; queue=new Queue&lt;Key&gt;(); for(int i=rank(lo);i&lt;rank(hi);i++)&#123; queue.enqueue(keys[i]); &#125; if(contains(keys[rank(hi)]))&#123; queue.enqueue(keys[rank(hi)]); &#125; return queue; &#125;&#125; 算法分析： 有序数组二分查找的各个操作的成本: BinarySearchST的算法实现了最优的查找效率~lgN，但是插入操作很慢~N，无法保证高效的查找和插入操作。]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-排序（堆排序）]]></title>
    <url>%2F2018%2F09%2F04%2FJava%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%EF%BC%88%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[堆的定义堆这种数据结构是一种完全二叉树，堆分为最大堆和最小堆 最大堆：二叉树中的任一顶点大于等于它的左右子节点 最小堆：二叉树中的任一顶点小于等于它的左右子节点堆可以用数组来存储表示 优先队列优先队列（Priority Queue）：特殊的队列，取出元素的顺序按照元素的优先权或关键字的大小，不是元素入队的先后顺序。优先队列（堆）的使用场景： 1. 任何时候返回最值元素； 2. 数据太大存不下，要找出一定的最值元素； 3. 合并若干不同来源的已经排序的源（索引优先队列） 优先队列的实现方式： 基于堆的优先队列用堆实现优先队列的方法：注：以下代码存储数据时从数组的下标1开始代码实现：最大堆实现的最大优先队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 public class MaxPQ&lt;T extends Comparable&lt;T&gt;&gt;&#123; private T[] pq; //存队列数据的数组 private int N=0; //最终元素的个数 //构造函数 public MaxPQ(int maxN)&#123; pq=(T[])new Comparable[maxN+1]; &#125; //判断队列是否为空 public boolean isEmpty()&#123; return N==0; &#125; //返回队列元素个数 public int size()&#123; return N; &#125; //插入数据 public void insert(T v)&#123; pq[++N]=v; swim(N); &#125; //删除队列中最大元素并返回最大值 public T delMax()&#123; T max=pq[1]; exch(1,N--); pq[N+1]=null; sink(1); return max; &#125; //上浮 private void swim(int k)&#123; while(k&gt;1 &amp;&amp; less(k/2,k))&#123; exch(k/2,k); k=k/2; &#125; &#125; //下沉 private void sink(int k)&#123; while(2*k&lt;=N)&#123; int t=2*k; if(t&lt;N &amp;&amp; less(t,t+1))&#123; t++; &#125; if(less(k,t))&#123; exch(k,t); &#125;else&#123; break; &#125; k=t; &#125; &#125; private boolean less(int i,int j)&#123; return pq[i].compareTo(pq[j])&lt;0; &#125; private void exch(int i,int j)&#123; T temp=pq[i]; pq[i]=pq[j]; pq[j]=temp; &#125; public static void main(String[] args)&#123; MaxPQ&lt;Integer&gt; p=new MaxPQ&lt;Integer&gt;(10); int n=5; p.insert(88); p.insert(2); p.insert(56); p.insert(3); p.insert(42); while(n&gt;0)&#123; System.out.println(p.delMax()); n--; &#125; &#125;&#125; 代码实现的最主要的功能是实现元素的优先级，快速找到并删除最大元素，插入元素（自动调整）算法分析： 一颗大小为N的完全二叉树的高度为lgN； 含有N个元素的基于堆的优先队列，插入元素需要不超过lgN+1次比较，删除最大元素需要不超过2lgN次比较；最小堆实现的最小优先队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MinPQ&lt;T extends Comparable&lt;T&gt;&gt; &#123; private T[] pq; private int N; public MinPQ(int maxN)&#123; pq=(T[])new Comparable[maxN+1]; &#125; public boolean isEmpty()&#123; return N==0; &#125; public int size()&#123; return N; &#125; public void insert(T v)&#123; pq[++N]=v; swim(N); &#125; private void swim(int k)&#123; while(k&gt;1 &amp;&amp; less(k,k/2))&#123; exch(k,k/2); k=k/2; &#125; &#125; public T deleteMin()&#123; T min=pq[1]; exch(1,N--); sink(1); return min; &#125; private void sink(int k)&#123; while(2*k&lt;N)&#123; int t=2*k; if(t&lt;k &amp;&amp; less(t+1,t))&#123; t++; &#125; if(less(t,k))&#123; exch(t,k); &#125;else&#123; break; &#125; k=t; &#125; &#125; private boolean less(int v,int w)&#123; return pq[v].compareTo(pq[w])&lt;0; &#125; private void exch(int v,int w)&#123; T temp=pq[v]; pq[v]=pq[w]; pq[w]=temp; &#125;&#125; 索引优先队列优先队列的一个缺点是无法直接访问队列中的元素(除了直接找到最大或最小的元素)，对其更新修改。用过建立索引优先队列来实现快速索引。创建两个数组：elements[]用来存储队列中的对象(不需要按连续存储)，pq[]用来存储队列中每个对象在elements[]中的索引。 通过这两个数组建立的映射关系，在构建优先队列的时候，不需要变动elements[]，只需要维护改变pq中的元素即可。当向队列中插入一个新的对象时，在elements中存储该对象，将其索引存储在pq中，并对这个索引值进行上浮操作维护优先队列在操作队列时，如果想更改队列中某个对象，比如像将索引为3的位置改为”b”，那么直接操作elements[3]=”b”，这时需要重新调整维护优先队列，在pq数组中队值为3的元素操作，但是并不知道pq中那个位置的值是3，只能通过顺序遍历查找。为了方便查找pq中的元素，创建一个qp数组，将pq中元素作为索引在qp中存储该元素在pq中的索引。在队列的操作中经常要交换两个元素，交换pq中的两个元素的同事也要交换qp中相应位置的元素。索引最小优先队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class IndexMinPQ&lt;Key extends Comparable&lt;Key&gt;&gt; &#123; private int pq[]; private int qp[]; private Key keys[]; private int maxN; private int N; public IndexMinPQ(int maxN)&#123; this.maxN=maxN; N=0; pq=new int[maxN+1];//这些数组中0索引处不存储值 qp=new int[maxN+1]; keys=(Key[])new Comparable[maxN]; for(int i=0;i&lt;=maxN;i++)&#123; qp[i]=-1; &#125; &#125; public boolean isEmpty()&#123; return N==0; &#125; public int size()&#123; return N; &#125; public boolean contains(int i)&#123; //这里的i检查的是keys在索引i处是否有值 if(i&lt;0 || i&gt;maxN)&#123; throw new IllegalArgumentException(); &#125; return qp[i]!=-1; &#125; public void insert(int k,Key key)&#123; if ( k&lt; 0 || k&gt; maxN) throw new IllegalArgumentException(); if (contains(k)) throw new IllegalArgumentException("index is already in the priority queue"); keys[k]=key; pq[++N]=k; qp[k]=N; swim(N); &#125; //返回队列中的最小值 public Key minKey()&#123; return keys[pq[1]]; &#125; //删除并返回队列中的最小值 public Key deleteMin()&#123; if (N == 0) throw new NoSuchElementException("Priority queue underflow"); Key min=keys[pq[1]]; pq[1]=pq[N--]; sink(1); return min; &#125; //删除并返回队列中的某个值 public void delete(int k)&#123; if (k &lt; 0 || k &gt; maxN) throw new IllegalArgumentException(); if (!contains(k)) throw new NoSuchElementException("index is not in the priority queue"); int index=qp[k]; pq[index]=pq[N--]; swim(index); sink(index); keys[k]=null; qp[k]=-1; &#125; //改变队列中某个对象的值 public void changeKey(int k,Key key)&#123; if (k &lt; 0 || k &gt; maxN) throw new IllegalArgumentException(); if (!contains(k)) throw new NoSuchElementException("index is not in the priority queue"); keys[k]=key; swim(qp[k]); sink(qp[k]); &#125; //上浮调整 private void swim(int k)&#123; while(k&gt;1)&#123; if(less(k,k/2))&#123; exch(k,k/2); &#125; k=k/2; &#125; &#125; //下沉调整 private void sink(int k)&#123; while(2*k&lt;=N)&#123; int t=2*k; if(t&lt;N &amp;&amp; less(t+1,t))&#123; t=t+1; &#125; if(less(k,t))&#123; exch(k,t); &#125;else&#123; break; &#125; k=t; &#125; &#125; private boolean less(int k,int v)&#123; return keys[pq[k]].compareTo(keys[pq[v]])&lt;0; &#125; private void exch(int k,int v)&#123; int temp=pq[k]; pq[k]=pq[v]; pq[v]=temp; qp[pq[k]]=k; qp[pq[v]]=v; &#125;&#125; 堆排序堆排序分为两个阶段，给定一个无序的数组，首先要做的事构造堆。a.将无需序列构建成一个堆，根据升序降序需求选择最大堆或最小堆;b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端，N–将最大的元素固定,再次调整不在去管它;c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。对于给定的无序构造堆的一个高效方法就是从右向左进行sink下沉操作，不需要管叶子结点（叶子结点已经算作一个有堆，无法进行下沉操作），所以只需要扫描一半的数组元素。示意图：堆排序算法实现：123456789101112131415161718192021222324252627282930313233343536373839 public class HeapSort&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; @Override public void sort(T[] a)&#123; //数组a[0]不存储哨兵，a[0]的值一般用作，从a[1]开始 int N=a.length-1; //构建堆 for(int k=N/2;k&gt;=1;k--)&#123; sink(a,k,N); &#125; //堆排序 while(N&gt;1)&#123; exch(a,1,N--); sink(a,1,N); &#125; &#125; private void sink(T[] a,int k,int N)&#123; while(2*k&lt;=N)&#123; int j=2*k; if(j&lt;N &amp;&amp; less(a[j],a[j+1]))&#123; j++; &#125; if(less(a[k],a[j]))&#123; exch(a,k,j); &#125;else&#123; break; &#125; k=j; &#125; &#125; public static void main(String[] args)&#123; HeapSort&lt;String&gt; b=new HeapSort&lt;String&gt;(); String[] str=&#123;"q","sss","aaa","ccc","qqq","bbb"&#125;; b.sort(str); for(int i=1;i&lt;=str.length-1;i++)&#123; System.out.println(str[i]); &#125; &#125;&#125; 算法分析： 用下沉法构建堆（N个元素）只需少于2N次比较和少于N次的交换； 对N个元素的堆排序，需要少于（2NlgN+2N)次比较，一半次数的交换； 多种算法比较快速排序是最快的通用排序方法因为快速排序内循环指令少，他还能利用缓存（因为总是顺序访问数组），时间复杂度都是~cNlgN,使用三向切分后可能将某些时间复杂度变为线性级的。 Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql]]></title>
    <url>%2F2018%2F09%2F04%2FMysql%2F</url>
    <content type="text"><![CDATA[Mysql基本操作登陆数据库： mysql -u root -p 退出数据库： exit; 数据库操作创建数据库 create database 数据库名; create database 数据库名 character set 字符集（utf8) collate 校对规则; 删除数据库 drop database 数据库名; 查看数据库 show databases -查看所有数据库 show create database 数据库名 -查看创建的数据库的信息 修改数据库 alter database 数据库名 选中使用数据库 use 数据库名 表的操作创建表 create table 表名{ 列名1 数据类型（长度）约束； 列名2 数据类型（长度） 约束； ...... } 数据类型：https://www.cnblogs.com/Caveolae/p/7058890.htmlhttps://www.cnblogs.com/-xlp/p/8617760.html 约束：主键：primary key （唯一，一个表只有一个主键） 第一种–单一主键：id int primary key（列级）第二种–复合主键：primary key（id，name）设置多个主键（表级）在主键中设置自增：id int primary key auto_increment 外键：foreign key （一个表可以有多个外键） foreign key(外键） references 另一个表名（要关联的键）给外键起名：constraint dpt_fk foreign key(外键名） conferences 表名（关联的键） 默认值：default 非空：not null age int not null; 唯一约束：unique 第一种：email varchar(32) unique （列级）第二种：unique（id，email） —组合约束 （表级）第三种：constraint 约束名 unique（email） —约束起名字（表级） 操作表表重命名： rename table old to new； 删除表： drop table 表名； 增加列： alter table 表名 add 列名 数据类型 约束 after 列名; 可以指定新增列的位置 删除列： alter table 表名 drop 列名; 修改列： alter table 表名 modify 列名 数据类型 约束 改变表中数据 插入数据 insert into 表名(列1，列2，...) values(值1，值2...) or insert into 表名(列1，2...) values(值1，值2...),(v1,v2..),(v1,v2...)... 修改数据： update 表名 set 列1=值1，列2=值2 where 条件 删除数据： delete from 表名 where 条件 查询select语句 select * from 表名; select 列1，列2，... from 表名; select c1,c2,... from 表名 as 另一名; select c1 as p1,c2 as p2,... from 表名; select distinct c from 表名; ---去掉重复值 运算查询： select *,列的运算 as 名 from 表名; 条件查询： where 条件 select 查询内容 from 表名 where 条件 关系运算符 逻辑运算符 模糊查询 like where c like &apos;条件&apos; -：代表单个字符 %：代表多个字符 范围查询 in where c in (a1,a2,a3...) 排序查询： order by c asc/desc asc:ascend 升序 desc:descend 降序 聚合函数： select sum(number) from 表名; sum() avg() count() max() min() 分组： group by having:在group后，可以接聚合函数 where:在group之前，不可以接聚合函数 select ... from ... where ... group by ... having ... order by ...]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-排序（简单排序）]]></title>
    <url>%2F2018%2F08%2F20%2FJava%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[算法模板Comparable接口 Interface Comparable&lt;T&gt; 该接口对实现它的每个类的对象强加一个整体排序，这个排序被称为类的自然排序，类的compareTo方法被称为其自然比较方法 **int compareTo(T o)** 将此对象与指定的对象进行比较以进行排序 返回一个负整数，零或正整数，因为该对象小于，等于或大于指定对象 compareTo() 必须实现一个完整的比较序列，即： 自反性，对于所有的 v ， v=v ； 反对称性，对于所有的 v&lt;w 都有 v&gt;w ，且 v=w 时 w=v ； 传递性，对于所有的 v 、 w 和 x ，如果 v&lt;=w 且 w&lt;=x ，则 v&lt;=x 。 算法模板： 1234567891011121314151617181920212223242526272829public abstract class Sort&lt;T extends Comparable&lt;T&gt;&gt;&#123; public static void sort(T[] a)&#123; &#125; //比较数据大小 protected static boolean less (Tv,T w)&#123; return v.compareTo(w)&lt;0; &#125; //交换数据 protected static void exch(T[] a,int i,int j)&#123; T temp=a[i]; a[i]=a[j]; a[j]=temp; &#125; //输出显示排序好的数据 protected static void show(T[] a)&#123; for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]+" "); &#125; System.out.println(); &#125; //判断是否排序 public static boolean isSorted(T[] a)&#123; for(int i=1;i&lt;a.length;i++)&#123; if(less(a[i],a[i-1])) return false; &#125; return true; &#125;&#125; 注意：只要是实现了Comparable（自己定义的数据类型要重写compareTo方法）的数据类型都可以用次模板排序 选择排序12345678910111213public class Selection&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; @Override public static void sort(T[] a)&#123; int N=a.length; for(int i=0;i&lt;N;i++)&#123; int min=i; for(int j=i+1;j&lt;N;j++)&#123; if(less(a[j],a[min])) min=j; &#125; exch(a,i,min); &#125; &#125;&#125; 选择排序： 首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。 算法分析： 选择排序的效率取决于交换的次数：对于长度为 N 的数组，选择排序需要大约 N 2 /2 次比较和 N 次交换时间复杂度 T(N)=O(N*N); 运行时间和输入无关:已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间一样长 数据移动是最少的:选择排序用了 N 次交换,交换次数和数组的大小是线性关系 冒泡排序冒泡排序：从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。在一轮循环中，如果没有发生交换，就说明数组已经是有序的，此时可以直接退出。 12345678910111213141516public class Bubble&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; @Override public static void sort(T[] a)&#123; int N=a.length; boolean flag=false; for(int i=N-1;i&gt;0 &amp;&amp; !flag;i--)&#123; flag=true; for(int j=0;j&lt;i;j++)&#123; if(less(a[j+1],a[j]))&#123; exch(a,j,j+1); flag=false; &#125; &#125; &#125; &#125;&#125;``` 插入排序12345678910public class Insertion&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; public static &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] a)&#123; int N=a.length; for(int i=1;i&lt;N;i++)&#123; for(int j=i;j&gt;0 &amp;&amp; less(a[j],a[j-1]);j--)&#123; exch(a,j,j-1); &#125; &#125; &#125;&#125; 算法分析： 对于随机排列的长度为 N 且主键不重复的数组，平均情况下插入排序需要～ N 2 /4 次比较以及～ N 2 /4 次交换。最坏情况下需要～ N 2 /2 次比较和～ N 2 /2 次交换，最好情况下需要 N-1次比较和 0 次交换时间复杂度 T(N)=O(N*N) 插入排序所需的时间取决于输入中元素的初始顺序 插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一 插入排序对于实际应用中常见的某些类型的非随机数组很有效插入排序对于部分有序的数组十分高效，也很适合小规模数组 比较：对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数 希尔排序希尔排序：对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。 1234567891011121314151617public class Shell&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; public static &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] a)&#123; int N=a.length; int h=1; while(h&lt;N/3)&#123; h=h*3+1; &#125; while(h&gt;=1)&#123; for(int i=h;i&lt;N;i++)&#123; for(int j=i;j&gt;0 &amp;&amp; less(a[j],a[j-h]);j-=h)&#123; exch(a,j,j-h); &#125; &#125; h=h/3; &#125; &#125;&#125; 算法的性能不仅取决于 h，还取决于 h 之间的数学性质 目前最重要的结论是希尔排序的运行时间达不到平方级别 希尔排序比插入排序和选择排序要快得多，并且数组越大，优势越大 MergeSort(归并排序)In-place merge(原地归并)1234567891011121314151617181920public class Merge&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; protected T[] aux; protected void merge(T[] a,int lo,int mid,int hi)&#123; int i=lo; //左边数组的起始位置 int j=mid+1; ////右边数组的起始位置 for(int k=lo;k&lt;=hi;k++)&#123; aux[k] =a[k]; &#125; for(int k=lo;k&lt;=hi;k++)&#123; if(i&gt;mid)&#123; a[k]=aux[j++]; //左边的子数组用尽 &#125;else if(j&gt;hi)&#123; a[k]=aux[i++]; //右边的子数组用尽 &#125;else if(less(aux[j],aux[i]))&#123; a[k]=aux[j++]; &#125;else&#123; a[k]=aux[i++]; &#125; &#125; &#125; This method merges by first copying into the auxiliary array aux[] then merging back to a[]. In the merge (the second for loop), there are four conditions: left half exhausted (take from the right), right half exhausted (take from the left), current key on right less than current key on left (take from the right), current key on right greater than or equal to current key on left (take from the left). Top-down mergesort(自顶向下的归并排序)123456789101112131415public class UptoDpwnMergeSort&lt;T extends Comparable&lt;T&gt;&gt; extends Merge&#123; public void sort(T[] a)&#123; aux=(T[]) new Comparable[a.length]; sort(a,0,a.length-1); &#125; private void sort(T[] a,int lo,int hi)&#123; if(hi&lt;=lo)&#123; return; &#125; int mid=lo+(hi-lo)/2; sort(a,0,mid); sort(a,mid+1,hi); merge(a,lo,mid,hi); &#125;&#125; A: The code is a recursive(递归) mergesort implementation based on this abstract inplace merge. B: It is one of the best-known examples of the utility of the divide-and-conquer(分而治之) paradigm for efficient algorithm design C: the sort code simply provides an organized way to sequence the calls to the merge() method 算法分析： A: Top-down mergesort uses between ½ N lg N and N lg N compares to sort any array of length N时间复杂度：T(N)=O(N lg N) B: Top-down mergesort uses at most 6N lg N array accesses to sort an array of length N Bottom-up mergesort(自底向上的排序)1234567891011public class BottomtoUpMergeSort&lt;T extends Comparable&lt;T&gt;&gt; extends Merge&lt;T&gt; &#123; public void sort(T[] a)&#123; int N=a.length; aux = (T[]) new Comparable[a.length]; for(int sz=1;sz&lt;N;sz=sz+sz)&#123; for(int lo=0;lo&lt;N-sz;lo+=sz+sz)&#123; merge(a,lo,lo+sz-1,Math.min(lo+sz+sz-1, N-1)); &#125; &#125; &#125;&#125; 算法分析：Bottom-up mergesort uses between ½ N lg N and N lg N compares and at most 6N lg N array accesses to sort an array of length N. both the number of compares usedby mergesort in the worst case and the minimum number of compares that any compare-basedsorting algorithm can guarantee are ~N lg N 归并排序在最坏的情况下的比较次数和任意基于比较的排序算法所需的最少比较次数都是~ NlgN]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-排序（快速排序）]]></title>
    <url>%2F2018%2F08%2F18%2FJava%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%EF%BC%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[QuickSort（快速排序）The basic algorithm（基本算法）归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Quick&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; public void sort(T[] a)&#123; shuffe(a); //消除对输入的依赖 sort(a,0,a.length-1); &#125; private void sort(T[] a, int lo, int hi) &#123; if(hi&lt;=lo)&#123; return; &#125; int j=partition(a,lo,hi); //切分 sort(a,lo,j-1); //将左半边排序 sort(a,j+1,hi); //将右半边排序 &#125; //切分方法 private int partition(T[] a, int lo, int hi) &#123; int i=lo; int j=hi+1; T v=a[lo]; //选取lo处的元素作为分界元素 while(true)&#123; //从左向右扫描找到比v大的元素 while(less(a[++i],v))&#123; if(i==hi)&#123; break; &#125; &#125; //从右向左扫描找到比v小的元素 while(less(v,a[--j]))&#123; if(j==lo)&#123; break; &#125; &#125; if(i&gt;=j)&#123; break; &#125; exch(a,i,j);y &#125; exch(a,lo,j); return j; &#125; //打乱数组 private void shuffe(T[] a)&#123; List&lt;T&gt; list=Arrays.asList(a); Collections.shuffle(list); list.toArray(a); &#125;&#125; Performance characteristics（性能分析）A: advantagea: it is in-place (uses only a small auxiliary stack) (原地排序)b: it requires time proportional to N log N on the average to sort an array of length N (时间复杂度T(N)=O(NlgN))c: the inner loop of quicksort (in the partitioning method) increments an index and compares an array entry against a fixed value.(内循环短小) B: The best case for quicksort is when each partitioning stage divides the array exactlyin half. This circumstance would make the number of compares used by quicksort satisfy the divide-and-conquer recurrence CN = 2CN/2 + N，this recurrence has the solution CN ~ N lg N C: Quicksort uses ~ 2N ln N compares (and one-sixth that many exchanges)on the average to sort an array of length N with distinct keys. D: Quicksort uses ~ N * N/2 compares in the worst case, but random shuffling protects against this case.(最坏情况) Algorithmic improvements(算法改进)Cutoff to insertion sort (切换到插入排序)对小数组排序时插入排序的效率比快速排序的效率高，以为快速排序递归在小数组中调用自己耗费时间改进方法：将 if(hi&lt;=lo) return; 改为 if(hi&lt;=lo+M){ Insertion(a,lo,hi); return; } The optimum value of the cutoff M is system-dependent, but any value between 5 and 15 is likely to work well in most situations 这种方法主要用于提高对小型数组排序的速度问题 Median-of-three partitioning（三取样切分）Entropy-optimal sorting（三向切分的快速排序）这种算法是为了提高有大量重复元素的数组的排序效率，通过选定特定的切分元素v将数组切分为三个部分，小于v的元素、大于v的元素和小于v的元素123456789101112131415161718192021222324252627282930313233public class Quick3way&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; @Override public void sort(T[] a)&#123; shuffe(a); sort(a,0,a.length-1); &#125; private void sort(T[]a,int lo,int hi)&#123; if(hi&lt;=lo)&#123; return; &#125; int lt=lo; int i=lo+1; int gt=hi; T v=a[lo]; while(i&lt;=gt)&#123; int tep=a[i].compareTo(v); if(tep&lt;0)&#123; exch(a,i++,lt++); &#125;else if(tep&gt;0)&#123; exch(a,i,gt--); &#125;else&#123; i++; &#125; &#125; sort(a,lo,lt-1); sort(a,gt+1,hi); &#125; private void shuffe(T[] a)&#123; List&lt;T&gt; list=Arrays.asList(a); Collections.shuffle(list); list.toArray(a); &#125;&#125; 算法分析： 对于包含大量重复元素的数组，三向切分的快速算法比标准的快速算法效率高的多，排序时间从线性对数级降低到了线性级别。对于一个数组，它的所有主键的香农信息量 H=-(p1lgp1+p2lgp2 +…+pnlgpn) 大小为N的数组，三向切分需要~（2ln2)NH次比较 三向切分最坏的情况是当所有的主键不重复时，H=lgN，时间复杂度为NlgN，是线性对数级别的；一般情况下，三向切分的运行时间和输入的信息量的N倍成正比，是线性级别的。]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-基本数据结构]]></title>
    <url>%2F2018%2F08%2F18%2FJava%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基本数据结构数组链表链表的节点表示1234public class Node&lt;Item&gt;&#123; Item item; Node next; &#125; 栈用链表实现栈 public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt;{ //栈顶指针 private Node first; //栈中元素数量 private int N; //定义节点 private class Node{ Item item; Node next; } //判断栈是否为空 public boolean isEmpty(){ return first==null; } //返回栈中元素数量 public int size(){ return N; } //压栈 public void push(Item item){ Node oldfirst=first; first=new Node(); first.item=item; first.next=oldfirst; N++; } //出栈 public Item pop(){ if(isEmpty()){ try { throw new Exception("stack is empty"); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } } Item item=first.item; first=first.next; N--; return item; } public Iterator&lt;Item&gt; iterator(){ return new Iterator&lt;Item&gt;(){ private Node current=first; @Override public boolean hasNext(){ return current!=null; } @Override public Item next(){ Item item=current.item; current=current.next; return item; } public void remove(){} }; } } 队列用链表实现队列 public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt; { private Node first; private Node last; private int N; private class Node{ Item item; Node next; } //判断队列是否为空 public boolean isEmpty(){ return N==0; } //返回队列中元素个数 public int size(){ return N; } //入队 public void enqueue(Item item){ Node oldlast=last; last=new Node(); last.item=item; last.next=null; if(isEmpty()){ first=last; }else{ oldlast.next=last; } N++; } //出队 public Item dequeue(){ if(isEmpty()){ try { throw new Exception("queue is empty"); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } } Item item=first.item; first=first.next; N--; if(isEmpty()){ last=null; } return item; } public Iterator&lt;Item&gt; iterator(){ return new Iterator&lt;Item&gt;(){ private Node current=first; @Override public boolean hasNext(){ return current!=null; } @Override public Item next(){ Item item=current.item; current=current.next; return item; } public void remove(){} }; } }]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-集合（容器）]]></title>
    <url>%2F2018%2F08%2F17%2FJava-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Collection public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; Collection接口的常用方法 添加功能 boolean add(E e) boolean addAll(Collection&lt;? extends E&gt; c) 添加一个集合的元素 删除功能 void clear() 从此集合中删除所有元素 boolean remove(Object o) boolean removeAll(Collection&lt;?&gt; c) 删除指定集合中包含的所有此集合的元素 判断功能 boolean contains(Object o) 如果此集合包含指定的元素，则返回true boolean containsAll(Collection&lt;?&gt; c) 如果此集合包含指定 集合中的所有元素，则返回true boolean isEmpty() 如果此集合不包含元素，则返回 true 长度功能 int size() 返回此集合中的元素数 交集功能 boolean retainAll(Collection&lt;?&gt; c) 两个集合都有的元素 a.retainAll(b) a和b做交集，结果保存在a中，b不变，返回的boolean值表示a是否发生变化 一、List public interface List&lt;E&gt; extends Collection&lt;E&gt; List-有序集合（存储和取出的元素一致）（也称为序列 ），可以精确控制列表中每个元素的插入位置，通过整数索引（列表中的位置）访问元素，并搜索列表中的元素，列表通常允许重复的元素 List的特有方法 void add(int index,E element) 将指定的元素插入此列表中的指定位置 E get(int index) 返回此列表中指定位置的元素 ListIterator&lt;E&gt; listIterator() 返回列表中的列表迭代器（按适当的顺序） E remove(int index) 删除该列表中指定位置的元素 E set(int index, E element) 用指定的元素替换此列表中指定位置的元素 List的类型分类各类型特点对比： ArrarList：底层数据结构是数组，查询快，增删慢 线程不安全，效率高 Vector： 底层数据结构是数组，查询快，增删慢 线程安全，效率低 LinkedList：低层数据结构是链表，查询慢（只能顺序访问），增删快 线程不安全，效率高 LinkedList还可以用作栈、队列、双向队列 LinkedListLinkedList的基本方法： public void addFirst(E e) 在列表的头部插入元素 public void addLast(E e) 在列表尾部插入元素 public E getFirst() 返回此列表中的第一个元素。 public E getLast() 返回此列表中的最后一个元素 public E removeFirst() 从此列表中删除并返回第一个元素 public E removeLast() 从此列表中删除并返回最后一个元素 二、迭代器 迭代器是一种对象，它的功能是遍历并选择序列中的对象。 Iterator迭代器Collection 实现了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。 Collection获取迭代器的方法： Iterator&lt;E&gt; iterator() 返回此集合中的元素的迭代器 Iterator接口的常用方法： boolean hasNext() 判断集合里是否有元素 E next() 获取元素并移动到下一个元素 集合的使用步骤： A:创建集合对象 Collection c = new ArrayList(); B:创建元素对象 Object obj=..... C：元素添加到集合 c.add(obj) D：遍历集合元素 a:用过集合获取迭代器对象 Iterator it = c.iterator() b:通过迭代器对象的hasNext()方法判断是否有元素 boolean flag = it.hasNext() c:通过迭代器next()方法获取元素 Object obje = it.next() 集合的遍历（以List类型为例，Set同理）第一种：迭代器遍历 //部分伪代码，E代表某种类型 List&lt;E&gt; list=new List&lt;E&gt;(); list.add(E a); list.add(E b); //假设list里已经添加多个E类型的对象，可以遍历 Iterator it=list.iterator(); while(it.hasNext()){ E e=it.next(); print(e); } 第二种：foreach方法（增强for循环） List&lt;E&gt; list=new List&lt;E&gt;(); list.add(E a); list.add(E b); ....... for(E e:list){ print(e); } ------------------- List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); for (String item : list) { System.out.println(item); } ListIteratorListIterator是Iterator的子类，只用于List类集合，Iterator只能单向移动，而ListIterator可以双向移动主要方法： 继承了Iterator的功能（hasNext(),next()) boolean hasPrevious() 返回true如果遍历反向列表，列表迭代器有多个元素 E previous() 返回列表中的上一个元素，并向后移动光标位置 int nextIndex() 返回由后续调用返回的元素的索引next() int previousIndex() 返回由后续调用previous()返回的元素的索引 三、Set与List集合不同的是，Set集合不保存重复的元素 TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素&gt;的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1),TreeSet 则为 O(logN) HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的 LinkedHashSet：具有 HashSet的查找效率，且内部使用双向链表维护元素的插入顺序 HashSet提供最快的查询速度，TreeSet保持元素处于排序状态，LinkedHashSet以插入顺序保存元素 HashSet保证集合元素唯一性的原理： 主要取决于HashSet的add()方法， add()方法中主要依赖于String.hashCode()和String.equals()方法, 定义类时应该重写这两个方法 TreeSet（排序，唯一不重复）: 基于TreeMap实现，使用元素的自然顺序对元素进行排序，或者使用set提供的comparator方法排序， 具体使用时取决于使用的构造方法 A:自然排序：真正依赖于compareTo()方法， 这个方法定义在Comparable中，所以想重写该方法，就要实现Comparable接口，这个接口表示自然排序 例如：定义学生类时实现Comparable接口 public class Student implements Comparable&lt;T&gt;{ @override public int compareTo(T t){ .......... 主要条件 次要条件 } } B:比较器排序:comparator方法, TreeSet的add()方法，是基于TreeMap方法的put()方法 public TreeSet(Comparator&lt;? super E&gt; comparator ) 构造一个新的，空的树集，根据指定的比较器进行排序 TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;(){ public int compare(Student s1,Student s2){ ........... } };) Mappublic interface Map&lt;K,V&gt; Map将键映射到值的对象。 地图不能包含重复的键; 每个键可以映射到最多一个值 Map的基本类型 TreeMap：基于红黑树实现，保证唯一性和排序 HashMap：基于哈希表实现 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。ConcurrentHashMap：现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序HashMap用来快速访问，TreeMap保持键排序，LinkedHashMap保持元素插入的顺序，也通过散列提供快速访问能力 Map基本方法功能 添加 V put(K key,V value) 将指定的值与该映射中的指定键相关联 如果键是第一次存储，直接存储元素，返回null； 如果不是第一次添加键值，就用新的值替换旧的值，并返回旧的值。 删除 void clear() 从该地图中删除所有的映射 V remove(Object key) 删除并返回 删除集合里存在的键，返回建的值，如果不存在返回null 判断 boolean containsKey(Object key) 如果此映射包含指定键的映射，则返回true boolean containsValue(Object value) 如果此映射将一个或多个键映射到指定的值，则返回true boolean isEmpty() 判断集合是否为空 获取 V get(Object key) 返回到指定键所映射的值 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此地图中包含的映射的Set视图 Set&lt;K&gt; keySet() 返回此地图中包含的键的Set视图 Collection&lt;V&gt; values() 返回此地图中包含的值的Collection视图 长度 int size() 返回此地图中键值映射的数量 Map集合的遍历 //创建集合 Map&lt;String,String&gt; map=new Map&lt;String,String&gt;(); //添加数据 map.put(&quot;德国&quot;,&quot;克罗斯&quot;); map.put(&quot;法国&quot;,&quot;格列兹曼&quot;); map.put(&quot;比利时&quot;,&quot;德布劳内&quot;); 方式一： //获取键值集合 Set&lt;String&gt; set=map.keySet(); for(String s:set){ v=map.get(s); System.out.println(s+&quot;---&gt;&quot;+v); } 方式二： //获取映射Set集合 Set&lt;Map.Entry&lt;String,String&gt; set=map.entrySet(); for(Map.Entry&lt;String,String&gt; m:set){ key=m.getKey(); value=m.getValue(); System.out.println(key+&quot;---&gt;&quot;+value); }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想-面向对象（基础）]]></title>
    <url>%2F2018%2F08%2F16%2FJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、关键字this关键字this关键字在方法内部使用，表示对“调用方法的那个对象”的引用，如果在方法内调用同一个类的另一个方法可以不使用this super关键字 this &amp;&amp; super A:this本类的引用，super代表父类存储空间的标识（看成对父类的引用） B:this.变量 ，super.变量 -----引用变量 this(.....) ，uper(.....) -----调用构造方法 this.成员方法 ，super.成员方法 -----调用成员方法 static关键字static的特点：1.类中static关键字修饰的变量（静态变量）被类的所有对象共享 class Static{ static int i=47; } 即使创建多个对象也共享同一个变量i： Static st1=new Static(); Static st2=new Static(); st1.i和st2.i指向同一个存储空间地址，有相同的值，也可以通过Static.i引用变量 2.类中static修饰的方法可以在不创建方法的前提下直接调用static修饰的方法不与包含它的类的任何对象关联在一起，不用创建对象通过类本身调用，这是static方法的主要用途 class Static{ public static void increment(){ Static.i++; } } 定义了一个静态方法，通过类直接调用：Static.increment() 3.静态是随着类的加载而加载,与对象无关 4.static方法没有this关键字 5.static方法不能调用非静态方法，反过来可以 6.所有构造方法都默认被static修饰 final关键字1.修饰数据声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量 final修饰基本类型（整型，浮点，字符等），表示一个常量，赋值后不可以改变 final修饰引用类型（类，接口，数组），final使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的 2.修饰方法 final修饰的方法不能被重写（private方法也不可重写） private方法隐式地被指定为final，如果在子类中定义的方法和基类中的一个private方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法 3.修饰类 final修饰的类不可以被继承 成员变量和局部变量 局部变量：在方法外---在栈内存 （变量没有默认初始值）---随之对象的创建产生，随着对象的消失 成员变量： 在方法内---在堆内存 （变量有默认初始值）--随着方法的调用产生 二、继承 java中继承的特点： A: 只支持单继承，不支持多继承 B: 支持多层继承 class A{} class B extends A{} class C extends B{} 注意事项 A:子类只能继承父类中非私有的成员（成员变量和成员方法） B:子类不能继承父类的构造方法，但可以通过super关键字去访问父类构造方法 1.访问权限包访问权限（friendly） ：默认的访问权限通常是包访问权限，当前包中所有其他类可以访问那个成员，对于这个包之外的所有类是privatepublic：公共的，谁都可以访问protected：继承访问权限private：私有的，除了包含该成员的类之外其他类无法访问！注意：a.类不可以用private，protected修饰，只可以是包访问权限和publicb.如果类的构造方法由private修饰，则无法创建该类的对象，从而禁止拥有该类的访问权限，但是任然可以调用访问该类中static修饰的成员 2.类间的关系组合 class Actor{ public void act() {} } class HappyActor{ public void act(){ print(&quot;HappyActor&quot;); } class SadActor{ public void act(){ print(&quot;SadActor&quot;); } } class Stage{ privat Actor actor=new HappyActor(); public void change(){ actor=new SadActor(); } public void perform(){ actor.act(); } } 继承代理 3.重写和重载 重写（Override） 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。 为了满足里式替换原则，重写有有以下两个限制： 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型。 使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。 重载（Overload） 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。 应该注意的是，返回值不同，其它都相同不算是重载。 三、多态1.多态的前提要有继承关系，要有方法重写，要有父类引用指向子类对象（父类 F = new 子类()) class fu{ public fu(){ } public void show(){ System.out.println(&quot;fu&quot;); } } class zi extends fu{ public void show(){ System.out.println(&quot;show zi&quot;); } public void method(){ Sysltem.out.println(&quot;method zi&quot;); } } class DuotaiDemo{ public static void main(String[] args){ fu f = new zi(); f.show(); } } 2.多态中成员访问特点 A:成员变量—编译看左边，运行看左边 B:构造方法—创建子类对象时，访问父类的构造方法，对父类的数据进行初始化 C:成员方法—编译看左边，运行看右边（因为有成员方法重写，所以调用子类） D:静态方法—编译看左边，运行看左边（静态只和类有关） 多态好处 ：提高了代码的维护性（继承）、扩展性（多态）弊端 ：不能使用子类的特有功能 对象间的转型:向下转型 父-&gt;子 zi z = (zi)f向上转型 子-&gt;父 fu f = new zi() 四、接口1.抽象类和抽象方法抽象类和抽象方法必须用abstract修饰 格式： abstract class 类名 {} public abstract void 方法名(); 特点： 抽样类中不一定有抽样方法，但是有抽样方法的类一定要定义成抽类 抽样类不能实例化，抽象类有构造方法，但不可以实例化，构造方法是给子类调用的 抽象类的子类：如果不想重写抽样方法，子类是一个抽样类，如果想重写抽样方法，子类是一个具体的类 成员特点： 成员变量：既可以是常量，也可以是变量 构造方法：有，用于子类访问父类数据初始化 成员方法：既可以是抽象的，也可以是非抽象的，成员方法是抽象的，子类必须得重写，成员方法是非抽象的，子类继承 2.接口interface产生一个完全抽象的类，此类没有提供任何相应的具体实现，它允许确定方法名、参数列表、和返回类型，但是没有任何方法体。 接口只提供了形式，而未提供任何具体实现 接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected 接口的字段默认都是 static 和 final 的 A.接口成员特点：成员变量：只能是常量，是静态的，默认修饰符 public static final构造方法：没有（所有类都默认继承object类）成员方法：只能是抽象方法，默认修饰符public B.比较 从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 C.使用选择 使用接口：a.需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；b.需要使用多重继承；c.创建不带任何方法定义和成员变量的基类； 使用抽象类：a.需要在几个相关的类中共享代码；b.需要能控制继承来的成员的访问权限，而不是都为 public；c.需要继承非静态和非常量字段； 在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低 D.关系类和类：继承关系，只能单继承，多层继承类和接口：实现关系，可以单实现也可以多实现，可以在继承一个类的同时实现多个接口接口和接口：继承关系，可以单继承，也可多继承 五、内部类匿名内部类内部类的简写前提：存在一个类和接口类名或接口 格式： new名 () { 方法重写; };本质是一个继承了该类或实现了接口的子类匿名对象 六、字符串String主要方法构造方法 public String() 空构造 public String(byte[] bytes) 把字节数组转换成字符串 public String(byte[] bytes,int offset,int length) 把字节数组一部分转换成字符串 public String(char[] value) 把字符数组转换成字符串 public String(char[] value,int offset,int count) 把字符数组一部分转换成字符串 public String(String original) eg. String s = new String(参数) 成员方法 **判断功能** public boolean equals(Object anObject) 比较字符串的内容是否相同 public boolean equalsIgnoreCase(String str) 比较字符串的内容是否相同，忽略大小写 public boolean contens(String str) 大的字符串是否包含小串 public boolean startsWith(String str) 判断字符串是否以某个特定的字符串开头 public boolean endsWith(String str) 判断字符串是否以某个特定的字符串结尾 public boolean isEmpty() 判断字符串是否为空 **获取功能** public int length() 获取字符串长度 public char charAt(int index) 返回索引处的字符 public int indexOf(int ch) 返回指定字符第一次出现的字符串内的索引 public int indexOf(String str) 返回指定子字符串第一次出现的字符串内的索引。 public int indexOf(int ch,int fromIndex) 返回指定字符第一次出现的字符串内的索引，以指定的索引开始搜索 public int indexOf(String str,int fromIndex) 返回指定子串的第一次出现的字符串中的索引，从指定的索引开始 public String substring(int beginIndex) 返回一个字符串，该字符串是此字符串的子字符串。 子字符串以指定索引处的字符开头，并扩展到该字符串的末尾 public String substring(int beginIndex,int endIndex) 返回一个字符串，该字符串是此字符串的子字符串，子串开始于指定beginIndex并延伸到字符索引endIndex - 1 **转换功能** public byte[] getBytes() 把字符串换换为字节数组 public toCharArray() 把字符串转换为字符数组 public static String valueof(char[] chs) 字符数组转化成字符串 public static String valueof(int i) 把int转化成字符串 public String toLowerCase() 字符串变小写 public String toUpperCase() 字符串变小写 public String concat(String str) 字符串拼接 **替换功能** public String replace(char old,char new); public String replace(String old,String new); **去除字符串开头结尾两个空格** public String trim(); **按字典顺序比较两个字符串** public int compareTo(String str); public int compareToIgnorceCase(String str); String, StringBuffer and StringBuilder 可变性String 不可变StringBuffer 和 StringBuilder 可变 线程安全String 不可变，因此是线程安全的StringBuilder 不是线程安全的StringBuffer 是线程安全的，内部使用 synchronized 进行同步 类型转换String和StringBuffer相互转换 String s = new String() A:StringBuffer sb = new StringBuffer(s) B:StringBuffer sd2 = new StringBuffer() sb2.append(s) StringBuffer sb = new Stringbuffer(&quot;java&quot;) A:String str = new String(sb) B:String str2 = sb.toString() String和int int a=100; String s2=String.valueOf(a); System.out.println(s2); String s =&quot;100&quot;; int y=Integer.parseInt(s); System.out.println(y);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-网络编程]]></title>
    <url>%2F2018%2F08%2F11%2FJava-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[网络编程的三要素IP地址 概念：IP地址是网络中计算机的唯一标识 IP的组成：网络号+主机号 java提供了InetAddress类来对IP地址解析和操作 确定主机名称的IP地址public static InetAddress getByName(String host)获取此IP地址的主机名 public String getHostName() 端口 端口是正在运行程序的标识 协议 UDP 将数据源和目的地封装在数据包中，无连接，是不可靠协议，不需要建立连接，速度快 TCP 建立连接，形成传输数据的通道，在连接中进行大数据量的传输，通过三次握手完成连接，是可靠地，效率会低 Socket网络编程Socket包含了IP地址和端口号Socket原理机制：通信的两端都有Socket，网络通信其实是Socket间的通信，数据在两个Socket间通过IO传输 UDP UDP使用DatagramSocket类用于发送和接收数据报数据包 构造方法：public DatagramSocket()—发送数据使用的构造方法public DatagramSocket(int port)—接收数据使用的构造方法主要成员方法：public void close()关闭此数据报套接字public void send(DatagramPacket p)从此套接字发送数据报包public void receive(DatagramPacket p)从此套接字接收数据报包 发送和接收的数据是DatagramPacket类的，该类表示数据报包，send方法中需要传递DatagramPacket对象 构造方法：public DatagramPacket(byte[] buf,int length,InetAddress address,int port)–发送数据使用的构造方法public DatagramPacket(byte[] buf,int length) –接收数据使用的构造方法buf - 分组数据length - 包长度address - 目的地址port - 目的端口号主要成员方法：public byte[] getData()返回数据缓冲区public int getLength()返回要发送的数据的长度或接收到的数据的长度public InetAddress getAddress()返回该数据报发送或接收数据报的计算机的IP地址 UDP协议发送数据 1.创建发送端Socket对象 2.创建数据并打包 3.调用Socket对象的发送方法发送数据 4.释放资源 下面为实现UDP协议发送数据 public class send{ public static void main(String[] args){ //创建发送端Socket DatagramSocket ds=new DatagramSocket(); //创建数据并打包 byte[] bys=&quot;UDP协议发送的数据&quot;.getBytes(); int length=bys.length; //发送数据的目的IP地址 InetAddress address=InetAddress.getByName(&quot;主机名&quot;)； //发送端计算机的端口 int port=10086; DatagramPacket dp=new DatagramPacket(bys,length,address,port); //发送数据 ds.send(dp); //释放资源 ds.close(); } } UDP协议接收数据1.创建接收端Socket2.创建数据包接收数据（接受容器）3.用Socket接受方法接收数据4.解析数据输出5.释放资源 下面为实现UDP协议接收数据 public class Receive { public static void main(String[] args) throws IOException { // TODO Auto-generated method stub //创建接收端Socket DatagramSocket ds=new DatagramSocket(10086); //创建数据包接收 byte[] bys=new byte[1024]; int length=bys.length; DatagramPacket dp=new DatagramPacket(bys,length); //接收数据 ds.receive(dp); //解析数据 InetAddress address=dp.getAddress(); String ip=address.getHostAddress(); byte[] bys2=dp.getData(); int len=dp.getLength(); String s=new String(bys2,0,len); System.out.println(ip+&quot;:&quot;+s); //释放资源 ds.close(); } } TCPTCP协议发送数据 （客户端）1.创建发送端Socket2.获取输出流写数据3.释放资源 TCP发送客户端使用的是Socket类 构造方法：public Socket(InetAddress address,int port)public Socket(String host,int port)主要成员方法：public void close()关闭public OutputStream getOutputStream()返回此套接字的输出流 public class TSend { public static void main(String[] args) throws IOException { //创建Socket Socket s=new Socket(&quot;daw-PC&quot;,10086); //获取输出流写数据 OutputStream os=s.getOutputStream(); os.write(&quot;TCP发送数据&quot;.getBytes()); //释放资源 s.close(); } } TCP协议接收数据（服务器）1.创建接收端Socket2.监听客户端连接，返回对应的Socket对象3.获取输入流读数据4.释放资源 TCP接收客户端使用的是ServeSocket类 构造方法：public ServerSocket(int port)成员方法：public Socket accept()监听 ，返回的是Scoket类，所以需要Socket类的方法Socket类的—public InputStream getInputStream()返回此套接字的输入流 public class TReceive { public static void main(String[] args) throws IOException { //创建接收端Socket ServerSocket ss=new ServerSocket(10086); //监听客户端 Socket s=ss.accept(); //获取输入流写数据 InputStream is=s.getInputStream(); byte[] bys=new byte[1024]; int len=is.read(bys); String str=new String(bys,0,len); System.out.println(str); //释放资源，注意不关闭服务器 s.close(); } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
