<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Chenwang Zheng]]></title>
    <url>%2F2039%2F01%2F21%2FChenwang%20Zheng%2F</url>
    <content type="text"><![CDATA[Welcome to Chenwang Zheng’s Homepage! Personal Information I am currently a graduate student with School of Electronic and Information Engineering, Beijing Jiaotong University, China. My research interests include data mining and recommendation system. Research Chenwang Zheng, Dan Tao. A User Dynamic Preference and Attention Mechanism based POI Recommendation Method [P]. Patent No.201911420233.6]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法-排序算法总结]]></title>
    <url>%2F2020%2F06%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[排序算法总结： 术语说明： 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度： 一个算法执行所耗费的时间； 空间复杂度：运行完一个程序所需内存的大小。 1. 冒泡排序（Bubble Sort）冒泡排序：是一种简单的排序算法，它从左到右不断交换相邻逆序的元素，在一轮遍历后，可以让未排序部分中最大的元素浮到右侧。不多的从左到右调整，直至数组有序。12345678910111213141516 public int[] bubbleSort(int [] input)&#123; if(input.length == 0)&#123; return input; &#125; for(int i=input.length-1; i&gt;0; i--)&#123; for(int j=0; j&lt;i; j++)&#123; if(input[j] &gt; input[j+1])&#123; int temp = input[j]; input[j] = input[j+1]; input[j+1] = temp; &#125; &#125; &#125; return input;&#125; 算法分析 时间复杂度： O(n^2) 空间复杂度： O(1) 2. 选择排序（Selection Sort）选择排序：首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。选择排序是表现最稳定的排序算法之一 ，因为无论什么数据进去都是O(n2)的时间复杂度 ，所以用到它的时候，数据规模越小越好。123456789101112131415161718 public int[] bubbleSort(int [] input)&#123; if(input.length == 0)&#123; return input; &#125; for(int i=0; i&lt;input.length; i++)&#123; int minIndex = i; for(int j=i+1; j&lt;input.length; j++)&#123; if(input[j] &lt; input[minIndex])&#123; minIndex = j; &#125; &#125; int temp = input[i]; input[i] = input[minIndex]; input[minIndex] = temp; &#125; return input;&#125; 算法分析 时间复杂度： O(n^2) 空间复杂度： O(1) 3.插入排序（Insertion Sort）插入排序： 直接插入排序是将无序序列中的数据插入到有序的序列中，在遍历无序序列时，首先拿无序序列中的首元素去与有序序列中的每一个元素比较并插入到合适的位置，一直到无序序列中的所有元素插完为止。对于一个无序序列arr{4，6，8，5，9}来说，我们首先先确定首元素4是有序的，然后在无序序列中向右遍历，6大于4则它插入到4的后面，再继续遍历到8，8大于6则插入到6的后面，这样继续直到得到有序序列{4，5，6，8，9}。插入排序所需的时间取决于输入中元素的初始顺序。插入排序对于实际应用中常见的某些类型的非随机数组很有效。插入排序对于部分有序的数组十分高效，也很适合小规模数组。 12345678910111213141516 public int[] bubbleSort(int [] input)&#123; if(input.length == 0)&#123; return input; &#125; for(int i=1; i&lt;input.length; i++)&#123; int preIndex = i - 1; int current = input[i]; while(preIndex&gt;=0 &amp;&amp; input[preIndex]&gt;current)&#123; input[preIndex+1] = input[preIndex]; preIndex --; &#125; input[preIndex+1] = current; &#125; return input;&#125; 算法分析 时间复杂度: O(n^2) 空间复杂度: O(1) 4. 希尔排序（Shell Sort）希尔排序：对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。希尔排序又叫缩小增量排序。 1234567891011121314151617181920 public int[] bubbleSort(int [] input)&#123; if(input.length == 0)&#123; return input; &#125; int h = input.length / 2; while(h &gt; 0)&#123; for(int i=h; i&lt;input.length; i++)&#123; int preIndex = i - h; int temp = input[i]; while(preIndex&gt;=0 &amp;&amp; input[preIndex]&gt;temp)&#123; input[preIndex+h] = input[preIndex]; preIndex -= h; &#125; input[preIndex + h] = temp; &#125; h /= 2; &#125; return input;&#125; 算法分析希尔排序的运行时间达不到平方级别， 希尔排序比插入排序和选择排序要快得多，并且数组越大，优势越大。 5. 归并排序https://blog.csdn.net/weixin_41190227/article/details/86600821]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-数组问题]]></title>
    <url>%2F2020%2F06%2F07%2F%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 解题思路 哈希法：先遍历一遍数组，利用Map存储每个元素出现的次数，在遍历一次Map，找出众数。 12345678910111213141516171819202122232425262728293031 import java.util.HashMap;import java.util.Set;import java.util.Map;public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; if(array.length==0)&#123; return 0; &#125; int l = (int)(array.length / 2); Map&lt;Integer, Integer&gt; count = new HashMap&lt;&gt; (); for(int i=0; i&lt;array.length; i++)&#123; int num = array[i]; if(count.containsKey(num))&#123; count.put(num, count.get(num)+1); &#125;else&#123; count.put(num, 1); &#125; &#125; Set&lt;Integer&gt; set = count.keySet(); for(Integer k: set)&#123; Integer v = count.get(k); if(v.intValue() &gt; l)&#123; return k.intValue(); &#125; &#125; return 0; &#125;&#125;// 时间复杂度：O(n)// 空间复杂度：O(n) 排序法：先将数组进行排序，众数一定在数组中间，再比遍历数组统计该数出现的次数，进行判断。 1234567891011121314151617181920 import java.util.Arrays;public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; if(array.length==0)&#123; return 0; &#125; Arrays.sort(array); int num = array[array.length / 2]; int count = 0; for(int i=0; i&lt;array.length; i++)&#123; if(array[i] == num)&#123; count ++; &#125; &#125; return count&gt;(array.length / 2)?num:0; &#125;&#125; // 时间复杂度：O(nlogn)// 空间复杂度：O(1) 候选法（最优解):如果两个数不相等，就消去这两个数，最坏情况下，每次消去一个众数和一个非众数，那么如果存在众数，最后留下的数肯定是众数。 12345678910111213141516171819202122232425262728 public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; int num = -1; int cnt = 0; for(int i=0; i&lt;array.length; i++)&#123; if(cnt == 0)&#123; num = array[i]; cnt ++; &#125;else&#123; if(num == array[i])&#123; cnt++; &#125;else&#123; cnt --; &#125; &#125; &#125; cnt = 0; for(int i=0; i&lt;array.length; i++)&#123; if(array[i] == num)&#123; cnt ++; &#125; &#125; return cnt&gt;(array.length/2)?num: 0; &#125;&#125;// 时间复杂度：O(n)// 空间复杂度：O(1)]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-字符串问题]]></title>
    <url>%2F2020%2F06%2F07%2F%E5%89%91%E6%8C%87offer-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[字符串的排列题目描述 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 解题思路利用递归的思想，首先固定第一个字符，将剩余的部分看做一个新的字符串，递归的取得首位后面各种字符串的组合。再第一个字符串与后面的每一个字符串进行交换，同样递归的获得其字符串组合。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 import java.util.ArrayList;import java.util.Collections;// ************使用数组*****************public class Solution &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; ret = new ArrayList&lt;String&gt;(); if(str.length()==0 &amp;&amp; str==null)&#123; return ret; &#125; Permute(str.toCharArray(), 0, ret); Collections.sort(ret); return ret; &#125; public void Permute(char[] str, int i, ArrayList&lt;String&gt; ret)&#123; if(i == str.length - 1)&#123; if(!ret.contains(new String(str)))&#123; ret.add(new String(str)); &#125; &#125;else&#123; for(int j=i; j&lt;str.length; j++)&#123; swap(str, i, j); Permute(str, i+1, ret); swap(str, i, j); &#125; &#125; &#125; public void swap(char[] str, int i, int j)&#123; char temp = str[i]; str[i] = str[j]; str[j] = temp; &#125;&#125; // ************** 使用StringBuffer ************** public class Solution &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; ret = new ArrayList&lt;String&gt;(); if(str.length()==0 &amp;&amp; str==null)&#123; return ret; &#125; Permute(new StringBuffer(str), 0, ret); Collections.sort(ret); return ret; &#125; public void Permute(StringBuffer str, int i, ArrayList&lt;String&gt; ret)&#123; if(i == str.length() - 1)&#123; if(!ret.contains(str.toString()))&#123; ret.add(str.toString()); &#125; &#125;else&#123; for(int j=i; j&lt;str.length(); j++)&#123; swap(str, i, j); Permute(str, i+1, ret); swap(str, i, j); &#125; &#125; &#125; public void swap(StringBuffer str, int i, int j)&#123; char temp = str.charAt(i); str.setCharAt(i, str.charAt(j)); str.setCharAt(j, temp); &#125;&#125; // 算法时间复杂度： O(n!) // 空间复杂度：O(1)]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法-树结构总结]]></title>
    <url>%2F2020%2F06%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[“树”是数据结构中常见的非线性存储结构。在“树”结构中有一些常用的术语，总结为下： 父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点。 子节点：一个节点含有的子树的根节点称为该节点的子节点。 兄弟节点：拥有共同父节点的节点互称为兄弟节点。 度：节点的子树数目就是节点的度。 叶子节点：度为零的节点就是叶子节点。 节点的层次：从根节点开始，根节点为第一层，根的子节点为第二层，以此类推。 节点深度：对任意节点x，x节点的深度表示为根节点到x节点的路径长度。例如：根节点深度为0，第二层节点深度为1，以此类推。 “根节点—&gt;节点的路径长度” 节点高度：对任意节点x，叶子节点到x节点的路径长度就是节点x的高度。 “节点—&gt;叶子节点的路径长度” 树的深度：一棵树中节点的最大深度就是树的深度，也称为高度。 数据结构中有很多种树结构：二叉树，二叉搜索树， 红黑树，B+树等，下面对常见的几种树结构的的定义以及用途进行简单的介绍。 1. 二叉树 二叉树的定义：二叉树的每个结点最多只有二棵子树(不存在度大于2的结点)的树结构。每个节点有左右两个子节点。 二叉树示例： 满二叉树 和 完全二叉树： 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。即除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点都在同一层上。 完全二叉树：对于一颗二叉树，假设其深度为d（d&gt;1）。除第d层外的所有节点构成满二叉树，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树 示例： 二叉树的性质： 在非空二叉树中，第i层的结点总数不超过2i-1, i&gt;=1; 深度为d的二叉树最多有2d-1个结点(d&gt;=1)，最少有d个结点; 具有n个结点的完全二叉树的深度为log2(n+1)； 2. 二叉查找树（二叉搜索树、二叉排序树、BST） 二叉查找树定义:二叉查找树又称二叉搜索树、二叉排序树、BST. 它是具有以下性质的二叉树： 若左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值； 左、右子树也分别为二叉排序树； 没有键值相等的节点。 示例左边的是BST，右边的不是： 对二叉查找树进行中序遍历，即可得到有序的数列。 它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。 二叉查找树的高度决定了二叉查找树的查找效率。 3. 二叉树的操作 二叉树的遍历 二叉树有三种遍历方式： 先序遍历：先访问根节点，再前序遍历左子树，最后前序遍历右子树。 中序遍历：先中序访问左子树，再访问根节点，再中序访问右子树。中序遍历得到一个有序（递增）的数列。 后序遍历：先后序访问左子树，再后序访问右子树，再访问根节点。 123456789101112131415161718192021222324252627// 二叉树的定义public class TreeNode&#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val)&#123; this.val = val; &#125;&#125; // 先序遍历 (根节点-&gt;左子树-&gt;右子树)public void PreOrderTraversal(TreeNode root)&#123; System.out.println(root.val); PreOrderTraversal(root.left); PreOrderTraversal(root.right);&#125; // 中序遍历 （左子树-&gt;根节点-&gt;右子树）public void InOrderTraversal(TreeNode root)&#123; InOrderTraversal(root.left); System.out.println(root.val); InOrderTraversal(root.right);&#125; // 后序遍历 (左子树-&gt;右子树-&gt;根节点)public void PostOrderTraversal(TreeNode root)&#123; PostOrderTraversal(root.left); PostOrderTraversal(root.right); System.out.println(root.val);&#125; 参考： 书籍《算法 第四版》 https://www.cnblogs.com/maybe2030/p/4732377.htmlhttps://blog.csdn.net/u014532217/article/details/79118023https://blog.csdn.net/qq_31709249/article/details/103092783]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-String Problem]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-String%20problem%2F</url>
    <content type="text"><![CDATA[Longest Substring Without Repeating CharactersDescription Given a string, find the length of the longest substring without repeating character. example Input: &quot;abcabcbb&quot; Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. solution1. 方法一：暴力法 检查每一个子字符串是否有重复的字符12345678910111213141516171819public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); int ans = 0; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt;= n; j++) if (allUnique(s, i, j)) ans = Math.max(ans, j - i); return ans; &#125; public boolean allUnique(String s, int start, int end) &#123; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (int i = start; i &lt; end; i++) &#123; Character ch = s.charAt(i); if (set.contains(ch)) return false; set.add(ch); &#125; return true; &#125;&#125; 算法分析：时间复杂度：O(n3)；空间复杂度：O(min(m,n)) 2. 方法二：滑动窗口 滑动窗口经常用在数组和字符串的问题中，滑动窗口是数组和字符串中的一些元素，它用两个索引来表示滑动窗口的起始位置[i,j),滑动窗口通过滑动左右的两个索引来改变滑动窗口滑动的方向以及窗口内的元素. 本题用HashSet来存储现在的滑动窗口内的元素[i,j),通过检查第j个元素，如果不在集合中就存储到集合并继续增加滑动窗口右侧可值j，如果第j个元素已经在集合中了，那么就滑动左侧的索引i，从集合中删除第i个元素，直到此时第j个元素不在集合中了。 代码实现12345678910111213141516171819 public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int ans = 0, i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; n) &#123; // try to extend the range [i, j] if (!set.contains(s.charAt(j)))&#123; set.add(s.charAt(j++)); ans = Math.max(ans, j - i); &#125; else &#123; set.remove(s.charAt(i++)); &#125; &#125; return ans; &#125;&#125; 算法分析：时间复杂度：O(2n)=O(n) 3. 方法三:滑动窗口的优化 利用HashMap来代替HashSet123456789101112131415class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n=s.length(); int maxn=0; Map&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(); for(int i=0,j=0;j&lt;n;j++)&#123; if(map.contains(s.charAt(j)))&#123; i=Math.max(map.get(s.charAt(j)),i); &#125; amxn=Math.max(maxn,j-i+1); map.put(s.charAt(j),j+1); &#125; return maxn; &#125;&#125; 算法分析：时间复杂度O(n) Longest Palindromic Substring 回文字符串：正读反读都一样 1.方法一：暴力法 遍历所有的子字符串，判断它是不是回文字符串 1234567891011121314151617181920212223242526272829303132333435363738 class Solution &#123; public String longestPalindrome(String s) &#123; if(s.length()==1)&#123; return s; &#125; if(s.isEmpty())&#123; return ""; &#125; int maxn=0; int iMin=0; //遍历每个子字符串并判断是不是回文的 for(int i=0;i&lt;s.length();i++)&#123; for(int j=s.length()-1;j&gt;=i;j--) if(s.charAt(i)==s.charAt(j))&#123; if(check(s,i,j))&#123; if(j-i+1&gt;maxn)&#123; maxn=j-i+1; iMin=i; &#125; break; &#125; &#125; &#125; return s.substring(iMin,maxn); &#125; //检测一个字符串是不是回文 public boolean check(String s,int i,int j)&#123; while(i&lt;=j)&#123; if(s.charAt(i)!=s.charAt(j))&#123; return false; &#125; i++; j--; &#125; return true; &#125;&#125; 算法分析： 时间复杂度O(n^3) 2. 方法二：动态规划 暴力法时间复杂度高的原因是去检查每一个子字符串是不是回文的，降低时间复杂度就要减少对子字符串是不是回文的判断 假设一个字符串”ababa”,当我已经确认了”bab”是回文字符串，由于它左右两边的字符都是a，那么这个完整的字符串本身就是回文的，就可以不用对整个字符串再进行完整的判断。 假设一个字符串的长度为n，那么建立一个n*n数组P。在矩阵中P[i][j]=l，若l&gt;0：表示以字符S[i]开始和以S[j]结尾的字符串是回文字符串，字符串的长度为l;若l=0，表示此字符串不是回文字符串 只需要对矩阵中j&gt;=i的部分赋值即可，就j&lt;i部分为0； 1.一个字符的情况：将矩阵的对角线赋值为1，因为每个字符本身是回文的 2.两个字符的情况：j-i=1 P[i][j]=2,if S[i]=S[j] 3.多个字符的情况：j-i&gt;=2 if S[i]!=S[j] P[i][j]=0; if S[i]=S[j] if P[i+1][j-1]&gt;0 P[i][j]=p[i+1][j-1]+2; else P[i][j]=0; 字符串有多个字符组成时，如果两边的字符相等，那么这个字符串可能是回文的，这时将字符串去掉首末字符得到子字符串，如果子字符串回文的，那么这个字符串也是回文的。 12345678910111213141516171819202122232425262728293031323334353637383940 public static String longestPalindrome(String s)&#123; if(s.length()==0)&#123; return ""; &#125; if(s.length()==1)&#123; return s; &#125; int[][] p=new int[s.length()][s.length()]; int indexMin=0,maxn=1; //初始化二维数组P for(int i=0;i&lt;s.length();i++)&#123; for(int j=0;j&lt;s.length();j++)&#123; if(i==j) p[i][j]=1; &#125; &#125; for(int j=0;j&lt;s.length();j++)&#123; for(int i=j-1;i&gt;=0;i--)&#123; if(s.charAt(i)==s.charAt(j))&#123; if(j-i==1)&#123; p[i][j]=2; &#125; if(j-i&gt;=2)&#123; if(p[i+1][j-1]&gt;0)&#123; p[i][j]=p[i+1][j-1]+2; &#125;else&#123; p[i][j]=0; &#125; &#125; &#125;else&#123; p[i][j]=0; &#125; if(p[i][j]&gt;maxn)&#123; maxn=p[i][j]; indexMin=i; &#125; &#125; &#125; return s.substring(indexMin, indexMin+maxn);&#125; 算法分析： 时间复杂度：O(n^2) 空间复杂度：O(n^2)需要一个n*n的矩阵来存储数据 3.方法三：Expand Around Center 对于动态规划算法时间复杂度为O(n^2)，空间复杂度为O(n^2)，可以进一步优化只用O(1)的空间实现O(n^2)的时间复杂度 一个回文字符串它是成中心对称的，比如”baab”,”bab”,但是回文字符串分为两种：奇数字符数，偶数字符数 1234567891011121314151617181920212223242526272829 class Solution &#123; public String longestPalindrome(String s) &#123; if(s.length()==0)&#123; return ""; &#125; if(s.length()==1)&#123; return s; &#125; int indexMin=0,maxn=1; for(int i=0;i&lt;s.length();i++)&#123; int len1=expandAroundCenter(s,i,i); int len2=expandAroundCenter(s,i,i+1); int len=Math.max(len1,len2); if(len&gt;maxn)&#123; indexMin=i-(len-1)/2; maxn=len; &#125; &#125; return s.substring(indexMin,indexMin+maxn); &#125; private int expandAroundCenter(String s,int L,int R)&#123; while(L&gt;=0 &amp;&amp; R&lt;s.length() &amp;&amp; s.charAt(L)==s.charAt(R))&#123; L--; R++; &#125; return R-L-1; &#125; &#125; 算法分析 时间复杂度：O(n^2) 空间复杂苏：O(1) 4.方法四：最长公共字符串 将字符串S翻转为S’,检查S和S’的最长公共字符串就是S的最长回文子字符串此方法中存在一种问题，就是当字符串中某一个子串存在一个镜像子串本身并不是回文的，翻转之后会被检测为回文的。 Longest Common Substring 最长公共子字符串 动态规划问题 动态规划问题的两个特点： 1.最优子结构 2.重叠子问题 因为有重叠子问题，当前计算的过程中可能有的问题在之前的计算已经计算过了，现在又要计算一遍，导致大量重复的计算动态规划通过找到解决问题的递推关系，将已经完成计算的存储起来，当开始新的计算时如果包含之前计算的子问题时，不需要再次计算，只需要访问已经存储的计算结果就可以动态规划解决问题的方法一般减少了时间复杂度，增加了存储空间。 对于这个问题，假设有两个字符串s[0,…m],t[0,…,n],求两个字符串的最长公共子字符串定义矩阵mXn的矩阵L,L[i][j]表示以s[i]开始和t[j]结尾的公共子字符串长度的最大值，那么对于L[i+1][j+1]只是比L[i][j]增加了s[i+1]和t[j+1] 因此可以构造出最长公共子字符串的递归式： if s[i]==t[j] L[i][j]=L[i-1][j-1]+1 if s[i]!=t[j] L[i][j]=0 假设有两个字符串：”ABAB”和”BABA” ,构造出了上述的矩阵代码实现123456789101112131415161718192021222324 public static String LCS(String s1,String s2)&#123; if(s1.isEmpty() || s2.isEmpty())&#123; return ""; &#125; int indexMax=0,maxn=0; int[][] L=new int[s1.length()][s2.length()]; for(int i=0;i&lt;s1.length();i++)&#123; for(int j=0;j&lt;s2.length();j++)&#123; if(s1.charAt(i)==s2.charAt(j))&#123; if(i==0 || j==0)&#123; L[i][j]=1; &#125;else&#123; L[i][j]=L[i-1][j-1]+1; &#125; &#125; if(L[i][j]&gt;maxn)&#123; maxn=L[i][j]; indexMax=i; &#125; &#125; &#125; return s1.substring(indexMax+1-maxn, indexMax+1);&#125; 算法分析： 时间复杂度：O(m*n) 空间复杂度：O(m*n) 算法优化 从上面动态查找最长公共子字符串的过程中发现，在循环查找的过程中只会用到矩阵L中的两行，即正在计算的一行和完成计算的上一行，之前计算的和带计算的都用不到，所以只需要维护两行数据就足够了，不需要使用mxn的数组 代码实现：123456789101112131415161718192021222324252627282930 public class LCS_improve &#123; public static String LCS_improve(String s1,String s2)&#123; if(s1.isEmpty() || s2.isEmpty())&#123; return ""; &#125; int indexMax=0,maxn=0; int [][] L=new int[2][s1.length()]; for(int i=0;i&lt;s1.length();i++)&#123; int cur=(i+2)%2; int pre=(i+1)%2; for(int j=0;j&lt;s2.length();j++)&#123; if(s1.charAt(i)==s2.charAt(j))&#123; if(i==0 || j==0)&#123; L[cur][j]=1; &#125;else&#123; L[cur][j]=L[pre][j-1]+1; &#125; &#125;else&#123; L[cur][j]=0; &#125; if(L[cur][j]&gt;maxn)&#123; maxn=L[cur][j]; indexMax=i; &#125; &#125; &#125; return s1.substring(indexMax+1-maxn, indexMax+1); &#125;&#125; 算法分析时间复杂度：O(mn)空间复杂度：O(min(m,n)) Longest Common PrefixDescription Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “” Example Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] Output: &quot;fl&quot; Solution 1. 方法一：横向比较 这是一种迭代的方法，假设字符串数组的长度为n，先将第一个字符串和第二个字符串比较得到最长公共前缀prefix，再将得到的prefix和第三个字符串比较得到新的prefix，依次向后比较，直到最后一个字符串。如果比较的过程中有prefix为空时，直接返回” “,LCP(S1,S2,.....,SN)=LCP(LCP(LCP(S1,S2),S3),.....SN)。 public String longestCommonPrefix(String[] strs) { if (strs.length == 0) return ""; String prefix = strs[0]; for (int i = 1; i &lt; strs.length; i++) while (strs[i].indexOf(prefix) != 0) { prefix = prefix.substring(0, prefix.length() - 1); if (prefix.isEmpty()) return ""; } return prefix; } 算法分析时间复杂度：在最坏的情况下为O(S),S为字符串数组中所有字符的总数空间复杂度：O(1) 2. 方法二：纵向比较 横向比较需要从第一个字符串比较到最后一个，如果数组中最短的字符串再最后的位置，那么在整个算法执行的过程中会有很多不必要的比较运算，增加了时间复杂度。因此采用纵向的比较，以最短字符串的长度l为标准，最多只比较到每个字符串的l位。从所有字符串的第一个字符开始比较，对位比较所有的字符串，直到在某一位的字符不相同或者已经到了最短的字符串的末尾字符，就结束运算。 public class Longest_Common_Prefix { public String longestCommonPrefix(String[] strs) { if(strs.length == 0) { return ""; } for(int i=0;i&lt;strs[0].length();i++) { char t = strs[0].charAt(i); for(int j=1;j&lt;strs.length;j++) { if(i == strs[j].length() || strs[j].charAt(i) != t) { return strs[0].substring(0, i); } } } return strs[0]; } } 算法分析时间复杂度：最坏情况下(所有字符串相同)O(S),一般情况下n*min(Si)空间复杂度：O(1) 3. 方法三：分而治之 将字符数组分为两组，分别对两组查找最长公共前缀sl,sr，最后再计算sl和sr的公共前缀。 public class Longest_Common_Prefix { //分而治之的方法 public String longestCommonPrefix(String[] strs) { if(strs.length==0) { return ""; } return longestCommonPrefix(strs,0,strs.length-1); } private String longestCommonPrefix(String[] strs,int l,int r) { if(l==r) { return strs[l]; } int mid = (l+r)/2; String lcpLeft=longestCommonPrefix(strs,l,mid); String lcpRight=longestCommonPrefix(strs,mid+1,r); return commonPrefix(lcpLeft,lcpRight); } private String commonPrefix(String s1,String s2) { int len=Math.min(s1.length(), s2.length()); for(int i=0;i&lt;len;i++) { if(s1.charAt(i) != s2.charAt(i)) { return s1.substring(0, i); } } return s1.substring(0,len); } } 算法分析时间复杂度：最坏情况下为O(S),(S=mn,m为每个字符串的长度，n为字符串的个数)空间复杂度：O(mlogn),算法logn次的递归调用，每次都需要m个存储空间 4. 方法四：二分法 首先找到字符串数组中最短字符串的长度minLen,它也是公共前缀的最大的长度，那么查找最长公共前缀的范围就缩小到每个字符串[0,minLen]之间。 将查找范围分为等长的两部分，[0,mid]和[mid+1,minLen]，取第一个字符串的前半部分的子字符串substr1 = str1.subString(0,mid),去和其他的字符串比较判断substr1是不是公共前缀，这时会有两种情况： 如果substr1是公共前缀，那么就将substr1增加判断更长的子字符串是不是公共前缀 如果substr1不是公共前缀，那么对于长度大于substr1的字符串都不是公共前缀，这时减小substr1去判断更小的子字符串是不是公共前缀 class Solution { public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return ""; int minLen = Integer.MAX_VALUE; for (String str : strs) minLen = Math.min(minLen, str.length()); int low = 1; int high = minLen; while (low &lt;= high) { int middle = (low + high) / 2; if (isCommonPrefix(strs, middle)) low = middle + 1; else high = middle - 1; } return strs[0].substring(0, (low + high) / 2); } private boolean isCommonPrefix(String[] strs, int len){ String str1 = strs[0].substring(0,len); for (int i = 1; i &lt; strs.length; i++) if (!strs[i].startsWith(str1)) return false; return true; } } 算法分析时间复杂度：O(S * logn)空间复杂度：O(1) Valid ParenthesesDescription Given a string containing just the characters &apos;(&apos;, &apos;)&apos;, &apos;{&apos;, &apos;}&apos;, &apos;[&apos; and &apos;]&apos;, determine if the input string is valid. An input string is valid if: 1.Open brackets must be closed by the same type of brackets. 2.Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example Example 1: Input: &quot;()&quot; Output: true Example 2: Input: &quot;()[]{}&quot; Output: true Example 3: Input: &quot;(]&quot; Output: false Example 4: Input: &quot;([)]&quot; Output: false Example 5: Input: &quot;{[]}&quot; Output: true Solution 方法概述-堆栈法 对于一个有效的字符表达式，字符串中的括号都是成对出现的。正如题中所说，打开的括号必须有相同形式的关闭括号，并且所有打开的括号必须以正确的顺序关闭。 从起始位置开始检查字符串，如果第一个字符是关闭字符，那么这个字符串一定不是有效的；如果第一个是某种打开字符，将它压入堆栈 stack.push(char c)，每遇到一个打开字符就做相同的操作；如果遍历字符串中遇到的关闭字符，看栈顶的字符是不是和此关闭字符相匹配的打开字符，如果是，将字符出栈并继续遍历，如果不是，那么就不是有效的字符串；顺利遍历完整个字符串时，检查栈是否为空，如果是空，那么字符串时有效的，否则无效。 class Solution { public boolean isValid(String s) { if(s.isEmpty()) { return true; } char[] stack = new char[s.length()]; int top = 0; for(int i=0;i&lt;s.length();i++) { char c = s.charAt(i); if(c=='{' || c=='[' || c=='(') { stack[top++] = c; } if(c=='}') { if(top==0 || stack[--top]!='{') { return false; } } if(c==']') { if(top==0 || stack[--top]!='[') { return false; } } if(c==')') { if(top==0 || stack[--top]!='(') { return false; } } } return top==0; } } Generate ParenthesesDescription Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. Example given n = 3, a solution set is: [ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot; ] Solution 方法一：暴力法 方法概述：产生所有可能的字符串，检查每个字符串是不是有效形式。 public class Generate_Parentheses { public List&lt;String&gt; generateParentheses(int n){ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); generateAll(new char[2*n],0,list); return list; } private void generateAll(char[] current,int index,List&lt;String&gt; result) { if(index == current.length) { if(valid(current)) { result.add(new String(current)); } }else { current[index] = '('; generateAll(current,index+1,result); current[index] = ')'; generateAll(current,index+1,result); } } private boolean valid(char[] current) { int flag=0; for(char c:current) { if(c == '(') flag++; else flag--; if(flag&lt;0) return false; } return (flag==0); } } 算法分析 时间复杂度：O(n*2^2n) 空间复杂度：O(n*2^2n) 方法二： 回溯算法 方法概述：回溯算法相当于穷举法(通用解法的美称)，性能一般不太理想，但某些情况和穷举法相比性能也有显著的提升，和穷举法不同的是回溯法设置一些条件过滤了一些不可能的情况，回溯法一般用递归来解决 public class Generate_Parentheses { //回溯法 public List&lt;String&gt; generateParentheses(int n){ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); backtrack(list,"",0,0,n); return list; } private void backtrack(List&lt;String&gt; list,String s,int open,int close,int max) { if(s.length() == 2*max) { list.add(s); return; } if(open&lt;max) { backtrack(list,s+'(',open+1,close,max); } if(close&lt;open) { backtrack(list,s+')',open,close+1,max); } } } 算法分析 时间复杂度：O(4^n/n^1/2) 空间复杂度：O(4^n/n^1/2) Longest Valid Parentheses(32-Hard)Description Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring. Example Example 1: Input: &quot;(()&quot; Output: 2 Explanation: The longest valid parentheses substring is &quot;()&quot; Example 2: Input: &quot;)()())&quot; Output: 4 Explanation: The longest valid parentheses substring is &quot;()()&quot; Solution Approach 1. Dynamic Programming public class Solution { public int longestValidParentheses(String s) { int maxans = 0; int dp[] = new int[s.length()]; for (int i = 1; i &lt; s.length(); i++) { if (s.charAt(i) == ')') { if (s.charAt(i - 1) == '(') { dp[i] = (i &gt;= 2 ? dp[i - 2] : 0) + 2; } else if (i - dp[i - 1] &gt; 0 &amp;&amp; s.charAt(i - dp[i - 1] - 1) == '(') { dp[i] = dp[i - 1] + ((i - dp[i - 1]) &gt;= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2; } maxans = Math.max(maxans, dp[i]); } } return maxans; } } Approach 2. Using Stack public class Solution { public int longestValidParentheses(String s) { int maxans = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(-1); for (int i = 0; i &lt; s.length(); i++) { if (s.charAt(i) == '(') { stack.push(i); } else { stack.pop(); if (stack.empty()) { stack.push(i); } else { maxans = Math.max(maxans, i - stack.peek()); } } } return maxans; } } Approach 3. Without extra space class Solution { public int longestValidParentheses(String s) { int left = 0, right = 0, maxlength = 0; for (int i = 0; i &lt; s.length(); i++) { if (s.charAt(i) == '(') { left++; } else { right++; } if (left == right) { maxlength = Math.max(maxlength, 2 * right); }else if (right &gt;= left) { left = right = 0; } } left = right = 0; for (int i = s.length() - 1; i &gt;= 0; i--) { if (s.charAt(i) == '(') { left++; } else { right++; } if (left == right) { maxlength = Math.max(maxlength, 2 * left); } else if (left &gt;= right) { left = right = 0; } } return maxlength; } } Substring with Concatenation of All WordsDescription You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example Input: s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively. The output order does not matter, returning [9,0] is fine too. Solution Code public class SubstringIndexOfAllWords { public List&lt;Integer&gt; findSubString(String s, String[] words){ List&lt;Integer&gt; indexs = new ArrayList&lt;Integer&gt;(); int n = s.length(); int num = words.length; if(n == 0 || num == 0) return indexs; int len = words[0].length(); //counts用于存储words中字符串的个数和每个字符串的个数 Map&lt;String,Integer&gt; counts = new HashMap(); for(String word : words) { counts.put(word, counts.getOrDefault(word, 0) + 1); } for(int i = 0;i &lt; n - num * len +1; i++) { Map&lt;String,Integer&gt; temp = new HashMap(); int j = 0; while(j &lt; num) { String word = s.substring(i + j * len, i + (j + 1) * len); if(counts.containsKey(word)) { temp.put(word, temp.getOrDefault(word, 0) + 1); if(temp .get(word) &gt; counts.get(word)) { break; } }else { break; } j++; } if(j == num) { indexs.add(i); } } return indexs; } }]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Sort Problem]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-Sort%20Problem%2F</url>
    <content type="text"><![CDATA[Next Permutation(31-Medium)Description Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. Example 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 Solution Code 如果一个数组中的元素从左到右成递减次序，那么就没有一个比它更大的排列，eg.5,4,3,1。 首先从数组的右边起，找到a[i]使其右边的部分不再递减。 public class NextPermutation { public void nextPermutation(int[] nums) { int i = nums.length - 2; while(i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i+1]) { i--; } if(i &gt;= 0) { int j = nums.length - 1; while(j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[i]) { j--; } swap(nums, i, j); } reverse(nums, i + 1); } public void reverse(int[] nums, int i) { int j = nums.length - 1; while(i &lt; j) { swap(nums, i, j); i++; j--; } } public void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } Time Complexity: O(n)Space Complexity: O(1)]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Search Problem]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-Search%20problem%2F</url>
    <content type="text"><![CDATA[Search in Rotated Sorted Array（33-Medium）Description Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n). Example Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 Solution 利用二分查找：O(log n) class Solution { public int search(int[] nums, int target) { if(nums.length == 0) return -1; int l =0; int r = nums.length - 1; while(l &lt;= r){ int m = (l + r) / 2; if(target == nums[l]) return l; if(target == nums[m]) return m; if(target == nums[r]) return r; if(target &gt; nums[l] &amp;&amp; target &lt; nums[m]){ r = m - 1; continue; }else if(target &gt; nums[m] &amp;&amp; target &lt; nums[r]){ l = m + 1; continue; }else if(nums[l] &gt; nums[m]){ r = m -1; continue; }else if(nums[m] &gt; nums[r]){ l = m + 1; continue; } } return -1; } } 优化： public int search(int[] nums, int target) { int lo = 0, hi = nums.length - 1; while (lo &lt; hi) { int mid = (lo + hi) / 2; if ((nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid])) lo = mid + 1; else hi = mid; } return lo == hi &amp;&amp; nums[lo] == target ? lo : -1; } Find First and Last Position of Element in Sorted Array（34-Medium）Description Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] Solution 改进基本的二分查找： 在二分查找中基本的条件： 1）if(nums[mid] &gt; target) right = mid -1; 2) if(nums[mid] &lt; target) left = mid + 1; 3) if(nums[mid] = target) right = mid,找到目标值 在本题中查找first和last目标值，将分为两部分查找，先找first，再找 last。 1.Search first first的查找应该使查找范围尽量靠左，尽管数组中可能有多个target，但是应该找到最左面的 [1,3,5,5,5,5,9], target = 5 l = 1; r = 9; mid = 5(2)； mid == 5,这回应该尽量向左找，因为此时的5可能不是first，r = mid l = 1; r = mid = 5; mid = 3; mid &lt; 5,这时时基本的二分查找条件，l = mid + 1 l = r = 5, 循环结束 2. Search last 和first相反，last应该使查找范围尽量靠右 同样的例子，[1,3,5,5,5,5,9], target = 5 l = 1; r = 9; mid = 5(2)； mid == 5,这回应该尽量向右找，因为此时的5可能不是last，l = mid l = mid = 5, r = 9, mid = 5(3) mid = 5, 尽量向右找， l = mid l = mid = 5 , r = 9 , mid = 5(4) mid = 5 , 尽量向右找, l = mid l = mid = 5, r = 9, mid = 5,----? 这时出问题了，最后的范围只剩下[5,9]但是取中值的时候，mid总是等于5，跳不出循环， 我们想让mid更靠右，因为last target 更在乎它右边的值，而first更在乎它左边的值， 但是 mid = (l + r）/ 2 的公式更偏向与左边，索引在找last的时候讲中值公式更改为 mid = (l + r）/ 2 + 1 索引最后一次 mid = 9 mid &gt; 5,也就是说右边从这个值开始不会再有5了，而最后一个5在m - 1，r = m - 1 通过first, last 的差异来进行两次循环 solution 1： class Solution { public int[] searchRange(int[] nums, int target) { int[] index = {-1,-1}; if(nums.length == 0) return index; int l = 0; int r = nums.length - 1; //第一次：找到第一个目标值索引 while(l &lt; r) { int m = (l + r) / 2; if(nums[m] &lt; target) { l = m + 1; }else { r = m; } } if(nums[l] != target) { return index; }else { index[0] = l; } //第二次：找到最后一个目标值的索引 r = nums.length - 1; while(l &lt; r) { int m = (l + r) / 2 + 1; if(nums[m] &gt; target) { r = m - 1; }else { l = m; } } index[1] = r; return index; } } solution 2 class Solution { public int[] searchRange(int[] nums, int target) { int[] index = {-1,-1}; if(nums.length == 0) { return index; } int left_index = Index(nums,target,true); if(left_index == nums.length || nums[left_index] != target) { return index; }else { index[0] = left_index; } index[1] = Index(nums, target,false) - 1; return index; } public int Index(int[] nums, int target,boolean left) { int l = 0; int r = nums.length; while(l &lt; r) { int m = (l + r) / 2; if(nums[m] &gt; target || (left &amp;&amp; nums[m] == target)) { r = m; }else { l = m + 1; } } return l; } } 时间复杂度 O(log n)]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Math Problem]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-Math-Problem%2F</url>
    <content type="text"><![CDATA[Palindrome Number 判断一个整数是否是回文的 方法：将这个整数的后半段反转，将它和前半段比较是否相同 特殊情况： x&lt;0 不是回文的 x是以0结尾的整数 不是回文的 public class PalindromeNumber { public boolean isPalindrome(int x) { if(x &lt; 0 || x % 10 == 0 &amp;&amp; x != 0) { return false; } int reverseNumber = 0; while(x &gt; reverseNumber) { reverseNumber = reverseNumber * 10 + x % 10; x = x / 10; } return x == reverseNumber || x== reverseNumber / 10; } }]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Linked List]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-Linked-List%2F</url>
    <content type="text"><![CDATA[Remove Nth Node From End of ListDescription Given a linked list, remove the n-th node from the end of list and return its head. Example Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Solution 方法一：两次扫描第一次扫描确定链表的长度，第二遍扫描删除指定的节点 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ //***********自己实现的方法*****************// class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode t = head; int len=0; int point=1; while(t != null) { len++; t = t.next; } if(len - n == 0) { return head.next; } t=head; while(point &lt; len-n){ t = t.next; point++; } t.next=t.next.next; return head; } } 方法优化提升首先设置一个指向head的“dumpy”结点，设置这个结点是为了简化一些特殊的情况，比如链表只有一个结点点或者要删除的节点是第一个结点。第一次扫描链表得到链表的长度L第二次扫描先指向dumpy，从开始移动到第 L-n 个结点，使第 L-n 个结点指向第 L-n+2 个结点。 public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0); dummy.next = head; int length = 0; ListNode first = head; while (first != null) { length++; first = first.next; } length -= n; first = dummy; while (length &gt; 0) { length--; first = first.next; } first.next = first.next.next; return dummy.next; } 算法分析 时间复杂度：O(L) L为链表的长度 空间复杂度：O(1) 方法二：一次扫描法一次扫描的方法是通过设置两个指针 first 和 second，首先 first 指针从开始移动 n+1 次，second 指针在起始的位置。这样使两个指针始终保持 n 个节点的距离向前移动，当 first 指针指向节点为空的时候，second 指针处在倒数第 n+1 的位置，此时可以删除目标位置的节点。 public ListNode removeNthFormEnd(ListNode head,int n) { ListNode dumpy = new ListNode(0); dumpy.next = head; ListNode first = head; ListNode second = head; for(int i=1;i&lt;n+1;i++) { first=first.next; } while(first != null) { first = first.next; second = second.next; } second.next = second.next.next; return dumpy.next; } 算法分析 时间复杂度：O(L) L为链表的长度 空间复杂度：O(1) Merge Two Sorted ListsDescription Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4 Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 Solution 方法一：迭代法/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode cur = new ListNode(0); ListNode relt = cur; while(l1!=null &amp;&amp; l2!=null) { if(l1.val &lt; l2.val) { cur.next = l1; l1 = l1.next; }else { cur.next = l2; l2 = l2.next; } cur = cur.next; } if(l1==null) cur.next=l2; if(l2==null) cur.next=l1; return relt.next; } } 方法二：递归法/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if(l1==null) return l2; if(l2==null) return l1; if(l1.val &lt; l2.val) { l1.next=mergeTwoLists(l1.next,l2); return l1; }else { l2.next=mergeTwoLists(l1,l2.next); return l2; } } } Merge k Sorted ListsDescription Merge k sorted linked lists and return it as one sorted list. Example Input: [ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6 ] Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 Solution 分而治之方法方法描述：这是一种递归的方法，思想就是将k个链表两两合并，如下图所示。 public class MergeKSortedLists { public ListNode mergeKLists(ListNode[] lists) { return merge(lists,0,lists.length-1); } private ListNode merge(ListNode[] lists,int left,int right) { if(left == right) { return lists[left]; } if(left &lt; right) { int mid = (right + left)/2; ListNode l1 = merge(lists,left,mid); ListNode l2 = merge(lists,mid+1,right); return mergeTwoLists(l1,l2); }else { return null; } } private ListNode mergeTwoLists(ListNode l1,ListNode l2) { if(l1 == null) return l2; if(l2 == null) return l1; if(l1.val &lt; l2.val) { l1.next = mergeTwoLists(l1.next,l2); return l1; }else { l2.next = mergeTwoLists(l1,l2.next); return l2; } } } 算法分析 时间复杂度：O(N*lgk),N是两个链表节点总数，lgk是分治算法递归实现的复杂度. 空间复杂度：O(1) Swap nodes in pairsDescription Given a linked list, swap every two adjacent nodes and return its head. Example Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Soution 迭代法public class SwapNodesInPairs { public ListNode swappairs(ListNode head) { if(head==null || head.next==null) return head; ListNode dumpy = head.next; while(head!=null &amp;&amp; head.next!=null) { ListNode first = head.next; ListNode second = head.next.next; first.next = head; head.next = (second==null || second.next==null) ? second : second.next; head = second; } return dumpy; } } 算法分析 时间复杂度：O(n),n为链表的长度 空间复杂度：O(1) 递归法public class SwapNodesInPairs { public ListNode swapPairs(ListNode head) { if(head==null || head.next==null) return head; ListNode first = head.next; ListNode second = head.next.next; first.next = head; head.next = swapPairs(second); return first; } } Reverse Nodes in k-GroupDescription Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Soluton /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseKGroup(ListNode head, int k) { /* if(head == null) return null; if(k == 1) return head;*/ ListNode dumpy = new ListNode(-1); dumpy.next = head; ListNode temp = head; int count = 0; while(temp!=null &amp;&amp; count!=k) { temp = temp.next; count++; } if(count == k) { temp = reverseKGroup(temp,k); ListNode pre = head; ListNode cur = head.next; while(k &gt; 1) { pre.next = cur.next; cur.next = dumpy.next; dumpy.next = cur; cur = pre.next; k--; } pre.next = temp; } return dumpy.next; } } 算法分析 时间复杂度：O(n) 空间复杂度：O(1) Reverse Linked List实现翻转链表的功能 方法一：原地翻转public class ReverseLinkedList { public ListNode reverseList(ListNode head) { //原地翻转法 if(head == null) return head; ListNode dumpy = head; ListNode pre = head; ListNode cur = head.next; while(cur != null) { pre.next = cur.next; cur.next = dumpy.next; dumpy.next = cur; cur = pre.next; } return dumpy.next; } } 方法二：建立新链表，插入式翻转public class ReverseLinkedList { public ListNode reverseList(ListNode head) { //建立新链表，添加节点翻转法 if(head == null) return head; ListNode dumpy = new ListNode(-1); ListNode cur = head; while(cur != null) { ListNode nex = cur.next; cur.next = dumpy.next; dumpy.next = cur; cur = nex; } return dumpy.next; } }]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Dynamic Programming]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-dynamic%20programming%2F</url>
    <content type="text"><![CDATA[Longest Palindromic Substring 回文字符串：正读反读都一样 方法一：暴力法 遍历所有的子字符串，判断它是不是回文字符串 class Solution { public String longestPalindrome(String s) { if(s.length()==1){ return s; } if(s.isEmpty()){ return ""; } int maxn=0; int iMin=0; //遍历每个子字符串并判断是不是回文的 for(int i=0;i&lt;s.length();i++){ for(int j=s.length()-1;j&gt;=i;j--) if(s.charAt(i)==s.charAt(j)){ if(check(s,i,j)){ if(j-i+1&gt;maxn){ maxn=j-i+1; iMin=i; } break; } } } return s.substring(iMin,maxn); } //检测一个字符串是不是回文 public boolean check(String s,int i,int j){ while(i&lt;=j){ if(s.charAt(i)!=s.charAt(j)){ return false; } i++; j--; } return true; } } 算法分析：时间复杂度O(n^3) 方法二：动态规划 暴力法时间复杂度高的原因是去检查每一个子字符串是不是回文的，降低时间复杂度就要减少对子字符串是不是回文的判断 假设一个字符串”ababa”,当我已经确认了”bab”是回文字符串，由于它左右两边的字符都是a，那么这个完整的字符串本身就是回文的，就可以不用对整个字符串再进行完整的判断。 假设一个字符串的长度为n，那么建立一个n*n数组P。在矩阵中P[i][j]=l，若l&gt;0：表示以字符S[i]开始和以S[j]结尾的字符串是回文字符串，字符串的长度为l;若l=0，表示此字符串不是回文字符串 只需要对矩阵中j&gt;=i的部分赋值即可，就j&lt;i部分为0； 1.一个字符的情况：将矩阵的对角线赋值为1，因为每个字符本身是回文的 2.两个字符的情况：j-i=1 P[i][j]=2,if S[i]=S[j] 3.多个字符的情况：j-i&gt;=2 if S[i]!=S[j] P[i][j]=0; if S[i]=S[j] if P[i+1][j-1]&gt;0 P[i][j]=p[i+1][j-1]+2; else P[i][j]=0; 字符串有多个字符组成时，如果两边的字符相等，那么这个字符串可能是回文的，这时将字符串去掉首末字符得到子字符串，如果子字符串回文的，那么这个字符串也是回文的。 public static String longestPalindrome(String s){ if(s.length()==0){ return ""; } if(s.length()==1){ return s; } int[][] p=new int[s.length()][s.length()]; int indexMin=0,maxn=1; //初始化二维数组P for(int i=0;i&lt;s.length();i++){ for(int j=0;j&lt;s.length();j++){ if(i==j) p[i][j]=1; } } for(int j=0;j&lt;s.length();j++){ for(int i=j-1;i&gt;=0;i--){ if(s.charAt(i)==s.charAt(j)){ if(j-i==1){ p[i][j]=2; } if(j-i&gt;=2){ if(p[i+1][j-1]&gt;0){ p[i][j]=p[i+1][j-1]+2; }else{ p[i][j]=0; } } }else{ p[i][j]=0; } if(p[i][j]&gt;maxn){ maxn=p[i][j]; indexMin=i; } } } return s.substring(indexMin, indexMin+maxn); } 算法分析： 时间复杂度：O(n^2) 空间复杂度：O(n^2),需要一个n*n的矩阵来存储数据 方法三：Expand Around Center 对于动态规划算法时间复杂度为O(n^2)，空间复杂度为O(n^2)，可以进一步优化只用O(1)的空间实现O(n^2)的时间复杂度 一个回文字符串它是成中心对称的，比如”baab”,”bab”,但是回文字符串分为两种：奇数字符数，偶数字符数 class Solution { public String longestPalindrome(String s) { if(s.length()==0){ return ""; } if(s.length()==1){ return s; } int indexMin=0,maxn=1; for(int i=0;i&lt;s.length();i++){ int len1=expandAroundCenter(s,i,i); int len2=expandAroundCenter(s,i,i+1); int len=Math.max(len1,len2); if(len&gt;maxn){ indexMin=i-(len-1)/2; maxn=len; } } return s.substring(indexMin,indexMin+maxn); } private int expandAroundCenter(String s,int L,int R){ while(L&gt;=0 &amp;&amp; R&lt;s.length() &amp;&amp; s.charAt(L)==s.charAt(R)){ L--; R++; } return R-L-1; } } 算法分析 时间复杂度：O(n^2) 空间复杂苏：O(1) 方法四：最长公共字符串** 将字符串S翻转为S’,检查S和S’的最长公共字符串就是S的最长回文子字符串此方法中存在一种问题，就是当字符串中某一个子串存在一个镜像子串本身并不是回文的，翻转之后会被检测为回文的。 下面是一种基于动态规划的求解最长公共字符串的方法。 Longest Common Substring 最长公共子字符串 动态规划问题 问题：因为有重叠子问题，当前计算的过程中可能有的问题在之前的计算已经计算过了，现在又要计算一遍，导致大量重复的计算 动态规划的解决方法：动态规划通过找到解决问题的递推关系，将已经完成计算的存储起来，当开始新的计算时如果包含之前计算的子问题时，不需要再次计算，只需要访问已经存储的计算结果就可以 动态规划解决问题的方法一般减少了时间复杂度，增加了存储空间。 动态规划问题的两个特点： 最优子结构 重叠子问题 对于这个问题，假设有两个字符串s[0,...m],t[0,...,n],求两个字符串的最长公共子字符串 定义矩阵mXn的矩阵L,L[i][j]表示以s[i]开始和t[j]结尾的公共子字符串长度的最大值，那么对于L[i+1][j+1]只是比L[i][j]增加了s[i+1]和t[j+1] 因此可以构造出最长公共子字符串的递归式： if s[i]==t[j] L[i][j]=L[i-1][j-1]+1 if s[i]!=t[j] L[i][j]=0 假设有两个字符串：”ABAB”和”BABA” ,构造出了上述的矩阵代码实现 public static String LCS(String s1,String s2){ if(s1.isEmpty() || s2.isEmpty()){ return ""; } int indexMax=0,maxn=0; int[][] L=new int[s1.length()][s2.length()]; for(int i=0;i&lt;s1.length();i++){ for(int j=0;j&lt;s2.length();j++){ if(s1.charAt(i)==s2.charAt(j)){ if(i==0 || j==0){ L[i][j]=1; }else{ L[i][j]=L[i-1][j-1]+1; } } if(L[i][j]&gt;maxn){ maxn=L[i][j]; indexMax=i; } } } return s1.substring(indexMax+1-maxn, indexMax+1); } 算法分析： 时间复杂度：O(mn) 空间复杂度：O(mn) 算法优化从上面动态查找最长公共子字符串的过程中发现，在循环查找的过程中只会用到矩阵L中的两行，即正在计算的一行和完成计算的上一行，之前计算的和带计算的都用不到，所以只需要维护两行数据就足够了，不需要使用mxn的数组 代码实现： public class LCS_improve { public static String LCS_improve(String s1,String s2){ if(s1.isEmpty() || s2.isEmpty()){ return ""; } int indexMax=0,maxn=0; int [][] L=new int[2][s1.length()]; for(int i=0;i&lt;s1.length();i++){ int cur=(i+2)%2; int pre=(i+1)%2; for(int j=0;j&lt;s2.length();j++){ if(s1.charAt(i)==s2.charAt(j)){ if(i==0 || j==0){ L[cur][j]=1; }else{ L[cur][j]=L[pre][j-1]+1; } }else{ L[cur][j]=0; } if(L[cur][j]&gt;maxn){ maxn=L[cur][j]; indexMax=i; } } } return s1.substring(indexMax+1-maxn, indexMax+1); } } 算法分析： 时间复杂度：O(mn) 空间复杂度：O(min(m,n))]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Array Problem]]></title>
    <url>%2F2020%2F06%2F01%2FLeetcode-Array-Problem%2F</url>
    <content type="text"><![CDATA[Two SumDescription Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Solution 方法一：暴力遍历12345678910111213public int[] twoSum(int[] nums, int target) &#123; int[] res=new int[2]; int n=0; for(int i=0;i&lt;nums.length-1;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums[i]+nums[j]==target)&#123; res[n++]=i; res[n++]=j; &#125; &#125; &#125; return res; &#125; 时间复杂度：O(n^2) 方法二： 利用哈希表12345678910111213public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123; return new int[] &#123; i, map.get(complement) &#125;; &#125; &#125; throw new IllegalArgumentException("No two sum solution");&#125; 时间复杂度：O(n)空间复杂度：O(n) 方法三：对方法二的改进1234567891011public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException("No two sum solution");&#125; 时间复杂度：O(n)空间复杂度：O(n) 3SumDescription Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note The solution set must not contain duplicate triplets Example Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is:[ [-1, 0, 1], [-1, -1, 2]] Solution1234567891011121314151617181920212223242526272829public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums)&#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList(); Arrays.sort(nums); for(int i=0;i&lt;nums.length;i++) &#123; if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) &#123; continue; &#125; int left=i+1; int right=nums.length-1; while(left&lt;right) &#123; if(nums[i]+nums[left]+nums[right]==0) &#123; list.add(Arrays.asList(nums[i],nums[left],nums[right])); left++; right--; while(left&lt;right &amp;&amp; left&gt;0 &amp;&amp; nums[left]==nums[left-1]) &#123; left++; &#125; while(left&lt;right &amp;&amp; right&lt;nums.length-1 &amp;&amp; nums[right]==nums[right+1]) &#123; right--; &#125; &#125;else if(nums[i]+nums[left]+nums[right]&lt;0) &#123; left++; &#125;else &#123; right--; &#125; &#125; &#125; return list;&#125; 时间复杂度：O(n^2) 3Sum ClosestDescription Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Solution解法思路类似于3Sum123456789101112131415161718192021222324252627public int threeSumClosest(int[] nums,int target) &#123; int sum=0,cox=Integer.MAX_VALUE; int[] rest = new int[3]; Arrays.sort(nums); for(int i=0;i&lt;nums.length;i++) &#123; int l=i+1; int r=nums.length-1; while(l&lt;r) &#123; sum=nums[i]+nums[l]+nums[r]; int temp=Math.abs(target-sum); if(temp&lt;cox) &#123; cox=temp; rest[0]=nums[i]; rest[1]=nums[l]; rest[2]=nums[r]; &#125; if(sum==target) &#123; return sum; &#125;else if(sum&lt;target) &#123; l++; &#125;else &#123; r--; &#125; &#125; &#125; return rest[0]+rest[1]+rest[2]; &#125; 时间复杂度O(n^2) 4SumSolution12345678910111213141516171819202122232425262728293031323334353637public class FourSum &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums,int target)&#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList(); Arrays.sort(nums); for(int i=0;i&lt;nums.length;i++) &#123; if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) &#123; continue; &#125; for(int j=i+1;j&lt;nums.length;j++) &#123; if(j&gt;i+1 &amp;&amp; nums[j]==nums[j-1]) &#123; continue; &#125; int l=j+1; int r=nums.length-1; while(l&lt;r) &#123; int sum=nums[i]+nums[j]+nums[l]+nums[r]; if(sum == target) &#123; list.add(Arrays.asList(nums[i],nums[j],nums[l],nums[r])); l++; r--; while(l&lt;r &amp;&amp; l&gt;0 &amp;&amp; nums[l] == nums[l-1]) &#123; l++; &#125; while(l &lt; r &amp;&amp; r &lt; nums.length &amp;&amp; nums[r] == nums[r+1]) &#123; r--; &#125; &#125;else if(sum &gt; target)&#123; r--; &#125;else &#123; l++; &#125; &#125; &#125; &#125; return list; &#125;&#125; 时间复杂度：O(n^3) Median of Two Sorted ArraysDescription There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays.The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty. Example nums1 = [1, 3] nums2 = [2] median is 2.0 Solution class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int m=nums1.length; int n=nums2.length; if(m&gt;n){ int[] temp=nums1;nums1=nums2;nums2=temp; int tmp=m;m=n;n=tmp; } int iMin=0,iMax=m,hl=(m+n+1)/2; while(iMin&lt;=iMax){ int i=(iMin+iMax)/2; int j=hl-i; if(i&lt;iMax &amp;&amp; nums2[j-1]&gt;nums1[i]){ iMin=i+1; }else if(i&gt;iMin &amp;&amp; nums1[i-1]&gt;nums2[j]){ iMax=i-1; }else{ int maxLeft=0; if(i==0){ maxLeft=nums2[j-1]; }else if(j==0){ maxLeft=nums1[i-1]; }else{ maxLeft=Math.max(nums1[i-1],nums2[j-1]); } if((m+n)%2==1){ return maxLeft; } int minRight=0; if(i==m){ minRight=nums2[j]; }else if(j==n){ minRight=nums1[i]; }else{ minRight=Math.min(nums1[i],nums2[j]); } return (maxLeft+minRight)/2.0; } } return 0.0; } }]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-Logistic回归]]></title>
    <url>%2F2019%2F02%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Logistic%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[Logistic回归-模型原理及梯度下降算法1. Logistc回归模型回归：用一条直线对给定数据进行拟合(最佳拟合直线) Logistic 回归：根据现有数据对分类边界建立回归方程，以此直线进行分类 给定数据集 \( [(x_{1},y_{1}),(x_{2},y_{2}),…,(x_{m},y_{m})] \) ，每个样本 x 有 d 个属性 \( x=[x_{1},x_{2},…,x_{d}] \) 。 对于给定数据集，该数据集的线性拟合公式为： $$ f(x) = w_{0}x_{0}+w_{1}x_{1}+w_{2}x_{2}+…+w_{d}x_{d} $$ $$ f(x) = w^{T}x $$ 其中 \( w^{T}=[w_{0}，w_{1},w_{2},…,w_{d}] \) 若要进行分类任务(以二分类为例)，需要找到一个单调可微的函数将分类任务的真实标记 y 和线性回归模型的预测值关联起来。 分类输出标记 y = {0 ， 1} ， 回归模型的预测值 \( z = w^{T}x \) ， 因此需要一个函数将 z 转化为 0 / 1 值。 最理想的函数是 “ 单位阶跃函数 ”，但是这个函数是不连续的函数，它的跳跃点从0到1的跳跃过程很难处理。需要一个近似单位阶跃的函数，更容易处理且单调可微，这就是 “ 对几率函数(logistic function) ” 函数 ,它是“Sigmoid函数”的一种 。 $$ y_{w}(x) = \frac{1}{1+z^{-1} }= \frac{1}{1+(w^{T}x)^{-1}} $$ $$ y = \begin{cases}1 &amp; \text{ if } z&gt;0 \0.5 &amp; \text{ if } z=0 \0 &amp; \text{ if } z&lt;0\end{cases} $$ 对下式取对数： $$ y = \frac{1}{ 1 + e^{-(w^{T}x+b)} }$$ $$ ln\frac{y}{1-y}=w^{T}x+b $$ 将上式中y作为样本为正例的可能性，1-y表示样本为负例的可能性，两者的比值 y/1-y 称为“几率”(odds),表示样本是正例的相对可能性，对“几率”取对数得到 ln(y/1-y) 称为“对数几率”(log odds/logit)。由此可见Logistic回归实际是在用线性回归模型的预测结果去逼近真实标记的对数几率。 我们将 ln(y/1-y)中的y视为类后验概率 P( y = 1 | x ）于是将 对几率函数重写为 $$ ln\frac{p(y=1|x)}{p(y=0|x)}=w^{T}x+b $$ 在Logistic回归中，输出y=1的对数几率是输入x的线性函数，于是得到二项Logistic回归模型的条件概率： $$ p(y=1|x)=\frac{e^{w^{T}+b}}{1+e^{w^{T}+b}} $$ $$ p(y=0|x)=\frac{1}{1+e^{w^{T}+b}} $$ 对于任意给定的样本x，按照上两是计算得到 p(y=1|x) 和 P(y=0|x),比较两个条件概率的大小，将x分到概率较大的那一类。 考虑对样本进行分类的线性函数 \( w^{T}+b \)，它的值域为实数域，通过Logistic回归条件概率将线性函数转化成概率，线性函数的值越接近正无穷，概率值就越接近1;线性函数值越接近负无穷，概率值就越接近0，这就是对几率函数的性质，这样的模型就是Logistic回归。 Logistic Regression虽然名字是回归，但它是一种分类学习算法，它的优点是分类时直接对分类可能性直接建模，无需事先假设数据分布，避免了假设分布不准确带来的问题；它不是仅预测出类别，而是类别的近似概率预测，这对很多需要概率辅助的分类任务很有用；对率函数是任意可导的凸函数，有很好的的数学性质，现有的很多数值优化算法都可直接用于求解最优解。 2. 模型参数估计确定了分类器的函数形式，最终的问题就是如何确定最佳回归参数，向量 w 就是回归参数 ，使用极大似然估计来估计参数模型 w 和 b。 给定数据集 \( [(x_{1},y_{1}),(x_{2},y_{2}),…,(x_{m},y_{m})] \)，将权值向量和特征向量扩充，仍记为w，x。 $$ w = (w^{1},w^{2},…,w^{d},b) $$ $$ x = (x^{1},x^{2},…,x^{d},1) $$ 设 ： \( p_{1}(x;w)=p(y=1|x;w) \), \( p_{0}(x;w)=p(y=0|x;w) \) 似然函数为： $$ \prod_{i=0}^{m}p(x_{i};w)^{y_{i}}[1-p(x_{i};w)]^{1-y_{i}} $$ 对数似然函数为： $$ Ln(w) = \sum_{i=0}^{m}[y_{i}log(p(x_{i};w))+(1-y_{i})log(1-p(x_{i};w))]=\sum_{i=0}^{m}[y_{i}log(\frac{p(x_{i};w)}{1-p(x_{i};w)})+log(1-p(x_{i};w))]=\sum_{i=0}^{m}[y_{i}(w^{T}x)-log(1+e^{w^{T}x})] $$ 对Ln(w)求极大值，可以得到w的估计值。问题变成了对似然函数的最优化问题，Logistic回归常用的方法是梯度下降法和拟牛顿法。 3. 误差评估在logistic回归中明确了分类预测函数，其中\( z = w^{T}x \)是分类边界，即决策边界就是划分样本类别的边界，可以是点，可以是线，可以是面，“决策边界是预测分类函数的 \( y_{w}(x) \)的属性，不是训练集的属性，因为能够划分类别界限的是\( y_{w}(x) \)，而训练集是用来训练调节参数” 在前面确定了 logistic regression的分类原理和方法，接下来要要评估分类效果，即评估\( y_{i} \) 和 \( f(x_{i}) \) 之间的误差，通过均方误差来描述误差,误差评估的函数又称为代价函数，均方误差是回归任务中常用的度量标准： $$ J(w)=\frac{1}{2m}\sum_{i=1}^{m}(f(x_{i})-y_{i})^{2} $$ 我们的目标就是通过调节参数 w 使 J(w)能够达到最小， 4. 优化算法-梯度下降法Gradient Descent训练学习的目标就是不断调节参数w来使J(w)达到最小，通常使用梯度下降方法来调节w： $$w_{j}=w_{j}-\alpha \frac{\partial }{\partial w}J(w)$$ 梯度方向是函数值下降最为剧烈的方向。那么，沿着 J(w) 的梯度方向走，我们就能接近其最小值，或者极小值，从而接近更高的预测精度。学习率 α 是个相当玄乎的参数，其标识了沿梯度方向行进的速率，步子大了，很可能这一步就迈过了最小值。而步子小了，又会减缓我们找到最小值的速率。在实际编程中，学习率可以以 3 倍，10 倍这样进行取值尝试：α=0.001,0.003,0.01…0.3,1 4.1 批量梯度下降法(Batch Gradient Descent)对一个大小为m的训练集，w的迭代过程如下，重复迭代直到收敛： $$w_{j}=w_{j}+\alpha \frac{1}{m}\sum_{i=1}^{m}(y_{i}-f(x_{i}))x_{j}^{i}$$ 矩阵表示如下： $$w_{j}=w_{j}+\alpha \frac{1}{m}(y-f(x))^{T}x_{j}$$ 这种方法是批量梯度下降法，每次更新一次系数就要完整遍历一次数据集，如果训练集体积巨大，那么计算的复杂度太高。 4.2 随机梯度下降法(Stochastic Gradient Descent)由于批量梯度下降法计算开销太大，一种改进方法是一次仅用一个样本点来更新回归系数，该方法称为随机梯度下降算法。由于可以在新样本到来时对分类器进行增量式更新，因而随机梯度下降算法是一个在线学习算法。与“在线学习”相对应，一次处理所有数据被称作是“批处理”。 重复迭代直至收敛：for i = 1 to m$$ w_{j}=w_{j}+\alpha \frac{1}{m}(y_{i}-f(x_{i}))x_{j}^{i} $$]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-贝叶斯分类器]]></title>
    <url>%2F2019%2F01%2F24%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一. 概率知识 先验概率：先验概率（prior probability）是指根据以往经验和分析得到的概率 后验概率：后验概率,事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小后验概率就是条件概率 p(c|x) = p(x|c)p(c)/p(x) 贝叶斯概率引入先验知识和逻辑推理来处理不确定的命题 事情还没有发生，要求这件事情发生的可能性的大小，是先验概率。事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小，是后验概率。 先验概率的计算比较简单，没有使用贝叶斯公式；而后验概率的计算，要使用贝叶斯公式，而且在利用样本资料计算逻辑概率时，还要使用理论概率分布，需要更多的数理统计知识 二. 贝叶斯分类器基本原理1. 贝叶斯判定准则假设训练集为 T = {(x1,y1),(x2,y2),....,(xN,yN)}, 有 K 中标记类型，标记集 y = {c1,c1,...,cK} 定义损失函数 L(Y=ck,f(x)) 为将样本 x 分类错误所产生的损失 基于后验概率可以得到将样本 x 分类为 ci 产生的期望损失，即在样本x上的‘条件风险’ 注：期望损失也称为风险 对于分类准则f(x),总体风险为： 我们的任务就是找到一个分类准则使总体风险最小化。如果对于每个样本 x ，若f(x)能最小化条件风险 R(f(x)|x) ,则总体风险 R(f) 也将最小化。 贝叶斯判定准则： 为了最小化总体风险，只需在每个样本上选择那个能使条件风险R(c|x)最小的类别标记 上式为最小分类错误的贝叶斯最优分类器，即对每个样本x，选择能使后验概率 P(c | x)最大的类别标记，所以期望风险最小化准则就是后验概率最大化准则 2. 朴素贝叶斯2.1 朴素贝叶斯的原理经过上面的分析我们得到要想设计最优的贝叶斯判定准则来最小化决策风险，首先要获得的就是后验概率 P(c| x)。 由贝叶斯定理可以得到后验概率的计算公式： P( c ) 是先验该概率，P(x | c)是样本 x 相对于类标记 c 的条件概率，或称为似然概率 先验概率p(c)表示样本空间中各类样本所占的比例 类条件概率p(x | c)是样本x所有属性的联合概率，难以从有限的训练样本中直接估计得到，为了避开这个障碍简化问题，朴素贝叶斯法做了‘ 属性条件独立的 ’的假设，即对已知类别，假设所有属性相互独立。 这就是朴素贝叶斯的由来，朴素贝叶斯分类器中的’ 朴素 ‘的含义是： 所有属性特征相互独立同等重要。如果属性之间不相互独立就是贝叶斯网，一种经典的概率图模型。 有朴素贝叶斯分类器的的属性相互独立的假设条件可以将后验概率公式变为如下： 由于对于所有类别来说 P(x) 相同，因此可以得到贝叶斯判定准则如下，xi 为样本 x 第 i 个属性的值： 这就是朴素贝叶斯分类器的表达式。 所以朴素贝叶斯分类器学习的关键是如何求解 P(c) 和 P(x | c) 2.2 极大似然估计法 初学，目前还没有搞懂，先占个坑吧！ 在朴素贝叶斯算法中，分类器的训练学习意味着估计 P(c) 和 P(xi | c) ,可以使用极大似然估计法估计响应的概率，先验概率和条件概率的极大似然估计如下： 2.3 朴素贝叶斯分类算法朴素贝叶斯分类器的训练过程就是基于训练集来估计类先验概率 P(c) , 和每个属性的条件概率 P(xi | c) 算法实例 注：算法和实例图来自于《统计学方法》 2.5 贝叶斯估计实现算法中可能出现的问题 下溢出问题 训练朴素贝叶斯分类器之后，当有新样本时，会计算样本属于某个类别的概率 P(i) = P(ci) P(w0 | ci) P(w1 | ci) ... P(wk | ci) 在计算概率是由于太多很小的数相乘，程序会下溢出或者得不到正确答案(比如python程序在乘法中得到非常小的输时会四舍五入) 一种解决方法是对上面的乘法计算公式取对数将乘法转化为加法，ln(a*b) = ln(a) + ln(b),通过对数避免下溢出或四舍五入，采用对数进行处理不会有任何损失，不会影响最终结果(因为算法最后是通过比较各个类别概率大小决定样本的类别，而不是返回概率本身) 训练集中特征不存在，概率为零 在计算条件概率时，如果某个属性在训练集中没有和某个类同事出现，那么这个条件概率就为0，这样在最后计算样本属于该类的概率时不管其他属性如何，这个概率都为零，为了避免其他属性携带的信息被训练集中未出现的属性抹去，通常要进行“平滑”，常用拉普拉斯平滑。 贝叶斯估计 用极大似然估计会出现所要计算的概率为0的情况，会影响到后验概率的计算进而影响最终的判定结果，使分类产生偏差。解决这一问题的方法是使用贝叶斯估计代替极大似然估计，下面公式是先验概率和条件概率的贝叶斯估计： λ ≧ 0 ，当 λ = 0 时，就是最大似然估计；当 λ = 1 时， 就是拉普拉斯平滑 2.5 朴素贝叶斯分类器的实现方式 基于高斯分布模型 GuassianNB:高斯朴素贝叶斯算法是基于假设特征服从高斯分布 基于贝努利模型 MultinomialNB:用于实现服从多项式分布数据的朴素贝叶斯算法，常用于文本分类(文本数据经常用词向量来表示) 基于多项式模型 BernoulliNB:用于实现服从多变量贝努利分布数据的朴素贝叶斯算法，这种算法要求样本表示成二进制特征向量]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-模型评估与选择]]></title>
    <url>%2F2019%2F01%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%2F</url>
    <content type="text"><![CDATA[模型评估与选择一.误差与过拟合分类器分类错误的样本数占样本总数的比例为错误率(errorate)，E=m/n(m为分类错误的总样本数，n为总样本数），分类的精度(accuracy) P=(1-E)x100% 学习器实际预测值和样本真实值之间的差异为“误差” 训练误差/经验误差：学习器在训练数据上的误差 泛华误差：学习器在新样本上的误差 我们希望得到的是泛化误差尽可能小的学习器，在通过训练数据训练学习器的过程中是在尽可能的最小化训练误差。有时学习器的训练误差非常小，但当遇到新的样本时表现的却不好。因此为了的当泛华能力比较强的学习器，只能让学习器从训练样本中学习到尽可能适应所有样本的普遍规律，要尽可能的学习所有训练样本的共性，这样学习器在遇到引得样本时才会做出正确的判断。通过训练数据训练出的学习器会有两个问题： 过拟合:学习器学习能力过于强大把训练数据学习的太好了，可能把训练样本自身的特点当做了所有样本的一般性质，导致过拟合，是学习器的泛化能力降低。过拟合无法避免，只能尽量减小。 欠拟合：和过拟合相对应，有学习器学习能力过低，对训练样本的一般性质没有学好，欠拟合容易克服，关键的问题是过拟合 二.模型评估和选择方法不同的机器学习算法，同一算法的不同参数配置都是不同的模型，机器学习的模型选择就是对模型的泛化误差进行评估选择泛化误差最小的模型。 通过训练数据得到的学习器，将学习器在在测试数据上的测试误差作为学习器的泛华误差。 训练集与测试集要有如下关系：训练集和测试集都是从样本真实分布中独立同分布采样而得，他们应该尽可能互斥，测试样本尽量不出现在训练样本中。 假设包含m个样例的样本集D={(x1,y1),(x2,y2),...,(xm,ym)},如何划分训练集和测试集的常用方法如下： 留出法直接将样本集D划分为两个互斥的集合D= S U T,S作为训练集，T作为测试集估计分类器的泛化误差。 训练集和测试集的划分要保持数据分布的一致性，避免数据划分引入偏差影响结果。比如在分类任务中要保持两个集合中样本的类别别比例相似。 在使用留出法时不同的划分会得到不同的模型，单次留出法得到的结果往往不够稳定可靠，一般采用若干次留出法随机划分，重复试验评估后取平均值作为留出法的评估结果。并且常将样本集的2/3 ~ 4/5的样本用于训练，剩余的用于测试。 交叉验证法 将样本集D划分为k个大小相似的互斥子集，D=D1 U D2 U…U Dk,每个子集尽可能保持数据分布的一致性， 每次使用k-1个子集的并集作为训练集，剩余的一个子集作为测试集， 这样可以得到k组训练/测试集，进行k次实验，得到的是k次测试结果的均值 交叉验证法评估结果的稳定性很大程度取决于k的取值，因此也称为“k折交叉”验证，k常取10，其他常用值为5，20等。 交叉验证法的特例：留一法(LOO)，k=m 留一法的优点：留一法不受随机样本划分方式的影响，因为m个样本只有唯一的方式划分为m个子集，每个子集一个样本，在多数情况下，留一法中被实际评估的模型和期望评估的用D训练出的模型很相似，评估结果往往被认为很准确。 留一法的缺点：数据集比较大时，计算复杂度高，开销非常大。 自助法自助法采用又放回采样方法，原始样本集D，每次从D中随机挑选一个样本，拷贝到D’中，并放回D中，重复每次，就得到了包含m个样本的数据集D’。通过采样法，初始数据集D中有约36.8%的样本未出现在D’中，D’作为训练集，D/D’作为测试集 总结： 在初始数据集比较充足时，留出法和交叉验证法更常用一些 在数据集比较小，难以有效划分训练/测试集是使用自助法 对于数据集小且可有效划分的时候最好使用留一法来进行划分，因为这种方法最为准确 数据集的分类及作用 训练集 training set： 用于训练模型 验证集 validation set： 用于模型选择 测试集 test set： 用于最终对学习方法的评估 调参机器学习中的两类参数： 算法的参数/超参数 模型的参数 算法的参数往往在实数范围内，因此对每种参数配置都训练出模型是不可能的，现实中往往对每个参数选定一个范围和步长值，这样选定的参数不是最佳的，但这是计算开销和性能估计之间进行这种的结果。调参往往很苦难，工程量大。 三.性能度量衡量模型泛化能力的评价标准就是性能度量，对比不同模型时使用不同的性能度量往往得到不同的评判结果。所以模型好坏是相对的，不仅取决于算法和数据，还决定于任务需求。 1.错误率和精度错误率和精度是分类任务中最常用的两个性能度量 2.查准率，查全率，F1错误率和精度有时不能满足所有的任务度量需求，对于某些问题不光要分类正确，还要求其他更进一步的需求，因此精度不能满足评估需求。比如挑西瓜，我们更关心挑出的西瓜有多少好瓜，或者有多少好瓜被挑选出来了，为了衡量这种指标，引入了查准率和查全率，查准率( precision , 注：分类精度为 accuracy)亦称准确率，查全率(recall)亦称召回率。 对于二分类问题，样本真实类别和分类器预测类别有四种组合： TP 真正例(true positive) FP 假正例(false positive) FN 假反例(false negative) TN 真反例(true negative） TP+FP+FN+TN = 样本总数 查准率：它是相对我们预测结果而言，预测的正例中有多少是真正的正例 查全率：它是相对测试样本而言，样本中的正例有多少被预测出来 查准率和查全率往往是矛盾的，查全率高时，查准率会偏低；二查准率高时，查全率就会偏低。只有在一些简单任务中这两个指标才会都很高 设计了“PR曲线”来综合考虑查全率、查准率的性能度量 在P-R曲线中，如果一个分类器的曲线完全包住另一个分类器的曲线，那么前者的性能优于后者，如果俩个分类器的曲线相交，则很难判断性能的优劣，需要其他指标来衡量。 平衡点(BEP)：曲线查全率等于查准率的点，过于简单 F1：是基于查全率和查准率的调和平均，公式如下： 其中Fβ是F1的更一般形式，因为在实际中不同的应用对查全率和查准率的要求不一样，所有 Fβ 是加权调和平均。β=1 时就是 F1； β&gt;1 时查全率影响更大；0&lt;β&lt;1 时，查准率影响更大些。 3. ROC和AUC3.1 ROCROC是一种度量分类器分类好坏的标准，评估分类器性能的标准有很多，但不同任务不同需求对好坏的标准并不一样。使用最多的标准就是分类精度，但有些现实问题中 accuracy 不能很好地评估分类器的性能。eg. 测试样本中有A类样本90个，B 类样本10个。分类器 C1 把所有的测试样本都分成了A类;分类器 C2 把A类的90个样本分对了70个，B类的10个样本分对了5个;则C1的分类精度为 90%，C2的分类精度为75% 。但是，显然C2更有用些，而且不同问题中分类错误的代价不一样。 很多学习器为测试样本产生一个实值或概率预测，将这个预测值和分类阈值threshol进行比较，大于阈值分为正例，否则分为反例。这个阈值直接决定了分类器的性能即泛化能力。根据分类器对测试样本的预测结果对所有的测试样本进行排序，分类就是在这个排序中选取某个截断点，截断点之前为正例，截断点之后为反例。根据不同的任务需求选取不同的截断点，比如如果更重视查准率，那么就选择的截断点更靠前，如果更重视查全率，选择的截断点更靠后的位置。因此排序质量的好坏，表示综合考虑分类器在不同任务下的“期望泛化性能”的好坏，ROC曲线就是从‘期望性能’的角度评估分类器的性能。 ROC全称是“受试者工作特征”ROC横坐标x为‘真正例率’ TRP，纵坐标y为‘假正利率’ FRP TRP = TP / (TP + FN) 真正例率表示原测试样本中正例被分为正例的比例 FPR = FP /（TN + FP） 假正例率表示原测试样本中反例被分为正例的比例 根据分类器的预测结果对测试样本进行排序，按照此顺序逐个把每个样本作为截断点(阈值)进行预测，每次得到两个指标值，得到ROC曲线，所以ROC体现的是分类器期望性能。 假设在一个二分类中，有正例和反例，那么对于分类结果当然是越多的正例被分出来更好，就是横坐标TRP越大越好，希望误分的反例越少越好，即FPR越小越好。放在具体领域来理解上述两个指标。如在医学诊断中，判断有病的样本。那么尽量把有病的揪出来是主要任务，也就是第一个指标TPR，要越高越好。而把没病的样本误诊为有病的，也就是第二个指标FPR，要越低越好。 类似于将预测结果排序得到分类结果统计图，如下图，左侧为负类分类结果统计图，右侧为正类分类结果统计图，两个图重叠的不跟越少那么分类器的分类性能越好，重叠的越多分类器的性能会越差，当有重叠时选择合适的阈值直接决定了分类器的分类能力。 如下图所示:不同分类性能的分类器对应的ROC曲线，分类能力越好的分类器的ROC曲线越接近左上角 3.2 AUC通过ROC曲线可以对不同分类器进行比较，如果一个分类器完全包住另一个分类器，那么前者的性能一定优于后者，若果曲线之间相交，就要比较ROC曲线下面的面积，即 AUC(Area Under ROC Cure) ，AUC量化了ROC曲线表示的分类器的分类能力。 3.2.1 AUC的含义 The AUC value is equivalent to the probability that a randomly chosen positive example is ranked higher than a randomly chosen negative example. 首先AUC值是一个概率值，当你随机挑选一个正样本以及一个负样本，当前的分类算法根据计算得到的Score值将这个正样本排在负样本前面的概率就是AUC值。当然，AUC值越大，当前的分类算法越有可能将正样本排在负样本前面，即能够更好的分类 AUC值为ROC曲线所覆盖的区域面积，显然，AUC越大，分类器分类效果越好。 AUC = 1，是完美分类器，采用这个预测模型时，不管设定什么阈值都能得出完美预测。 0.5 &lt; AUC &lt; 1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。 AUC = 0.5，随机猜测，模型没有预测价值。 AUC &lt; 0.5，比随机猜测还差；但只要总是反预测而行，就优于随机猜测。 3.2.2 AUC的计算方式4. 代价敏感错误率和代价曲线在现实任务中，不同错误所造成的后果并不一样，代价不相同。例如将健康患者诊断为患病，会增加后续检查的麻烦，而将患病者诊断为健康，后果核能是错失拯救生命的机会，后者误判的代价很明显远大于前者误判。 以二分类为例的代价矩阵如下 假设给定 m+ 个正例和 m- 个负例，D+ 和 D- 分别代表正、反例集合 ，则代价敏感错误率为 在非均等代价下，“代价曲线”可以反映分类器的期望总体代价。x坐标为正例概率代价，如下公式，p为样例为正例的概率。纵轴y为归一化代价FNR为假正例率，FPR为假反例率，FPR=1-FNR 。 代价曲线如下 ，ROC曲线的每个点代表代价平面上的一条线段。 5. 偏差和方差对算法除了通过实验评估学习器的泛化性能，还要分析为神魔有这样的性能，偏差方差分解是解释算法泛化性能的重要工具 5.1 偏差-方差分解那么如何理解方差和偏差呢？ 如下图经典的靶心图，假设红心是最正确的预测值就是样本的真实分类，二蓝色的点为模型对样本的输出值。由图可以观察到左侧两个靶子上的样本蓝点/预测值比较集中方差较小，右侧两个靶子的蓝点相对很分散则方差较大；从横向来看，上面的两个蓝色预测值比较集中的靠近靶心，所以偏差小，二下面的两个靶子中的蓝色点离靶心比较远则偏差比较大。 以回归为例，算法的期望预测为： 方差： 噪声为样本在测试集的实际标记和真实标记的偏差 偏差是期望预测和真实标记的误差 对算法的泛化误差分解 分解结果：泛化误差可以分解为偏差、方差和噪声 注：这个分解形式仅在基于均方误差的回归任务中推导出。 偏差度量了学习算法的期望预测与真实结果的偏离程度，刻画了算法本身的拟合能力 方差度量了同样大小的训练集的变动所导致的的学习性能的变化，刻画了数据扰动所造成的影响 噪声表达了当前任务上任何学习算法所能达到的期望泛化误差的下界。刻画了问题的本身难度 所以泛化性能是由算法的能力、数据的充分性和任务本身难度所共同决定的。 5.2 偏差-方差窘境一般情况下，偏差和方差是有冲突的，这就是偏差方差窘境，如下图所示 对于一个特定的任务，当训练不足时，分类器的拟合能力不足，存在欠拟合，训练数据的扰动不足以使分类器发生显著的变化，这时偏差主导着泛化误差(总体误差)；当加强训练程度时，分类器拟合能力逐渐增强，偏差逐渐变小不再主导误差，训练数据发生的扰动逐渐被学习器学到(即通过不同训练集得到的分类器的拟合能力不相同)，这时方差主导了泛化误差；当训练程度十分充足时，分类器的拟合能力非常的强，训练数据的轻微扰动都会导致分类器发生显著的变化，如果训练数据局部特性、非数据集一般特性被分类器学习到，则发生了过拟合。]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-模型评估与选择]]></title>
    <url>%2F2019%2F01%2F16%2F%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[模型评估与选择一.误差与过拟合分类器分类错误的样本数占样本总数的比例为错误率(errorate)，E=m/n(m为分类错误的总样本数，n为总样本数），分类的精度(accuracy) P=(1-E)x100% 学习器实际预测值和样本真实值之间的差异为“误差” 训练误差/经验误差：学习器在训练数据上的误差 泛华误差：学习器在新样本上的误差 我们希望得到的是泛化误差尽可能小的学习器，在通过训练数据训练学习器的过程中是在尽可能的最小化训练误差。有时学习器的训练误差非常小，但当遇到新的样本时表现的却不好。因此为了的当泛华能力比较强的学习器，只能让学习器从训练样本中学习到尽可能适应所有样本的普遍规律，要尽可能的学习所有训练样本的共性，这样学习器在遇到引得样本时才会做出正确的判断。通过训练数据训练出的学习器会有两个问题： 过拟合:学习器学习能力过于强大把训练数据学习的太好了，可能把训练样本自身的特点当做了所有样本的一般性质，导致过拟合，是学习器的泛化能力降低。过拟合无法避免，只能尽量减小。 欠拟合：和过拟合相对应，有学习器学习能力过低，对训练样本的一般性质没有学好，欠拟合容易克服，关键的问题是过拟合 二.模型评估和选择方法不同的机器学习算法，同一算法的不同参数配置都是不同的模型，机器学习的模型选择就是对模型的泛化误差进行评估选择泛化误差最小的模型。 通过训练数据得到的学习器，将学习器在在测试数据上的测试误差作为学习器的泛华误差。 训练集与测试集要有如下关系：训练集和测试集都是从样本真实分布中独立同分布采样而得，他们应该尽可能互斥，测试样本尽量不出现在训练样本中。 假设包含m个样例的样本集D={(x1,y1),(x2,y2),...,(xm,ym)},如何划分训练集和测试集的常用方法如下： 留出法直接将样本集D划分为两个互斥的集合D= S U T,S作为训练集，T作为测试集估计分类器的泛化误差。 训练集和测试集的划分要保持数据分布的一致性，避免数据划分引入偏差影响结果。比如在分类任务中要保持两个集合中样本的类别别比例相似。 在使用留出法时不同的划分会得到不同的模型，单次留出法得到的结果往往不够稳定可靠，一般采用若干次留出法随机划分，重复试验评估后取平均值作为留出法的评估结果。并且常将样本集的2/3 ~ 4/5的样本用于训练，剩余的用于测试。 交叉验证法 将样本集D划分为k个大小相似的互斥子集，D=D1 U D2 U…U Dk,每个子集尽可能保持数据分布的一致性， 每次使用k-1个子集的并集作为训练集，剩余的一个子集作为测试集， 这样可以得到k组训练/测试集，进行k次实验，得到的是k次测试结果的均值 交叉验证法评估结果的稳定性很大程度取决于k的取值，因此也称为“k折交叉”验证，k常取10，其他常用值为5，20等。 交叉验证法的特例：留一法(LOO)，k=m 留一法的优点：留一法不受随机样本划分方式的影响，因为m个样本只有唯一的方式划分为m个子集，每个子集一个样本，在多数情况下，留一法中被实际评估的模型和期望评估的用D训练出的模型很相似，评估结果往往被认为很准确。 留一法的缺点：数据集比较大时，计算复杂度高，开销非常大。 自助法自助法采用又放回采样方法，原始样本集D，每次从D中随机挑选一个样本，拷贝到D’中，并放回D中，重复每次，就得到了包含m个样本的数据集D’。通过采样法，初始数据集D中有约36.8%的样本未出现在D’中，D’作为训练集，D/D’作为测试集 总结： 在初始数据集比较充足时，留出法和交叉验证法更常用一些 在数据集比较小，难以有效划分训练/测试集是使用自助法 对于数据集小且可有效划分的时候最好使用留一法来进行划分，因为这种方法最为准确 数据集的分类及作用 训练集 training set： 用于训练模型 验证集 validation set： 用于模型选择 测试集 test set： 用于最终对学习方法的评估 调参机器学习中的两类参数： 算法的参数/超参数 模型的参数 算法的参数往往在实数范围内，因此对每种参数配置都训练出模型是不可能的，现实中往往对每个参数选定一个范围和步长值，这样选定的参数不是最佳的，但这是计算开销和性能估计之间进行这种的结果。调参往往很苦难，工程量大。 三.性能度量衡量模型泛化能力的评价标准就是性能度量，对比不同模型时使用不同的性能度量往往得到不同的评判结果。所以模型好坏是相对的，不仅取决于算法和数据，还决定于任务需求。 1.错误率和精度错误率和精度是分类任务中最常用的两个性能度量 2.查准率，查全率，F1错误率和精度有时不能满足所有的任务度量需求，对于某些问题不光要分类正确，还要求其他更进一步的需求，因此精度不能满足评估需求。比如挑西瓜，我们更关心挑出的西瓜有多少好瓜，或者有多少好瓜被挑选出来了，为了衡量这种指标，引入了查准率和查全率，查准率( precision , 注：分类精度为 accuracy)亦称准确率，查全率(recall)亦称召回率。 对于二分类问题，样本真实类别和分类器预测类别有四种组合： TP 真正例(true positive) FP 假正例(false positive) FN 假反例(false negative) TN 真反例(true negative） TP+FP+FN+TN = 样本总数 查准率：它是相对我们预测结果而言，预测的正例中有多少是真正的正例 查全率：它是相对测试样本而言，样本中的正例有多少被预测出来 查准率和查全率往往是矛盾的，查全率高时，查准率会偏低；二查准率高时，查全率就会偏低。只有在一些简单任务中这两个指标才会都很高 设计了“PR曲线”来综合考虑查全率、查准率的性能度量 在P-R曲线中，如果一个分类器的曲线完全包住另一个分类器的曲线，那么前者的性能优于后者，如果俩个分类器的曲线相交，则很难判断性能的优劣，需要其他指标来衡量。 平衡点(BEP)：曲线查全率等于查准率的点，过于简单 F1：是基于查全率和查准率的调和平均，公式如下： 其中Fβ是F1的更一般形式，因为在实际中不同的应用对查全率和查准率的要求不一样，所有 Fβ 是加权调和平均。β=1 时就是 F1； β&gt;1 时查全率影响更大；0&lt;β&lt;1 时，查准率影响更大些。 3. ROC和AUC3.1 ROCROC是一种度量分类器分类好坏的标准，评估分类器性能的标准有很多，但不同任务不同需求对好坏的标准并不一样。使用最多的标准就是分类精度，但有些现实问题中 accuracy 不能很好地评估分类器的性能。eg. 测试样本中有A类样本90个，B 类样本10个。分类器 C1 把所有的测试样本都分成了A类;分类器 C2 把A类的90个样本分对了70个，B类的10个样本分对了5个;则C1的分类精度为 90%，C2的分类精度为75% 。但是，显然C2更有用些，而且不同问题中分类错误的代价不一样。 很多学习器为测试样本产生一个实值或概率预测，将这个预测值和分类阈值threshol进行比较，大于阈值分为正例，否则分为反例。这个阈值直接决定了分类器的性能即泛化能力。根据分类器对测试样本的预测结果对所有的测试样本进行排序，分类就是在这个排序中选取某个截断点，截断点之前为正例，截断点之后为反例。根据不同的任务需求选取不同的截断点，比如如果更重视查准率，那么就选择的截断点更靠前，如果更重视查全率，选择的截断点更靠后的位置。因此排序质量的好坏，表示综合考虑分类器在不同任务下的“期望泛化性能”的好坏，ROC曲线就是从‘期望性能’的角度评估分类器的性能。 ROC全称是“受试者工作特征”ROC横坐标x为‘真正例率’ TRP，纵坐标y为‘假正利率’ FRP TRP = TP / (TP + FN) 真正例率表示原测试样本中正例被分为正例的比例 FPR = FP /（TN + FP） 假正例率表示原测试样本中反例被分为正例的比例 根据分类器的预测结果对测试样本进行排序，按照此顺序逐个把每个样本作为截断点(阈值)进行预测，每次得到两个指标值，得到ROC曲线，所以ROC体现的是分类器期望性能。 假设在一个二分类中，有正例和反例，那么对于分类结果当然是越多的正例被分出来更好，就是横坐标TRP越大越好，希望误分的反例越少越好，即FPR越小越好。放在具体领域来理解上述两个指标。如在医学诊断中，判断有病的样本。那么尽量把有病的揪出来是主要任务，也就是第一个指标TPR，要越高越好。而把没病的样本误诊为有病的，也就是第二个指标FPR，要越低越好。 类似于将预测结果排序得到分类结果统计图，如下图，左侧为负类分类结果统计图，右侧为正类分类结果统计图，两个图重叠的不跟越少那么分类器的分类性能越好，重叠的越多分类器的性能会越差，当有重叠时选择合适的阈值直接决定了分类器的分类能力。 如下图所示:不同分类性能的分类器对应的ROC曲线，分类能力越好的分类器的ROC曲线越接近左上角 3.2 AUC通过ROC曲线可以对不同分类器进行比较，如果一个分类器完全包住另一个分类器，那么前者的性能一定优于后者，若果曲线之间相交，就要比较ROC曲线下面的面积，即 AUC(Area Under ROC Cure) ，AUC量化了ROC曲线表示的分类器的分类能力。 3.2.1 AUC的含义 The AUC value is equivalent to the probability that a randomly chosen positive example is ranked higher than a randomly chosen negative example. 首先AUC值是一个概率值，当你随机挑选一个正样本以及一个负样本，当前的分类算法根据计算得到的Score值将这个正样本排在负样本前面的概率就是AUC值。当然，AUC值越大，当前的分类算法越有可能将正样本排在负样本前面，即能够更好的分类 AUC值为ROC曲线所覆盖的区域面积，显然，AUC越大，分类器分类效果越好。 AUC = 1，是完美分类器，采用这个预测模型时，不管设定什么阈值都能得出完美预测。 0.5 &lt; AUC &lt; 1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。 AUC = 0.5，随机猜测，模型没有预测价值。 AUC &lt; 0.5，比随机猜测还差；但只要总是反预测而行，就优于随机猜测。 3.2.2 AUC的计算方式4. 代价敏感错误率和代价曲线在现实任务中，不同错误所造成的后果并不一样，代价不相同。例如将健康患者诊断为患病，会增加后续检查的麻烦，而将患病者诊断为健康，后果核能是错失拯救生命的机会，后者误判的代价很明显远大于前者误判。 以二分类为例的代价矩阵如下 假设给定 m+ 个正例和 m- 个负例，D+ 和 D- 分别代表正、反例集合 ，则代价敏感错误率为 在非均等代价下，“代价曲线”可以反映分类器的期望总体代价。x坐标为正例概率代价，如下公式，p为样例为正例的概率。纵轴y为归一化代价FNR为假正例率，FPR为假反例率，FPR=1-FNR 。 代价曲线如下 ，ROC曲线的每个点代表代价平面上的一条线段。 5. 偏差和方差对算法除了通过实验评估学习器的泛化性能，还要分析为神魔有这样的性能，偏差方差分解是解释算法泛化性能的重要工具 5.1 偏差-方差分解那么如何理解方差和偏差呢？ 如下图经典的靶心图，假设红心是最正确的预测值就是样本的真实分类，二蓝色的点为模型对样本的输出值。由图可以观察到左侧两个靶子上的样本蓝点/预测值比较集中方差较小，右侧两个靶子的蓝点相对很分散则方差较大；从横向来看，上面的两个蓝色预测值比较集中的靠近靶心，所以偏差小，二下面的两个靶子中的蓝色点离靶心比较远则偏差比较大。 以回归为例，算法的期望预测为： 方差： 噪声为样本在测试集的实际标记和真实标记的偏差 偏差是期望预测和真实标记的误差 对算法的泛化误差分解 分解结果：泛化误差可以分解为偏差、方差和噪声 注：这个分解形式仅在基于均方误差的回归任务中推导出。 偏差度量了学习算法的期望预测与真实结果的偏离程度，刻画了算法本身的拟合能力 方差度量了同样大小的训练集的变动所导致的的学习性能的变化，刻画了数据扰动所造成的影响 噪声表达了当前任务上任何学习算法所能达到的期望泛化误差的下界。刻画了问题的本身难度 所以泛化性能是由算法的能力、数据的充分性和任务本身难度所共同决定的。 5.2 偏差-方差窘境一般情况下，偏差和方差是有冲突的，这就是偏差方差窘境，如下图所示 对于一个特定的任务，当训练不足时，分类器的拟合能力不足，存在欠拟合，训练数据的扰动不足以使分类器发生显著的变化，这时偏差主导着泛化误差(总体误差)；当加强训练程度时，分类器拟合能力逐渐增强，偏差逐渐变小不再主导误差，训练数据发生的扰动逐渐被学习器学到(即通过不同训练集得到的分类器的拟合能力不相同)，这时方差主导了泛化误差；当训练程度十分充足时，分类器的拟合能力非常的强，训练数据的轻微扰动都会导致分类器发生显著的变化，如果训练数据局部特性、非数据集一般特性被分类器学习到，则发生了过拟合。]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-IO概述]]></title>
    <url>%2F2018%2F12%2F13%2FJava-IO%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Java IO概述Java IO是一套提供输入输出（读写数据）功能的API，提供了java.io 包 Java IO的构成概述java.io包中主要包括了五个类和一个接口： File:文件类，用于文件的管理 InputStream:字节输入流类，二进制格式操作，基于字节的输入，是所有字节输入流类的父类 OutputStream:字节输出流类，二进制格式操作，基于字节的输出，是所有字节输出流类的父类 Reader:字符输入流类，文件格式操作，基于字符的输入操作，是所有字符输入流类的父类 Writer:字符输出流类，文件格式操作，基于字符的输出操作，是所有字符输入流类的父类 RandomAccessFile:可以在文件的任意位置进行存取操作 Serializable: 下面是一张通过输入、输出、基于字节或者字符、以及其他比如缓冲、解析之类的特定用途划分的大部分Java IO类的表格 Java IO关注的是从原始数据源读取数据输出原始数据到目标介质 ，主要的数据源和目标介质有 文件 管道 Java中的管道是为运行在同一个JVM中的两个线程提供通信能力 在Java中使用管道时，通信的双方应该是运行在同一进程中的不同线程 网络连接 内存缓存 System.in,System.out,System.error(Java标准的输入输出) 一个程序需要InputStream或者Reader从数据源读取数据，需要OutputStream或者Writer将数据写入到目标媒介中 Java IO的分类根据数据流向： 输入流-读取数据 输出流-写数据 根据处理的数据类型： 字节流：数据流中最小的数据单元是字节 字符流：数据流中最小的数据单元是字符，Java中的字符是Unicode编码，一个字符占用两个字节，因为数据编码的不同，而有了对字符进行高效操作的流对象，本质其实就是基于字节流读取时，去查了指定的码表。 注解： 采用数据流的目的是使输入输出独立于设备，不用关心设备 对于程序来说，输出流是往存储介质或数据通道写入数据，而输入流是从存储介质或数据通道中读取数据 只读或只写，每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流 File类-文件管理File类用于管理文件的类，包括创建文件，删除文件，获取文件路径、文件名等，做判断过滤等功能 构造方法 public File(String pathname) 通过将给定的路径名字符串转换为抽象路径名来创建新的File实例 public File(String parent,String child) 从父路径名字符串和子路径名字符串创建新的File实例 public File(File parent,String child) 从父抽象路径名和子路径名字符串创建新的File实例 成员方法： 创建功能： public boolean createNewFile() throws IOException 当且仅当具有该名称的文件尚不存在时，原子地创建一个由该抽象路径名命名的新的空文件 public boolean mkdir() 创建文件夹 public boolean mkdirs() 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目 删除功能： public boolean delete() 删除由此抽象路径名表示的文件或目录 重命名： public boolean renameTo(File dest) 判断： public boolean isDirectory() 判断是否是目录 public boolean isFile() 判断是否是文件 public boolean exists() 判断是否存在 public boolean canRead() 判断是否可读 public boolean canWrite() 判断是否可写 public boolean isHidden() 判断是否隐藏 获取： public String getAbsolutePath() 获取绝对路径 public String getPath() 获取相对路径 public String getName() 获取名称 public long length() 获取长度，字节数 public long lastModified() 获取最后一次修改时间 public String[] list() 获取指定目录下所有文件夹或文件名称的数组 public File[] listFiles() 获取指定目录下所有文件夹或文件的File的数组 文件名称过滤器FilenameFilter public String[] list(FilenameFilter filter) public File[] listFiles(FilenameFilter filter) 字节流InputStream InputStream FileInputStream BufferedInputStream]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb-Http与Servlet概述]]></title>
    <url>%2F2018%2F12%2F07%2FHttp%E4%B8%8EServlet%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Servlet Servlet的概述 Servlet的定义及其作用：Servlet是运行在Web服务器(eg.Tomcat)上的java程序，通过HTTP协议接收好响应来自Web客户端的请求。 Servlet的实现 Servlet接口定义了初始化servlet的方法、为请求提供服务的方法和从服务器移除servlet的方法,这些方法成为生命周期方法 Servlet实现方法：定义一个类implements Servlet 或者 Extends GenericServlet/HttpServlet(最常用) Servlet中的生命周期方法是按以下顺序调用的： 构造Servlet，使用init方法初始化 创建Servlet实例的时候回执行init方法 一个Servlet只会初始化一次，init方法只会被执行一次 处理客户端的请求对service方法的调用 当客户端有请求的时候回调用service方法 一次请求对应着service的执行，所以它可以被多次执行 从服务器中一处Servlet，并用destroy销毁它，最后垃圾回收终止它 Servlet销毁时会执行： 当Servlet从服务器移除时执行； 当关闭服务器时执行 下面是实现了Servlet的代码： 12345678public class Sever_servlet extends HttpServlet&#123; @Override public void init(ServletConfig arg0) throws ServletException &#123;&#125; @Override public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException &#123;&#125; @Override public void destroy() &#123;&#125;&#125; Servlet的配置 在一个Web工程中当我们实现了一个Servlet的时候，我们应该在Web工程中将这的Servlet加入到配置文件Web。xml文件中，配置Servlet。 下面是在web.xml天剑一个Servlet的写法 获取Servlet配置信息 //1. 得到servlet配置对象 专门用于在配置servlet的信息 ServletConfig config = getServletConfig(); //获取到的是配置servlet里面servlet-name 的文本内容 String servletName = config.getServletName(); System.out.println(&quot;servletName=&quot;+servletName); //2. 可以获取具体的某一个参数。 String address = config.getInitParameter(&quot;address&quot;); System.out.println(&quot;address=&quot;+address); //3. 获取所有的参数名称 Enumeration&lt;String&gt; names = config.getInitParameterNames(); //遍历取出所有的参数名称 while (names.hasMoreElements()) { String key = (String) names.nextElement(); String value = config.getInitParameter(key); System.out.println(&quot;key===&quot;+key + &quot; value=&quot;+value); } ServletContext 每个web工程都只有一个ServletContext对象。 在同一个Web工程中不管是哪个servlet，获取到的这个类的对象都是同一个 ServletContext主要有三个作用： 获取Web工程的全局配置参数 获得Web工程中的资源（properities） 存取数据，Servlet间共享数据，即域对象 获取全局配置参数在web.xml文件中有定义全局参数，每个Servlet都可以访问，而Servlet内部的参数只可以由自己访 icon 通过调用getServletContext()方法可以获得Web工程的ServletContext对象，通过这个对象来访问全局参数 icon 获取Web工程中的资源Web工程里的properities文件资源 //获取Web工程的ServletContext对象 ServletContext context=getServletContext(); //获得对去加载读取资源的对象property Properities property=new Properities(); //获取输入流，就是资源 InputStream in=null; //加载资源并读取 property.load(in); String city=property.getProperty(); 这里的关键是如何读入资源，获得资源的输入流InputStream，有三种方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//获得Servlet对象ServletContext context=getServletContext();Properties properity=new Properties();//方法一：通过ServletContext的getRealpath()方法获得资源输入流，只需要传入资源的相对路径/* * getRealPath("")这个得到的是运行在服务器TomCat中Web项目的根路径 * D:\tomcat\apache-tomcat-7.0.52\apache-tomcat-7.0.52\wtpwebapps\Web\ * getRealPath("file/file.properties")这个会将传入的相对路径拼接到上面的项目根路径的后面 * D:\tomcat\apache-tomcat-7.0.52\apache-tomcat-7.0.52\wtpwebapps\Web\file/file.properties* */String path= context.getRealPath("file/file.properties");InputStream in=new FileInputStream(path);//方式二：通过context.getResourceAsStream("file/file.properties")直接过得资源的输入流InputStream in=context.getResourceAsStream("file/file.properties");//方式三：通过类加载器直接获得资源的输入流InputStream in=this.getClass().getClassLoader().getResourceAsStream("../../file/file.properities");properity.load(in);String city=properity.getProperty("city");System.out.println("city:"+city); ``` ## HttpServletRequest ### 获取客户端的信息&gt;HttpServletRequest中封装了客户端所有的信息 &gt;通过request可以获得客户端请求头的全部信息和客户端传递的参数```javapublic class Request extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //取出客户端请求里面的所有头信息(名称-值) Enumeration&lt;String&gt;headers=request.getHeaderNames(); while(headers.hasMoreElements()) &#123; String name=headers.nextElement(); String value=request.getHeader(name); System.out.println(name+":"+value); &#125; //获得客户端上传的参数 //1.利用枚举方法获得参数 Enumeration&lt;String&gt;parameter=request.getParameterNames(); while(parameter.hasMoreElements()) &#123; String name=parameter.nextElement(); String value=request.getParameter(name); System.out.println(name+":"+value); &#125; //2.利用Map来获取参数 Map&lt;String,String[]&gt;parameter=request.getParameterMap(); Set&lt;String&gt; paras=parameter.keySet(); Iterator&lt;String&gt; it=paras.iterator(); while(it.hasNext()) &#123; String name=it.next(); String value=parameter.get(name)[0]; System.out.println(name+":"+value); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;&#125;&#125; 中文乱码 当客户端提交的数据中有中文的时候会出现乱码的现象，Get和POST方式的解决方法不同 Get请求方式 由于Get请求方式上传提交的数据是在Url地址中的，所以服务器接收的时候已经过编码了，服务器端直接获得的数据是乱码的 //tomcat收到了这批数据，getParameter 默认使用ISO-8859-1去解码 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); //先让文字回到ISO-8859-1对应的字节数组 ， 然后再按utf-8组拼字符串 username = new String(username.getBytes(&quot;ISO-8859-1&quot;) , &quot;UTF-8&quot;); System.out.println(&quot;userName=&quot;+username+&quot;==password=&quot;+password); 直接在tomcat里面做配置，以后get请求过来的数据永远都是用UTF-8编码。 可以在tomcat里面做设置处理 conf/server.xml 加上URIEncoding=&quot;utf-8&quot; &lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt; Post请求 在getParameter之前加入这行代码，是在设置请求体的编码方式 request.setCharacterEncoding(&quot;UTF-8&quot;); HttpServletResponse 它的作用是响应返回数据给客户端输出数据到页面上 //以字符流的方式写数据 response.getWriter().write(&quot;&lt;h1&gt;hello response...&lt;/h1&gt;&quot;); //以字节流的方式写数据 response.getOutputStream().write(&quot;hello&quot;.getBytes()); 中文乱码 以字符流输出 response.getWriter() //1. 指定输出到客户端的时候，这些文字使用UTF-8编码 response.setCharacterEncoding(&quot;UTF-8&quot;); //2. 直接规定浏览器看这份数据的时候，使用什么编码来看。 response.setHeader(&quot;Content-Type&quot;, &quot;text/html; charset=UTF-8&quot;); response.getWriter().write(&quot;北京&quot;); 以字节流输出 response.getOutputStream() //1. 指定浏览器看这份数据使用的码表 response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;); //2. 指定输出的中文用的码表 response.getOutputStream().write(&quot;我爱北京&quot;.getBytes(&quot;UTF-8&quot;)); 不管是字节流还是字符流，直接使用一行代码，然后再写数据 response.setContentType(&quot;text/html;charset=UTF-8&quot;);]]></content>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-图(最短路径)]]></title>
    <url>%2F2018%2F11%2F13%2FJava%E7%AE%97%E6%B3%95-%E5%9B%BE-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[最短路径最短路径应用的图是加权有向图加权有向图的数据结构：首先定义的是加权有向边的数据类型：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class DirectEdge &#123; private int v;//边的起点 private int w;//边的终点 private double weight;//边的权重 public DirectEdge(int v,int w,double weight)&#123; this.v=v; this.w=w; this.weight=weight; &#125; public double weight()&#123; return weight; &#125; public int from()&#123; return v; &#125; public int to()&#123; return w; &#125; public String toString()&#123; return String.format("%d-&gt;%d %.2f", v,w,weight); &#125;&#125; ``` 在加权有向边的基础上定义加权有向图 ```javapublic class EdgeWeightDigraph &#123; private int V; private int E; private Bag&lt;DirectEdge&gt;[] adj; public EdgeWeightDigraph(int V)&#123; this.V=V; this.E=0; adj=(Bag&lt;DirectEdge&gt;[])new Bag[V]; for(int v=0;v&lt;V;v++)&#123; adj[v]=new Bag&lt;DirectEdge&gt;(); &#125; &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; public void addEdge(DirectEdge e)&#123; int v=e.from(); adj[v].add(e); E++; &#125; public Iterable&lt;DirectEdge&gt; adj(int v)&#123; return adj[v]; &#125; public Iterable&lt;DirectEdge&gt; edges()&#123; Bag&lt;DirectEdge&gt; bag=new Bag&lt;DirectEdge&gt;(); for(int v=0;v&lt;V;v++)&#123; for(DirectEdge e:adj[v])&#123; bag.add(e); &#125; &#125; return bag; &#125;&#125; 最短路径：从图的一个顶点到达另一个顶点的成本最小(权重和最小)的路径，这里的最短路径是单点最短路径最短路径树： 给定一幅加权有向图和顶点s，可以找到一个以s为起点的最小路径树，他是图的一幅子图，包含了顶点s和所有s可达的顶点。树的根节点是s，树的每一条路径都是有向图中的一条最短路径 最短路径算法原理边的松弛顶点的松弛最短路径的最优条件：一幅有向加权图G,顶点s为起点，distTo[]保存着起点s到任意顶点v的路径长度，若s到v不可达，该值为无穷大。当且仅当对于从v到w的任意一条边e，满足distTo[w]&lt;=distTo[v]+e.weight()条件时，才是最短路径 Dijkstra算法 算法思想1) 首先Dijkstra算法只适用在权值非负的加权有向图 如下图所示，E(v2,v5)为负值，如果想找到v5到v4的最短路径，那么这一条路径：v5-&gt;v4-&gt;v2-&gt;v5-&gt;v4的权值之和为-6，如此一直沿着这条路径循环，那么v5到v4的路径权重之和会越来越小，趋近于负无穷，那么这两个顶点之间的最短路径无法确定。我们称图中这样的循环为负值圈，有向图中出现负值圈时，最短路径的问题就无法确定。 2）Dijkstra算法的思想 首先确定源点s，dist[v]表示的是从s到v的最短路径距离 Dijkstra算法每次从没有确定最短路径的顶点中选择dist[]值最小的顶点v，对v的所有边进行松弛，如此操作直到确定所有顶点的最短路径 算法实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Dijkstra &#123; private DirectEdge[] edgeTo; private double[] distTo; private IndexMinPQ&lt;Double&gt; pq; public Dijkstra(EdgeWeightDigraph G,int s)&#123; edgeTo=new DirectEdge[G.V()]; distTo=new double[G.V()]; pq=new IndexMinPQ&lt;Double&gt;(G.V()); //初始化distTo所有项为正无穷 for(int v=0;v&lt;G.V();v++)&#123; distTo[v]=Double.POSITIVE_INFINITY; &#125; //起始点设置为0 distTo[s]=0.0; //将起始点入队 pq.insert(s, 0.0); while(!pq.isEmpty())&#123; relax(G,pq.deleteMin()); &#125; &#125; private void relax(EdgeWeightDigraph G,int v)&#123; for(DirectEdge e:G.adj(v))&#123; int w=e.to(); if(distTo[w]&gt;distTo[v]+e.weight())&#123; distTo[w]=distTo[v]+e.weight(); edgeTo[w]=e; if(pq.contains(w))&#123; pq.changeKey(w, distTo[w]); &#125;else&#123; pq.insert(w, distTo[w]); &#125; &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return distTo[v]&lt;Double.POSITIVE_INFINITY; &#125; public double distTo(int v)&#123; return distTo[v]; &#125; public Iterable&lt;DirectEdge&gt; pathTo(int v)&#123; Stack&lt;DirectEdge&gt; stack=new Stack&lt;DirectEdge&gt;(); while(edgeTo[v]!=null)&#123; stack.push(edgeTo[v]); v=edgeTo[v].from(); &#125; return stack; &#125;&#125; 算法分析 Dijkstra算法时间复杂度取决于存储顶点的数据结构 上面算法的实现使用的是最小优先队列，每次删除最小距离顶点时间复杂度为logV，整个算法需要对每条边松弛，所以基于最小优先队列的Dijkstra算法的时间复杂度为ElogV 基于拓扑排序的最短路径算法 算法原理 将图按照拓扑排序的顺序放松顶点 这种算法只能应用在无环有向图中，并且它允许图的边的权重是负值，他还能解决相关的问题比如最长路径 算法实现 12345678910111213141516171819202122232425262728293031323334353637383940//利用拓扑排序实现的最短路径算法 public class AcyclicSP &#123; private DirectEdge[] edgeTo; private double[] distTo; public AcyclicSP(EdgeWeightDigraph G,int s)&#123; edgeTo=new DirectEdge[G.V()]; distTo=new double[G.V()]; for(int v=0;v&lt;G.V();v++)&#123; distTo[v]=Double.POSITIVE_INFINITY; &#125; distTo[s]=0.0; TopoEdgeWeight top=new TopoEdgeWeight(G); for(int v:top.order())&#123; relax(G,v); &#125; &#125; private void relax(EdgeWeightDigraph G,int v)&#123; for(DirectEdge e:G.adj(v))&#123; int w=e.to(); if(distTo[w]&gt;distTo[v]+e.weight())&#123; distTo[w]=distTo[v]+e.weight(); edgeTo[w]=e; &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return distTo[v]&lt;Double.POSITIVE_INFINITY; &#125; public double distTo(int v)&#123; return distTo[v]; &#125; public Iterable&lt;DirectEdge&gt; pathTo(int v)&#123; Stack&lt;DirectEdge&gt; stack=new Stack&lt;DirectEdge&gt;(); while(edgeTo[v]!=null)&#123; stack.push(edgeTo[v]); v=edgeTo[v].from(); &#125; return stack; &#125; &#125; 在查找最短路径之前需要对图进行拓扑排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class TopoEdgeWeight &#123; private boolean marked[]; private Stack&lt;Integer&gt; stack; public TopoEdgeWeight(EdgeWeightDigraph G)&#123; marked=new boolean[G.V()]; stack=new Stack&lt;Integer&gt;(); EdgeWeightDigraphCycle cycle=new EdgeWeightDigraphCycle(G); if(!cycle.hasCycle())&#123; TopoSort(G); &#125; &#125; private void TopoSort(EdgeWeightDigraph G)&#123; for(int v=0;v&lt;G.V();v++)&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; private void dfs(EdgeWeightDigraph G,int v)&#123; marked[v]=true; for(DirectEdge e:G.adj(v))&#123; if(!marked[e.to()])&#123; dfs(G,e.to()); &#125; &#125; stack.push(v); &#125; public Iterable&lt;Integer&gt; order()&#123; return stack; &#125;&#125;``` 在拓扑排序之前需要检查图是不是无环图 ```javapublic class EdgeWeightDigraphCycle &#123; private boolean[] marked; private DirectEdge[] edgeTo; private Stack&lt;DirectEdge&gt; cycle; private boolean[] onStack; public EdgeWeightDigraphCycle(EdgeWeightDigraph G)&#123; marked=new boolean[G.V()]; edgeTo=new DirectEdge[G.V()]; onStack=new boolean[G.V()]; for(int v=0;v&lt;G.V();v++)&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; private void dfs(EdgeWeightDigraph G,int v)&#123; marked[v]=true; onStack[v]=true; for(DirectEdge e:G.adj(v))&#123; int w=e.to(); if(hasCycle())&#123; return; &#125;else if(!marked[w])&#123; edgeTo[w]=e; dfs(G,w); &#125;else if(onStack[w])&#123; cycle=new Stack&lt;DirectEdge&gt;(); DirectEdge f=e; while(f.from()!=w)&#123; cycle.push(f); f=edgeTo[f.from()]; &#125; cycle.push(f); return; &#125; &#125; onStack[v]=false; &#125; public boolean hasCycle()&#123; return cycle!=null; &#125; public Iterable&lt;DirectEdge&gt; cycle()&#123; return cycle; &#125;&#125; 算法分析基于拓扑排序的最短路径算法是一种比Dijkstra算法更快更简单的在无环加权有向图中找到最短路径的算法基于拓扑排序的最短路径算法的时间复杂度是O(V+E) Floyd算法 算法原理 从任意节点v到节点w最短路径有两种情况：第一种是直接从v到w；第二种是从v经过若干个节点到达w，对图中的每个节点k，检查dist(v,k)+dist(k,w)&lt;dist(v,w)是否成立，如果成立，那么更新v到w的最短路径为dist(v,k)+dist(k,w)，如此当我们遍历完图中所有的节点之后，v到w的最短路径和最短距离就确定了。 此算法就是一任意的顺序放松图中所有的边，重复V轮。 算法实现三重循环实现 for (int k=0; k&lt;n; ++k) { for (int i=0; i&lt;n; ++i) { for (int j=0; j&lt;n; ++j) { if (dist[i][k] + dist[k][j] &lt; dist[i][j] ) { dist[i][j] = dist[i][k] + dist[k][j]; path[i][j] = path[k][j]; } } } } 算法分析 Floyd算法的时间复杂度为：O(V3) Bellman-Ford算法Bellman-ford算法是求含负权图的单源最短路径算法，效率很低，但代码很容易写 算法原理利用队列 算法实现 public class BellmanFord { private double[] distTo; private DirectEdge[] edgeTo; private boolean[] onQ;//该顶点是否在队列中 private Queue&lt;Integer&gt; queue;//用于存放将被放松的顶点 private int cont;//放松的次数 private Iterable&lt;DirectEdge&gt; cycle; public BellmanFord(EdgeWeightDigraph G,int s){ distTo=new double[G.V()]; edgeTo=new DirectEdge[G.V()]; onQ=new boolean[G.V()]; queue=new Queue&lt;Integer&gt;(); for(int v=0;v&lt;G.V();v++){ distTo[v]=Double.POSITIVE_INFINITY; } queue.enqueue(s); onQ[s]=true; distTo[s]=0.0; while(!queue.isEmpty() &amp;&amp; hasNegativeCycle()){ int v=queue.dequeue(); onQ[v]=false; relax(G,v); } } private void relax(EdgeWeightDigraph G,int v){ for(DirectEdge e:G.adj(v)){ int w=e.to(); if(distTo[w]&gt;distTo[v]+e.weight()){ distTo[w]=distTo[v]+e.weight(); edgeTo[w]=e; if(!onQ[w]){ queue.enqueue(w); onQ[w]=true; } } if(cont++ % G.V() ==0){ findNegativeCycle(); } } } public void findNegativeCycle(){ int V=edgeTo.length; EdgeWeightDigraph bf=new EdgeWeightDigraph(V); for(int v=0;v&lt;V;v++){ if(edgeTo[v]!=null){ bf.addEdge(edgeTo[v]); } } EdgeWeightDigraphCycle cf=new EdgeWeightDigraphCycle(bf); cycle=cf.cycle(); } public boolean hasNegativeCycle(){ return cycle!=null; } public Iterable&lt;DirectEdge&gt; negativeCycle(){ return cycle; } public boolean hasPathTo(int v){ return distTo[v]&lt;Double.POSITIVE_INFINITY; } public double distTo(int v){ return distTo[v]; } public Iterable&lt;DirectEdge&gt; pathTo(int v){ Stack&lt;DirectEdge&gt; stack=new Stack&lt;DirectEdge&gt;(); while(edgeTo[v]!=null){ stack.push(edgeTo[v]); v=edgeTo[v].from(); } return stack; } } 算法分析 BellmanFord算法的时间复杂度一般情况为O(E+V),最坏情况为O(VE)]]></content>
      <tags>
        <tag>Algorihtms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-图（最小生成树）]]></title>
    <url>%2F2018%2F11%2F04%2FJava%E7%AE%97%E6%B3%95-%E5%9B%BE%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最小生成树定义：加权图：加权图是图中每条边都关联一个权值的图模型(边的权重可以表示距离、时间、费用等不同变量；权中可正可负)带权重边的表示：1234567891011121314151617181920212223242526272829303132333435public class Edge implements Comparable&lt;Edge&gt; &#123; private int v; private int w;//v,w为边连接的两个顶点 private double weight;//边的权重 public Edge(int v,int w,double weight)&#123; this.v=v; this.w=w; this.weight=weight; &#125; public double weight()&#123; return weight; &#125; public int either()&#123; return v; &#125; public int other(int vertex)&#123; if(vertex==v)&#123; return w; &#125;else if(vertex==w)&#123; return v; &#125;else&#123; throw new RuntimeException("Inconsistent edge"); &#125; &#125; @Override public int compareTo(Edge that)&#123; if(this.weight()&lt;that.weight())&#123; return -1; &#125;else if(this.weight()&gt;that.weight())&#123; return 1; &#125;else&#123; return 0; &#125; &#125;&#125;无向加权图的表示：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 public class EdgeWeightGraph &#123; private int V; private int E; private Bag&lt;Edge&gt;[] adj; public EdgeWeightGraph(int V)&#123; this.V=V; this.E=0; adj=(Bag&lt;Edge&gt;[])new Bag[V]; for(int v=0;v&lt;V;v++)&#123; adj[v]=new Bag&lt;Edge&gt;(); &#125; &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; //添加边 public void addEdge(Edge e)&#123; int v=e.either(); int w=e.other(v); adj[v].add(e); adj[w].add(e); E++; &#125; public Iterable&lt;Edge&gt; adj(int v)&#123; return adj[v]; &#125; //返回图中所有的边 public Iterable&lt;Edge&gt; edges()&#123; Bag bag=new Bag&lt;Edge&gt;(); for(int v=0;v&lt;V;v++)&#123; for(Edge e:adj[v])&#123; if(e.other(v)&gt;v)&#123; bag.add(e); &#125; &#125; &#125; return bag; &#125; //显示图表 public String toString()&#123; StringBuilder s=new StringBuilder(); s.append(V+"Vertexs"+E+"Edges\n"); for(int v=0;v&lt;V;v++)&#123; s.append(v+":"); for(Edge e:adj[v])&#123; s.append(e+" "); &#125; s.append("\n"); &#125; return s.toString(); &#125;&#125; 生成树：一幅图的生成树是它的一棵含有其所有顶点的无环连通子图最小生成树(MST)：一幅图的最小生成树是它的一棵所有边权值和最小的生成树(生成树+所有边权值和最小) 切分定理图的切分：将图中所有的顶点分为两个非空且不重叠的两个集合，横切边(crossing edge)是一条连接两个属于不同集合中顶点的边切分定理：一幅加权图中，对于图的任意切分的横切边中的权重最小的边一定属于改图的最小生成树切分定理会把加权图所有的顶点分为两个集合，检查每次切分的横切边并识别属于最小生成树的边最小生成树的贪心算法： 生成最小生成树的基础是切分定理，对于一个V个顶点的加权图，使用切分定理找到最小生成树的一条边，不断重复直到找到最小生成树所有的V-1条边 最小生成树Prim算法prim算法的核心是选取一个顶点，每一次向树中添加一条边，知道添加V-1条边；每次添加的边是连接树中的顶点和不在树中的顶点所连接的边中权重值最小的。注：连接树：最小生成树的一部分横切边:为连接树中的顶点和不在连接树中的顶点之间的所有边失效边:如果一条边的两个顶点都在连接树中，则为失效边不去管它 prim算法延时实现过程： 选取一个起始顶点作为生成树的第一个顶点，将此时所有的横切边加入优先队列（MinPQ） 检查队列while(队列不空)： 取出并删除队列中的权重值最小的边 if(这条边失效) contuine结束此次循环 if(这条边有一个顶点不在连接树上)将这个顶点添加到树中，并将新的横切边添加到优先队列中 算法改进：prim算法即时实现延时实现是一些失效的横切边保存在优先队列中(当向连接树添加一个新的顶点v时，所有和v相关联的横切边都会被加入到优先队列中)，只有要删除的时候才检查它的有效性Prim实时实现是不去保存所有的横切边，它只保存连接树顶点和非树顶点中权重最小的边试想：当我们向连接树中添加了一个新的顶点v，那么非树顶点w可能距离连接树的距离更近了，我们只保存非树顶点w和树顶点距离最近的那条边。可能队列中保存着w到连接树的权重最小的边w-&gt;k,当连接树中加入了v之后，w-&gt;v这条边的权重值比w-&gt;k的权重值要小，那么在优先队列中对于顶点w，它和连接树距离最短的边更新为w-&gt;v。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class PrimMST&#123; private Edge[] edgeTo;//用来存储非树顶点距离树最近的边 private double[] distTo;//用来存储边的权重，distTo[i]=edgeTo[i].weight() private boolean[] marked;//用来标记顶点是否在树中 private IndexMinPQ&lt;Double&gt; pq;//存储有效的横切边 public PrimMST(EdgeWeightGraph G)&#123; edgeTo=new Edge[G.V()]; distTo=new double[G.V()]; marked=new boolean[G.V()]; pq=new IndexMinPQ&lt;Double&gt;(G.V()); for(int i=0;i&lt;G.V();i++)&#123; distTo[i]=Double.POSITIVE_INFINITY; &#125; //从顶点0开始 distTo[0]=0.0; pq.insert(0, 0.0); while(!pq.isEmpty())&#123; visit(G,pq.deleteMin()); &#125; //当向最初的树中添加V-1条边后，最小生成树完成而优先队列变为空 &#125; private void visit(EdgeWeightGraph G,int v)&#123; //将v添加至树中，更新相关数据 marked[v]=true; //遍历和v相连的每一个顶点 for(Edge e:G.adj(v))&#123; int w=e.other(v); if(marked[w])&#123; continue; &#125; //检查distTo中存储的是否是w距树最小的距离 if(e.weight()&lt;distTo[w])&#123; edgeTo[w]=e; distTo[w]=e.weight(); //添加或更新优先队列中的相关顶点的数据 if(pq.contains(w))&#123; pq.changeKey(w, distTo[w]); &#125;else&#123; pq.insert(w, distTo[w]); &#125; &#125; &#125; &#125; //遍历最小生成树中的所有边 public Iterable&lt;Edge&gt; edges()&#123; Queue&lt;Edge&gt; q=new Queue&lt;Edge&gt;(); for(int v=0;v&lt;edgeTo.length;v++)&#123; Edge e=edgeTo[v]; if(e!=null)&#123; q.enqueue(e); &#125; &#125; return q; &#125;&#125; Kruskal算法Kruskal算法的核心是将图中所有的边按权重由小到大的顺序加入最小生成树，新加入的边不能与已经加入的边构成环。12345678910111213141516171819202122232425262728 public class KruskalMST &#123; private Queue&lt;Edge&gt;mst; public KruskalMST(EdgeWeightGraph G)&#123; mst=new Queue&lt;Edge&gt;(); //创建最小优先队列，并存储图中所有的边 MinPQ&lt;Edge&gt; pq=new MinPQ&lt;Edge&gt;(G.E()); for(Edge e:G.edges())&#123; pq.insert(e); &#125; //创建并查集Union_Find中的一个形式Quick_find Quick_find uf=new Quick_find(G.V()); while(!pq.isEmpty() &amp;&amp; mst.size()&lt;G.V()-1)&#123; Edge e=pq.deleteMin(); int v=e.either(); int w=e.other(v); //判断这条边的两个顶点是否连通，如果已经连通那么再加入这条边就会形成一个环 if(uf.connected(v, w))&#123; continue; &#125; uf.union(v, w); mst.enqueue(e); &#125; &#125; public Iterable&lt;Edge&gt; edges()&#123; return mst; &#125;&#125;]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-图]]></title>
    <url>%2F2018%2F10%2F10%2FJava%E7%AE%97%E6%B3%95-%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[无向图图的定义：A graph is a set of vertices and a collections of edges that each connect a pair of vertices.graph = edge + vertex 图的表示邻接矩阵假设图有V个顶点，使用一个V*V的布尔矩阵a来表示图，顶点v和顶点w相连那么a[v,w]和a[w,v]都设置为true，相连设置为false。 邻接矩阵在存储一个较大的图时是不可行的，所需要的巨大的空间无法满足。 邻接表邻接表是一个一顶点vertex为索引的列表数组，每一个索引代表一个顶点，数组在该索引处的元素是和该顶点相连接的顶点列表。使用邻接表实现的图有如下特点： 创建图使用的空间和V+E成正比 添加一条边时间为常数 遍历顶点v相邻的顶点所需时间和v的度数成正比 用邻接表创建的Graph数据结构：12345678910111213141516171819202122232425262728293031323334353637383940414243public class Graph &#123; private int V; //顶点数目 private int E; //边的条数 private Bag&lt;Integer&gt;[] adj; //邻接表 public Graph()&#123;&#125; //初始化顶点为V的邻接表 public Graph(int V)&#123; this.V=V; this.E=0; adj=(Bag&lt;Integer&gt;[]) new Bag[V]; for(int i=0;i&lt;V;i++)&#123; adj[i]=new Bag&lt;Integer&gt;(); &#125; &#125; public int V()&#123; return V; &#125; public int E()&#123; return E; &#125; public void addEdg(int v,int w)&#123; adj[v].add(w); adj[w].add(v); E++; &#125; public Iterable&lt;Integer&gt; adj(int v)&#123; return adj[v]; &#125; public int degree(int v)&#123; return adj[v].size(); &#125; public String toString()&#123; String s=V+" vertices"+E+" edges\n"; for(int i=0;i&lt;V;i++)&#123; s+=i+":"; for(int j:this.adj[i])&#123; s+=j+" "; &#125; s+="\n"; &#125; return s; &#125;&#125; 深度优先搜索深度优先搜索类似于走迷宫的Tremaux搜索。从一个没有走过的路口开始，走过的路铺一条绳子；标记走过的路口；当来到标记的路口，一直回退到有没被标记的路口继续走，如果回退时一直无路可走就一直回退到起点。 深度优先搜索类似于走迷宫，一直寻找没有被访问的节点深度优先搜索需要用递归的方法遍历图中所有的顶点 将访问的节点标记 递归的访问它的所有没有被标记的邻居节点深度优先代码如下： 12345678910111213141516171819202122public class DFS&#123; private boolean[] marked; private int count; public DFS(Graph G,int s)&#123; marked=new boolean[G.V()]; dfs(G,s); &#125; private void dfs(Graph G,int s)&#123; marked[s]=true; for(int v:G.adj[s])&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; public boolean marked(int w)&#123; return marked[m]; &#125; public int count()&#123; return count; &#125;&#125; 下面是DFS的搜索轨迹图： 深度优先搜索可以遍历图中所有的顶点和边，利用DFS可以解决图中的一些问题： 连通性问题：给定的两个顶点是否相连 单点问题，路径问题：某一起点与任意联通顶点的路径下面为利用DFS查找图中的路径的算法程序 12345678910111213141516171819202122232425262728293031323334353637 public class DepthFirstPaths &#123; private boolean[] marked;//用于标记顶点是否被访问过 private int[] edgeTo; //记录从起点到一个顶点的路径上的最后一个顶点 private int s; public DepthFirstPaths(Graph G,int s)&#123; this.s=s; marked=new boolean[G.V()]; edgeTo=new int[G.V()]; dfs(G,s); &#125; //深度优先算法DFS private void dfs(Graph G,int v)&#123; marked[v]=true; for(int w:G.adj(v))&#123; if(!marked[w])&#123; edgeTo[w]=v; dfs(G,w); &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return marked[v]; &#125; //返回起点到某个顶点的路径 public Iterable&lt;Integer&gt; pathTo(int v)&#123; if(!hasPathTo(v))&#123; return null; &#125; Stack&lt;Integer&gt; path=new Stack&lt;Integer&gt;(); for(int x=v;x!=s;x=edgeTo[x])&#123; path.push(x); &#125; path.push(s); return path; &#125;&#125; 下图为DFS搜索路径的轨迹实例图 广度优先搜索我们常要解决的问题是图中两个点之间最短的路径问题，DFS可以找出两点间的联通路径，却没办法找到最短的路径，但广度优先搜索可以解决这个问题。 在广度优先搜索中我们是按照与起点的距离的顺序遍历所有结点，这里用到了队列（先进先出，就近遍历）；首先将起点标记并加入队列，重复以下步骤直到队列为空： 将队列中的下一个顶点v出队，并将其标记； 将与v相邻且未被标记的顶点按顺序依次入队；BFS搜索路径算法： 12345678910111213141516171819202122232425262728293031323334353637383940414243 public class BreadthFirstPaths &#123; private boolean[] marked;//用于标记顶点是否被访问过 private int[] edgeTo; //记录从起点到一个顶点的路径上的最后一个顶点 private int s; public BreadthFirstPaths(Graph G,int s)&#123; this.s=s; marked=new boolean[G.V()]; edgeTo=new int[G.V()]; bfs(G,s); &#125; //广度优先算法BFS private void bfs(Graph G,int s)&#123; Queue&lt;Integer&gt; queue=new Queue&lt;Integer&gt;(); marked[s]=true; queue.enqueue(s); while(!queue.isEmpty())&#123; int v=queue.dequeue(); for(int w:G.adj(v))&#123; if(!marked[w])&#123; edgeTo[w]=v; marked[w]=true; queue.enqueue(w); &#125; &#125; &#125; &#125; public boolean hasPathTo(int v)&#123; return marked[v]; &#125; //返回起点到某个顶点的路径 public Iterable&lt;Integer&gt; pathTo(int v)&#123; if(!hasPathTo(v))&#123; return null; &#125; Stack&lt;Integer&gt; path=new Stack&lt;Integer&gt;(); for(int x=v;x!=s;x=edgeTo[x])&#123; path.push(x); &#125; path.push(s); return path; &#125;&#125; 下图为BFS实例中搜索轨迹图： 用BFS检测给定的图是无环的吗。用BFS检测是否是二分图（即任意一条边的两个顶点都不属于同一连通集） DFS和BFS具有不同的搜索路径： 深度优先搜索是不断深入图中，探索距离起点越来越远的顶点，只有碰到访问过的顶点或者死胡同时才返回到最近的顶点；广度优先搜索像扇面一样前进，它只有访问了一个顶点附近相邻的所有顶点之后才继续向前探索；DFS的路径通常长而曲折，而BFS路径短而整齐直接。 如下图所示两种搜索方式的路径对比： 连通分量DFS解决连通性问题用深度优先搜索来查找图中所有的连通分量的算法123456789101112131415161718192021222324252627282930313233343536public class CC&#123; private boolean[] marked; //用来标记顶点是否被访问过 private int[] id; //用来标记所属的连通集 private int count; //表示连通集 public CC(Graph G)&#123; marked=new boolean(G.V()); id=new int(G.V()); for(int s=0;s&lt;G.V();s++)&#123; if(!marked[s])&#123; dfs(G,s); count++; &#125; &#125; &#125; public dfs(Graph G,int v)&#123; marked[v]=true; id[v]=count; for(int s:G.adj[v])&#123; if(!marked[s])&#123; dfs(G,s); &#125; &#125; &#125; //判断两个顶点是否属于同一个连通分量 public boolean connect(int v,int w)&#123; return id[v]==id[w]; &#125; //返回顶点所在的连通集 public int id(int v)&#123; return id[v]; &#125; //返回有几个连通分量 public int count()&#123; return count; &#125;&#125;下图为搜索图中所有连通分量的轨迹： 并查集解决连通性问题Union_Find：并查集能解决动态连通性问题，union()会将两个分量合并到同一连通分量，fins()会返回给定点所在的连通分量的标识符，connect()会判断两个点是否在同一连通分量，count()会返回连通分量的数量。123456789101112131415161718192021 //并查集抽象类，关键的是抽象的方法find和union abstract class Union_Find &#123; protected int[] id; protected int count; public Union_Find(int N)&#123; count=N; id=new int[N]; for(int i=0;i&lt;N;i++)&#123; id[i]=i; &#125; &#125; public int count()&#123; return count; &#125; public boolean connected(int p,int q)&#123; return find(p)==find(q); &#125; public abstract int find(int p); public abstract void union(int p,int q); &#125; Quick Find快速查找算法：id[]这个数组标记着结点所在的连通集，将在同一连通集的结点的id[]值设置为同一个值，当将两个连通集合并的时候，将一个连通集内的所有结点的id[]值改为另一个连通集的id[]值。 这种算法不适合处理大型问题，以为find速度很快，但是union速度非常慢，需要将其中一个连通分量中的所有节点 id 值都修改为另一个节点的 id 值 1234567891011121314151617181920212223 //快速查找算法public class Quick_find extends Union_Find &#123; public Quick_find(int N)&#123; super(N); &#125; public int find(int p)&#123; return id[p]; &#125; public void union(int p,int q)&#123; int pID=find(p); int qID=find(q); if(pID==qID)&#123; return; &#125; for(int i=0;i&lt;id.length;i++)&#123; if(id[i]==pID)&#123; id[i]=qID; &#125; &#125; count--; &#125;&#125; Quick Union需要一种快速union的算法，只需要修改一下id[]数组的结构，每个点对应的id[]元素都是同一连通分量的其它点，这叫做链接。一个结点由链接找到指向它的另一个结点，这个节点再继续查找，以此类推知道找到这个连通集的根节点，类似以树结构。 union操作时只需将一个连通集的根节点指向另一个连通集的根节点 这种算法union操作很高效，find操作时间复杂度和树的高度成正比，最坏情况下树的高度为结点个数 quick-union算法123456789101112131415161718192021//快速合并算法public class Quick_Union extends Union_Find &#123; public Quick_Union(int N) &#123; super(N); &#125; public int find(int p)&#123; while(p!=id[p])&#123; p=id[p]; &#125; return p; &#125; public void union(int p,int q)&#123; int pID=find(p); int qID=find(q); if(pID==qID)&#123; return; &#125; id[pID]=qID; count--; &#125;&#125; 加权Quick Union为了防止quick-union最坏情况的发生，改进quick-union为加权quick-union算法 做法是记录被一个连通集的大小，union时将小的连通集指向大的连通集，这样生成的连通集会很平衡 加权的quick-union算法能够实现lgN对数级别的性能 123456789101112131415161718192021222324252627282930313233343536373839404142434445 //加权快速合并算法public class WeightedQuickUnion &#123; private int[] id; private int[] sz; private int count; public WeightedQuickUnion(int N)&#123; count=N; id=new int[N]; for(int i=0;i&lt;N;i++)&#123; id[i]=i; &#125; sz=new int[N]; for(int i=0;i&lt;N;i++)&#123; sz[i]=1; &#125; &#125; public int count()&#123; return count; &#125; public boolean connected(int p,int q)&#123; return find(p)==find(q); &#125; public int find(int p)&#123; while(p!=id[p])&#123; p=id[p]; &#125; return p; &#125; public void union(int p,int q)&#123; int pID=find(p); int qID=find(q); if(pID==qID)&#123; return; &#125; if(sz[pID]&lt;sz[qID])&#123; id[pID]=qID; sz[qID]+=sz[pID]; &#125;else&#123; id[qID]=pID; sz[pID]+=sz[qID]; &#125; count++; &#125;&#125; 有向图有向图：由一组顶点和一组有向的边组成的。 有向图也用邻接表表示，与无向图不同的是无向图制定了a通向b，即a-&gt;b,那么同时就有b-&gt;a;但有向图不一样，当指定了a-&gt;b没有b-&gt;a。 有向图的数据结构只有addEdg()方法不同，去掉注释的语句：12345public void addEdg(int v,int w)&#123; adj[v].add(w); #adj[w].add(v); E++;&#125; 有向图的可达性单点可达性：一个图和一个起点s–&gt;是否存在从s到v的有向路径多点可达性： 一个图和一个顶点集合–&gt;是否存在从集合任意顶点到达给定顶点的有向路径 12345678910111213141516171819202122232425262728293031 public class DirectedDFS &#123; private boolean[] marked; //单点可达判断 public DirectedDFS(Digraph G,int s)&#123; marked=new boolean[G.V()]; dfs(G,s); &#125; //多点可达判断 public DirectedGFS(Digraph G,Iterable&lt;Integer&gt; sources)&#123; marked=new boolean[G.V()]; for(int s:sources)&#123; if(!marked[s])&#123; dfs(G,s); &#125; &#125; &#125; //深度优先搜索 private void dfs(Digraph G,int v)&#123; marked[v]=true; for(int w:G.adj[v])&#123; if(!marked[w])&#123; dfs(G,w); &#125; &#125; &#125; //判断一个点是否可达 public boolean marked(int v)&#123; return marked[v]; &#125;&#125; 图中的环和有向无环图有些问题是不允许图中有有向环的可以用DFS检测一个图是否是有向无环图代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class DirectedCycle &#123; private boolean[] marked; //标记顶点 private int[] edgeTo; //标记指向的顶点 private Stack&lt;Integer&gt; cycle; //存储有向环中的顶点 private boolean[] onStack; //标记递归调用的栈上的所有顶点 public DirectedCycle(Digraph G)&#123; marked=new boolean[G.V()]; edgeTo=new int[G.V()]; onStack=new boolean[G.V()]; for(int v=0;v&lt;G.V();v++)&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; private void dfs(Digraph G,int v)&#123; marked[v]=true; onStack[v]=true; for(int w:G.adj(v))&#123; if(this.hasCycle())&#123; return; &#125;else if(!marked[w])&#123; edgeTo[w]=v; dfs(G,w); &#125;else if(onStack[w])&#123; cycle=new Stack&lt;Integer&gt;(); for(int x=v;v!=w;v++)&#123; cycle.push(x); &#125; cycle.push(w); cycle.push(v); &#125; &#125; onStack[v]=false; &#125; public boolean hasCycle() &#123; // TODO Auto-generated method stub return cycle!=null; &#125; public Iterable&lt;Integer&gt; cycle()&#123; return cycle; &#125;&#125; 拓扑排序对于有向图深度优先搜索只会访问图中每个顶点一次将DFS访问的顶点存储在一个数据结构，遍历这个数据结构就能按一定顺序得到图中所有的顶点根据数据结构的不同和保存节点的时间不同分成三种顺序： 前序：队列-&gt;在递归调用前将点入队 后序：队列-&gt;在递归调用之后将顶点入队 逆后序:栈-&gt;在递归之后将顶点入栈 代码如下：1234567891011121314151617181920212223242526272829303132333435363738 public class DepthFirstOrder &#123; private boolean[] marked; private Queue&lt;Integer&gt; pre; //所有顶点的前序排列 private Queue&lt;Integer&gt; post; //所有顶点的后序排列 private Stack&lt;Integer&gt; reverpost; //所有顶点的逆后排序 public DepthFirstOrder(Digraph G)&#123; pre=new Queue&lt;Integer&gt;(); post=new Queue&lt;Integer&gt;(); reverpost=new Stack&lt;Integer&gt;(); marked=new boolean[G.V()]; for(int v=0;v&lt;G.V();v++)&#123; if(!marked[v])&#123; dfs(G,v); &#125; &#125; &#125; private void dfs(Digraph G,int v)&#123; pre.enqueue(v); //递归之前入队 marked[v]=true; for(int w:G.adj(v))&#123; if(!marked[w])&#123; dfs(G,w); &#125; &#125; post.enqueue(v); //低估后入队 reverpost.push(v); &#125; public Iterable&lt;Integer&gt; pre()&#123; return pre; &#125; public Iterable&lt;Integer&gt; post()&#123; return post; &#125; public Iterable&lt;Integer&gt; reverpost()&#123; return reverpost; &#125;&#125; 拓扑排序：是对有向无环图的排序，给定一幅图，将所有顶点排序，使所有的有向边从排在前面的元素指向排在后面的元素，如果有一条路径从v-&gt;w，那么排序后v就要在w的前面拓扑排序主要用来对有依赖关系的事物排序一个有向无环图的拓扑排序顺序即所有顶点逆后序排列给定的一个图先判断是否无环，然后利用DepthFirstOrder返回逆后序顶点就是拓扑排序的结果1234567891011121314 public class Topological &#123; private Iterable&lt;Integer&gt; order; public Topological(Digraph G)&#123; DirectedCycle dc=new DirectedCycle(G); //判断是否是有向无环图 if(!dc.hasCycle())&#123; DepthFirstOrder dfs=new DepthFirstOrder(G); order=dfs.reverpost(); &#125; &#125; public Iterable&lt;Integer&gt; order()&#123; return order; &#125;&#125; 有向图的强连通性强连通：有向图中如果两个顶点互相可达则这两个点是强连通的强连通分量：有向图中的一个强连通分量是图中的一个最大的顶点集合C，对于C中的每一对顶点u和v，u和v是强连通的 识别计算有向图中的强连通分量：Kosaraju算法 对于一个有向图G，使用DepthFirstOrder来计算它的反向图GR的逆后序排序列 按照的到的GR的逆后序列的顺序在G中进行深度优先搜索 下列代码可以判断两个顶点是否强连通，查找并计算所有的强连通分量1234567891011121314151617181920212223242526272829303132333435363738public class KosarajuSCC &#123; private boolean[] marked; //用来标记顶点是否被访问过 private int[] id;//记录强连通分量的标识 private int count;//记录强连通分量的数量 public KosarajuSCC(Digraph G)&#123; marked=new boolean[G.V()]; id=new int[G.V()]; DepthFirstOrder order=new DepthFirstOrder(G.reverse());//计算GR的逆后序列 for(int s:order.reverpost())&#123; if(!marked[s])&#123; dfs(G,s); count++; &#125; &#125; &#125; private void dfs(Digraph G, int v) &#123; marked[v]=true; id[v]=count; for(int w:G.adj(v))&#123; if(!marked[w])&#123; dfs(G,w); &#125; &#125; &#125; //判断两顶点是否强连通 public boolean stronglyConnected(int v,int w)&#123; return id[v]==id[w]; &#125; //返回顶点所在的强连通分量 public int id(int v)&#123; return id[v]; &#125; //返回强连通分量的数量 public int count()&#123; return count; &#125;&#125;]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-查找（散列表）]]></title>
    <url>%2F2018%2F09%2F29%2FJava%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE%EF%BC%88%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[散列查找在查找算法中如果利用数组将要存储的键作为数组索引下标，将对应的值作为数组的内容，在预先知道所要查找的内容在数组的下标可以实现快速查找，实现时间复杂度为O(1)的算法。由于键值可能是各种类型的，可能是整数、可能是字符串类型不能直接作为数组的索引，所以第一步就是要通过散列函数将键转化为数组的索引值。由于散列函数在转化过程中不同的键可能变成相同的索引值，出现碰撞冲突，所以第二步就要处理碰撞冲突。 散列函数如果保存键值的数组大小为M，那么键值通过散列函数就要转化在[0,M-1]的索引范围内，我们需要的散列函数能够将键值均匀的分布在[0,M-1]内，每个键都有相同的可能与0~M-1红的每个整数对应。 我们所使用的散列函数能够均匀并独立的将所有的键分布于0到M-1之间 由于键值的数据类型不同，所需要的散列函数也不同，每种类型都有与之对应的散列函数 整数类型对于整数类型常用的方法是除留余数法:k%M最好使用不是2的幂的质数 浮点数将键表示为二进制然后使用除留余数法 字符串下面为String类型中计算hash值得算法 1234567891011public int hashCode() &#123; int h = hash; //hash是初始值，一般为0 if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; 组合键下面为自定义类的hashcode算法，它将类中的所有成员变量综合起来计算hash值 默认的hashcode函数返回对象的地址 123456789101112131415public class Person &#123; private String name; private int age; private String sex; private String city; public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((city == null) ? 0 : city.hashCode()); result = prime * result + ((name == null) ? 0 : name.hashCode()); result = prime * result + ((sex == null) ? 0 : sex.hashCode()); return result; &#125;&#125; 将hashcode()的返回值转化为数组索引 1234 public int hash(Key k)&#123; return (k.hashCode() &amp; 0x7fffffff) % M;&#125; &amp;的作用是将计算出的hashCode值得符号位屏蔽 基于拉链法的散列表拉链法：保存数组的大小为M，将数组的每一个元素指向一个链表，每个链表中都存储键值相同的元素。 12345678910111213141516171819202122232425262728293031323334 public class SeparateChainingHashST&lt;Key,Value&gt; &#123; private int N;//键值对总数 private int M;//散列表大小 private SequentialSearchST&lt;Key,Value&gt;[] st;//存储链表的数组 public SeparateChainingHashST(int M) &#123; this.M = M; st=(SequentialSearchST&lt;Key,Value&gt;[]) new SequentialSearchST[M]; for(int i=0;i&lt;M;i++)&#123; st[i]=new SequentialSearchST(); &#125; &#125; private int hash(Key key)&#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; public Value get(Key key)&#123; return st[hash(key)].get(key); &#125; public void put(Key key,Value val)&#123; st[hash(key)].put(key, val); &#125; public void delete(Key key)&#123; st[hash(key)].delete(key); &#125; public Iterable&lt;Key&gt; keys()&#123; Queue&lt;Key&gt; queue=new Queue&lt;Key&gt;(); for(int i=0;i&lt;M;i++)&#123; for(Key key:st[i].keys())&#123; queue.enqueue(key); &#125; &#125; return queue; &#125;&#125; 拉链法的散列表性能分析： 一张含有M个链表和N个键的散列表中，未命中的查找和插入所需要的比较次数大约为N/M 需要选择合适的M：如果M过大会空链表多浪费空间资源，但查找速度快；M过小链表平均长度变长，查找效率低；应该选择足够大的M能够将性能提高M倍。也可以选择动态调整数组大小 基于线性探测法的散列表（开放地址散列表）线性探测法：通过哈希函数将键值k转化成数组索引值n，检查数组索引为n的位置会出现三种情况 该位置键值为空，将键值对插入该位置 该位置的键和被查找的键相同，如果查找操作返回查找内容，如果插入操作将键所对应的值换成新值 该位置的键和被查找的键不同，则增大索引继续检查下一个键值，知道找到该键或者遇到一个空元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class LinearProbingHashST&lt;Key,Value&gt; &#123; private int N; private int M; private Key[] keys; private Value[] vals; public LinearProbingHashST(int M)&#123; this.M=M; keys=(Key[]) new Object[M]; vals=(Value[]) new Object[M]; &#125; private int hash(Key key)&#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; public boolean contains(Key key)&#123; return get(key)!=null; &#125; private void resize(int cap)&#123; LinearProbingHashST&lt;Key,Value&gt; t=new LinearProbingHashST&lt;Key,Value&gt;(cap); for(int i=0;i&lt;M;i++)&#123; if(keys[i]!=null)&#123; t.put(keys[i], vals[i]); &#125; &#125; keys=t.keys; vals=t.vals; M=t.M; &#125; public void put(Key key,Value val)&#123; //N/M&gt;=1/2调整到1/4，使N/M保持在(1/8~1/2) if(N&gt;=M/2)&#123; resize(2*M); &#125; for(int i=hash(key);keys[i]!=null;i=(i+1)%M)&#123; if(key.equals(keys[i]))&#123; vals[i]=val; return; &#125; keys[i]=key; vals[i]=val; N++; &#125; &#125; public Value get(Key key)&#123; for(int i=hash(key);keys[i]!=null;i=(i+1)%M)&#123; if(keys[i].equals(key))&#123; return vals[i]; &#125; &#125; return null; &#125; public void delete(Key key)&#123; if(!contains(key))&#123; return; &#125; int i=hash(key); while(!keys[i].equals(key))&#123; i=(i+1)%M; &#125; keys[i]=null; vals[i]=null; i=(i+1)%M; while(keys[i]!=null)&#123; Key k=keys[i]; Value v=vals[i]; keys[i]=null; vals[i]=null; N--; put(k,v); i=(i+1)%M; &#125; N--; if(N&gt;0 &amp;&amp; N&lt;=M/8)&#123; resize(M/2); &#125; &#125; public Iterable&lt;Key&gt; keys()&#123; Queue&lt;Key&gt; queue=new Queue&lt;Key&gt;(); for(int i=0;i&lt;M;i++)&#123; if(keys[i]!=null)&#123; queue.enqueue(keys[i]); &#125; &#125; return queue; &#125; &#125; 线性探测法的性能分析：开放地址类的散列表的性能依赖于散列表的使用率p=N/M，我们一般会动态调整数组的大小是p保持在1/8~1/2之间。 在一张大小为M并包含有N=pM个键的基于线性探测的散列表中，命中和非命中查找所需要的探测次数为：~1/2(1+1/(1-p))和~1/2(1+1/(1-p)*(1-p)) 当p趋近1时，查找次数趋近于无穷；当p=1/2时，查找次数在[1.5,2.5]的范围呃内；所以动态调整数组大小减小p避免连列表过满，散列表快满时所需要的查找次数非常大。 散列表能够使查找和插入操作在时间复杂度上为常数级，理论上是最优的性能. 但它也有几个问题: 散列函数 :每种数据类型都需要优秀的散列函数，散列函数的计算可能复杂昂贵，一个好的散列函数直接影响着散列表的性能。 散列表不支持有序性操作：散列表中的键是无序的，如果你想快速找到最大最小值或者某个范围的键，散列表不合适因为这些操作都是线性级别的。]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-Comparable和Comparator的区别]]></title>
    <url>%2F2018%2F09%2F24%2FJava-Comparable%E5%92%8CComparator%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[ComparableComparable接口是排序接口，实现了这个借口的数据类型或者类可以通过Collection.sort()和Arrays.sort()自动排序，此接口中有一个方法compareTo(). public int compareTo(T p); Comparable是内部比较器，需要在一个类的内部实现,在类中需要重写compareTo方法，在此方法中需要实现所要比较的方式，比如如下代码，比较两个对象的方式是先比较姓名，如果一样在比较年龄。 定义一个实现了Comparable接口的Person类12345678910111213141516171819202122232425262728public class Person implements Comparable&lt;Person&gt; &#123; private String name; private int age; public Person(String name,int age)&#123; this.name=name; this.age=age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int compareTo(Person p)&#123; int rest=this.name.compareTo(p.name); if(rest!=0)&#123; return rest; &#125;else&#123; return this.age-p.age; &#125; &#125;&#125; 测试Person类的排序123456789101112131415161718public class test &#123; public static void main(String[] args)&#123; Person p1=new Person("keluosi",27); Person p2=new Person("nuoyier",30); Person p3=new Person("luoyisi",26); System.out.println(p1.compareTo(p2)); Person[] people=new Person[]&#123;p1,p2,p3&#125;; System.out.println("before sort:"); for(Person p:people)&#123; System.out.println(p.getName()+"---"+p.getAge()); &#125; Arrays.sort(people); System.out.println("after sort:"); for(Person p:people)&#123; System.out.println(p.getName()+"---"+p.getAge()); &#125; &#125;&#125; ComparatorComparator是比较接口，如果一个类没有实现Comparable接口需要对该类排序，则可以设计一个实现Comparator接口的比较器，通过这个类的比较器就可以对该类排序。Comparator是外部比较器，和Comparale不同不需要在类中实现，在对一个类实现比较排序时可以不用修改该类的源代码，只需创建该类的比较器利用这个比较器就可以对该类进行排序。使用Comparator有两种方式：一种是创建实现Compartor接口的比较器，使用时直接创建该比较器的对象；另一种是直接在使用到比较器的地方创建一个匿名内部类。如下代码：实现了Person类的比较器：123456public class PersonComparator implements Comparator&lt;Person&gt; &#123; public int compare(Person p1,Person p2)&#123; int rest=p1.getName().compareTo(p2.getName()); return rest!=0 ? rest:p1.getAge()-p2.getAge(); &#125;&#125;使用测试：1234567891011121314151617181920212223242526public class test &#123; public static void main(String[] args)&#123; Person p1=new Person("keluosi",27); Person p2=new Person("nuoyier",30); Person p3=new Person("luoyisi",26); System.out.println(p1.compareTo(p2)); Person[] people=new Person[]&#123;p1,p2,p3&#125;; System.out.println("before sort:"); for(Person p:people)&#123; System.out.println(p.getName()+"---"+p.getAge()); &#125; //使用比较器，创建比较器的对象 PersonComparator pc=new PersonComparator(); Arrays.sort(people,pc); //创建匿名内部类，直接在使用Comparator的地方创建一个Comparator对象并重写compare方法 Arrays.sort(people,new Comparator&lt;Person&gt;()&#123; public int compare(Person p1,Person p2)&#123; return p1.getAge()-p2.getAge(); &#125; &#125;); System.out.println("after sort:"); for(Person p:people)&#123; System.out.println(p.getName()+"---"+p.getAge()); &#125; &#125;&#125; 对比：Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。 Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。 两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-查找（平衡查找树）]]></title>
    <url>%2F2018%2F09%2F22%2FJava%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE%EF%BC%88%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[2-3查找树https://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html 红黑树https://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-查找（二叉搜索树）]]></title>
    <url>%2F2018%2F09%2F22%2FJava%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE%EF%BC%88%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[二叉查找树是一棵二叉树，每个节点的键都大于左子树的任意节点的键，小于右子树的任意节点的键 二叉树的遍历方式分为先序，中序，后序，如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Traversal&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123; private Node root; public class Node&#123; private Key key; private Value val; private Node left; private Node right; private int N; public Node(Key key,Value val,int N)&#123; this.key=key; this.val=val; this.N=N; &#125; &#125; //先序遍历(根节点-&gt;左子树-&gt;右子树) public void PreOrderTraversal()&#123; PreOrderTraversal(root); &#125; //递归实现 private void PreOrderTraversal(Node x) &#123; if(x!=null)&#123; System.out.println(x.key+"---&gt;"+x.val); PreOrderTraversal(x.left); PreOrderTraversal(x.right); &#125; &#125;/* //非递归实现 private void PreOrderTraversal(Node x)&#123; &#125;*/ //中序遍历(左子树-&gt;根节点-&gt;右子树) //递归实现 private void InOrderTraversal(Node x) &#123; if(x!=null)&#123; PreOrderTraversal(x.left); System.out.println(x.key+"---&gt;"+x.val); PreOrderTraversal(x.right); &#125; &#125; //后序遍历(左子树-&gt;右子树-&gt;根节点 ) //递归实现 private void PostOrderTraversal(Node x) &#123; if(x!=null)&#123; PreOrderTraversal(x.left); PreOrderTraversal(x.right); System.out.println(x.key+"---&gt;"+x.val); &#125; &#125; &#125; 基本操作算法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198public class BST&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123; private Node root; public class Node&#123; private Key key; private Value val; private Node left; private Node right; private int N; public Node(Key key,Value val,int N)&#123; this.key=key; this.val=val; this.N=N; &#125; &#125; public int size(Node x)&#123; if(x==null)&#123; return 0; &#125;else&#123; return x.N; &#125; &#125; public void put(Key key,Value val)&#123; root=put(root,key,val); &#125; private Node put(Node x,Key key,Value val)&#123; if(x==null)&#123; return new Node(key,val,1); &#125; int cmp=key.compareTo(x.key); if(cmp&gt;0)&#123; x.right=put(x.right,key,val); &#125;else if(cmp&lt;0)&#123; x.left=put(x.left,key,val); &#125;else&#123; x.val=val; &#125; x.N=size(x.left)+size(x.right)+1; return x; &#125; public Value get(Key key)&#123; return get(root,key); &#125; private Value get(Node x,Key key)&#123; if(x==null)&#123; return null; &#125; int cmp=key.compareTo(x.key); if(cmp&gt;0)&#123; return get(x.right,key); &#125;else if(cmp&lt;0)&#123; return get(x.left,key); &#125;else&#123; return x.val; &#125; &#125; public Key min()&#123; return min(root).key; &#125; private Node min(Node x)&#123; if(x.left==null)&#123; return x; &#125; return min(x.left); &#125;/* //非递归实现 private Key min(Node x)&#123; if(x!=null)&#123; while(x.left!=null)&#123; x=x.left; &#125; &#125; return x; &#125;*/ //max()同理 public Key floor(Key key)&#123; Node x=floor(root,key); if(x==null)&#123; return null; &#125; return x.key; &#125; private Node floor(Node x,Key key)&#123; if(x==null)&#123; return null; &#125; int cmp=key.compareTo(x.key); if(cmp==0)&#123; return x; &#125;else if(cmp&lt;0)&#123; return floor(x.left,key); &#125;else&#123; //注意在右侧查找时可能找不到，这是应返回根节点，而不是在右侧直接返回 Node t=floor(x.right,key); if(t==null)&#123; return x; &#125;else&#123; return t; &#125; &#125; &#125; //ceiling同理 public Key select(int k)&#123; return select(root,k).key; &#125; private Node select(Node x,int k)&#123; if(x==null)&#123; return null; &#125; int t=size(x.left); if(t==k)&#123; return x; &#125;else if(t&gt;k)&#123; return select(x.left,k); &#125;else&#123; //注意右子树查找的数量 k-t-1 return select(x.right,k-t-1); &#125; &#125; public int rank(Key key)&#123; return rank(root,key); &#125; private int rank(Node x,Key key)&#123; if(x==null)&#123; return 0; &#125; int cmp=key.compareTo(x.key); if(cmp==0)&#123; return size(x.left); &#125;else if(cmp&lt;0)&#123; return rank(x.left,key); &#125;else&#123; //注意在右侧查找后返回的元素包括根节点和左子树元素 return rank(x.right,key)+size(x.left)+1; &#125; &#125; public void deleteMin()&#123; root=deleteMin(root); &#125; private Node deleteMin(Node x)&#123; if(x.left==null)&#123; return x.right; &#125; x.left=deleteMin(x.left); x.N=size(x.left)+size(x.right)+1; return x; &#125; //deleteMax()同理 //删除操作，删除一个元素时用这个节点右子树的最小值或者左子树的最大值代替 public void delete(Key key)&#123; root=delete(root,key); &#125; private Node delete(Node x,Key key)&#123; if(x==null)&#123; return null; &#125; int cmp=key.compareTo(x.key); if(cmp&lt;0)&#123; delete(x.left,key); &#125;else if(cmp&gt;0)&#123; delete(x.right,key); &#125;else&#123; if(x.left==null)&#123; return x.right; &#125; if(x.right==null)&#123; return x.left; &#125; Node t=x; x=min(t.right); x.right=deleteMin(t.right); x.left=t.left; &#125; x.N=size(x.left)+size(x.right)+1; return x; &#125; //范围查找 public Iterable&lt;Key&gt; keys(Key lo,Key hi)&#123; Queue&lt;Key&gt; queue=new Queue&lt;Key&gt;(); keys(root,queue,lo,hi); return queue; &#125; private void keys(Node x,Queue&lt;Key&gt; queue,Key lo,Key hi)&#123; if(x==null)&#123; return; &#125; int cmplo=lo.compareTo(x.key); int cmphi=hi.compareTo(x.key); if(cmplo&lt;=0 &amp;&amp; cmphi&gt;=0)&#123; queue.enqueue(x.key); &#125; if(cmphi&gt;0)&#123; keys(x.right,queue,lo,hi); &#125; if(cmplo&lt;0)&#123; keys(x.left,queue,lo,hi); &#125; &#125;&#125; 二叉查找树实现的符号表的时间复杂度是lgN,最坏情况下为N]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-查找(符号表)]]></title>
    <url>%2F2018%2F09%2F08%2FJava%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE-%E7%AC%A6%E5%8F%B7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[符号表定义定义：符号表是一种存储键值对的数据结构，支持两种操作：插入(put)，将一组新的键值对存入表中;查找(get),根据给定的键值的到对应的值。 一种有序的泛型符号表的API实现的对字符表的操作 字符表的实现无序链表实现无序字符表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 public class SequentialSearchST&lt;Key, Value&gt; &#123; private int n; // number of key-value pairs private Node first; // the linked list of key-value pairs // a helper linked list data type private class Node &#123; private Key key; private Value val; private Node next; public Node(Key key, Value val, Node next) &#123; this.key = key; this.val = val; this.next = next; &#125; &#125; public SequentialSearchST() &#123;&#125; public int size() &#123; return n; &#125; public boolean isEmpty() &#123; return size() == 0; &#125; public boolean contains(Key key) &#123; if (key == null) throw new IllegalArgumentException("argument to contains() is null"); return get(key) != null; &#125; public Value get(Key key) &#123; if (key == null) throw new IllegalArgumentException("argument to get() is null"); for (Node x = first; x != null; x = x.next) &#123; if (key.equals(x.key)) return x.val; &#125; return null; &#125; public void put(Key key, Value val) &#123; if (key == null) throw new IllegalArgumentException("first argument to put() is null"); if (val == null) &#123; delete(key); return; &#125; for (Node x = first; x != null; x = x.next) &#123; if (key.equals(x.key)) &#123; x.val = val; return; &#125; &#125; first = new Node(key, val, first); n++; &#125; /** * Removes the specified key and its associated value from this symbol table * (if the key is in this symbol table). * * @param key the key * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125; */ public void delete(Key key) &#123; if (key == null) throw new IllegalArgumentException("argument to delete() is null"); first = delete(first, key); &#125; // delete key in linked list beginning at Node x // warning: function call stack too large if table is large private Node delete(Node x, Key key) &#123; if (x == null) return null; if (key.equals(x.key)) &#123; n--; return x.next; &#125; x.next = delete(x.next, key); return x; &#125; /** * Returns all keys in the symbol table as an &#123;@code Iterable&#125;. * To iterate over all of the keys in the symbol table named &#123;@code st&#125;, * use the foreach notation: &#123;@code for (Key key : st.keys())&#125;. * * @return all keys in the symbol table */ public Iterable&lt;Key&gt; keys() &#123; Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); for (Node x = first; x != null; x = x.next) queue.enqueue(x.key); return queue; &#125; 基于链表的实现及顺序查找是非常低效的向一个空表中插入N个不同的键需要~N*N/2次比较 基于有序数组的二分查找实现有序字符表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public class BinarySearchST&lt;Key extends Comparable&lt;Key&gt;,Value&gt; &#123; private Key[] keys; private Value[] vals; private int N=0; //构造方法，初始化 public BinarySearchST(int capacity)&#123; keys=(Key[]) new Comparable[capacity]; vals=(Value[]) new Object[capacity]; &#125; public int size()&#123; return N; &#125; public boolean isEmpty()&#123; return N==0; &#125; public boolean contains(Key key)&#123; if(key==null)&#123; throw new IllegalArgumentException("argument to contains() is null"); &#125; return get(key)!=null; &#125; //二分查找 //迭代法 private int rank(Key key)&#123; int lo=0; int hi=N-1; while(lo&lt;=hi)&#123; int mid=lo+(hi-lo)/2; int cmp=keys[mid].compareTo(key); if(cmp&gt;0)&#123; hi=mid-1; &#125;else if(cmp&lt;0)&#123; lo=mid+1; &#125;else&#123; return mid; &#125; &#125; return lo; &#125; /* 递归法实现二分查找 public int rank(Key key,int lo,int hi)&#123; if(hi&lt;lo)&#123; return lo; &#125; int mid=lo+(hi-lo)/2; int cmd=keys[mid].compareTo(key); if(cmd&gt;0)&#123; return rank(key,lo,mid-1); &#125;else(cmd&lt;0)&#123; return rank(key,mid+1,hi); &#125;else&#123; return mid; &#125; &#125;*/ public Value get(Key key)&#123; if(key==null)&#123; throw new IllegalArgumentException("argument to get() is null"); &#125; if(isEmpty())&#123; return null; &#125; int i=rank(key); if(i&lt;N &amp;&amp; keys[i].compareTo(key)==0)&#123; return vals[i]; &#125;else&#123; return null; &#125; &#125; public void put(Key key,Value val)&#123; if(key==null)&#123; throw new IllegalArgumentException("argument to put() is null"); &#125; if(val==null)&#123; delete(key); return; &#125; int i=rank(key); if(i&lt;N &amp;&amp; keys[i].compareTo(key)==0)&#123; vals[i]=val; return; &#125; for(int j=N;j&gt;i;j--)&#123; keys[j]=keys[j-1]; vals[j]=vals[j-1]; &#125; keys[i]=key; vals[i]=val; N++; &#125; public void delete(Key key)&#123; if(key==null)&#123; throw new IllegalArgumentException("argument to delete() is null"); &#125; if(isEmpty())&#123; return; &#125; int i=rank(key); if(i==N || keys[i].compareTo(key)!=0)&#123; return; &#125; for(int j=i;j&lt;N-1;j++)&#123; keys[j]=keys[j+1]; vals[j]=vals[j+1]; &#125; N--; keys[N]=null; vals[N]=null; &#125; public Key min()&#123; return keys[0]; &#125; public Key max()&#123; return keys[N-1]; &#125; public Key select(int k)&#123; return keys[k]; &#125; public Key ceiling(Key key)&#123; int i=rank(key); return keys[i]; &#125; public Key floor(Key key)&#123; if (key == null) throw new IllegalArgumentException("argument to floor() is null"); int i = rank(key); if (i &lt; N &amp;&amp; key.compareTo(keys[i]) == 0) &#123; return keys[i]; &#125;else&#123; return keys[i-1]; &#125; &#125; public Iterable&lt;Key&gt; keys(Key lo,Key hi)&#123; Queue&lt;Key&gt; queue=new Queue&lt;Key&gt;(); for(int i=rank(lo);i&lt;rank(hi);i++)&#123; queue.enqueue(keys[i]); &#125; if(contains(keys[rank(hi)]))&#123; queue.enqueue(keys[rank(hi)]); &#125; return queue; &#125;&#125; 算法分析： 有序数组二分查找的各个操作的成本: BinarySearchST的算法实现了最优的查找效率~lgN，但是插入操作很慢~N，无法保证高效的查找和插入操作。]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java算法-排序（堆排序）]]></title>
    <url>%2F2018%2F09%2F04%2FJava%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%EF%BC%88%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[堆的定义堆这种数据结构是一种完全二叉树，堆分为最大堆和最小堆 最大堆：二叉树中的任一顶点大于等于它的左右子节点 最小堆：二叉树中的任一顶点小于等于它的左右子节点堆可以用数组来存储表示 优先队列优先队列（Priority Queue）：特殊的队列，取出元素的顺序按照元素的优先权或关键字的大小，不是元素入队的先后顺序。优先队列（堆）的使用场景： 1. 任何时候返回最值元素； 2. 数据太大存不下，要找出一定的最值元素； 3. 合并若干不同来源的已经排序的源（索引优先队列） 优先队列的实现方式： 基于堆的优先队列用堆实现优先队列的方法：注：以下代码存储数据时从数组的下标1开始代码实现：最大堆实现的最大优先队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 public class MaxPQ&lt;T extends Comparable&lt;T&gt;&gt;&#123; private T[] pq; //存队列数据的数组 private int N=0; //最终元素的个数 //构造函数 public MaxPQ(int maxN)&#123; pq=(T[])new Comparable[maxN+1]; &#125; //判断队列是否为空 public boolean isEmpty()&#123; return N==0; &#125; //返回队列元素个数 public int size()&#123; return N; &#125; //插入数据 public void insert(T v)&#123; pq[++N]=v; swim(N); &#125; //删除队列中最大元素并返回最大值 public T delMax()&#123; T max=pq[1]; exch(1,N--); pq[N+1]=null; sink(1); return max; &#125; //上浮 private void swim(int k)&#123; while(k&gt;1 &amp;&amp; less(k/2,k))&#123; exch(k/2,k); k=k/2; &#125; &#125; //下沉 private void sink(int k)&#123; while(2*k&lt;=N)&#123; int t=2*k; if(t&lt;N &amp;&amp; less(t,t+1))&#123; t++; &#125; if(less(k,t))&#123; exch(k,t); &#125;else&#123; break; &#125; k=t; &#125; &#125; private boolean less(int i,int j)&#123; return pq[i].compareTo(pq[j])&lt;0; &#125; private void exch(int i,int j)&#123; T temp=pq[i]; pq[i]=pq[j]; pq[j]=temp; &#125; public static void main(String[] args)&#123; MaxPQ&lt;Integer&gt; p=new MaxPQ&lt;Integer&gt;(10); int n=5; p.insert(88); p.insert(2); p.insert(56); p.insert(3); p.insert(42); while(n&gt;0)&#123; System.out.println(p.delMax()); n--; &#125; &#125;&#125; 代码实现的最主要的功能是实现元素的优先级，快速找到并删除最大元素，插入元素（自动调整）算法分析： 一颗大小为N的完全二叉树的高度为lgN； 含有N个元素的基于堆的优先队列，插入元素需要不超过lgN+1次比较，删除最大元素需要不超过2lgN次比较；最小堆实现的最小优先队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MinPQ&lt;T extends Comparable&lt;T&gt;&gt; &#123; private T[] pq; private int N; public MinPQ(int maxN)&#123; pq=(T[])new Comparable[maxN+1]; &#125; public boolean isEmpty()&#123; return N==0; &#125; public int size()&#123; return N; &#125; public void insert(T v)&#123; pq[++N]=v; swim(N); &#125; private void swim(int k)&#123; while(k&gt;1 &amp;&amp; less(k,k/2))&#123; exch(k,k/2); k=k/2; &#125; &#125; public T deleteMin()&#123; T min=pq[1]; exch(1,N--); sink(1); return min; &#125; private void sink(int k)&#123; while(2*k&lt;N)&#123; int t=2*k; if(t&lt;k &amp;&amp; less(t+1,t))&#123; t++; &#125; if(less(t,k))&#123; exch(t,k); &#125;else&#123; break; &#125; k=t; &#125; &#125; private boolean less(int v,int w)&#123; return pq[v].compareTo(pq[w])&lt;0; &#125; private void exch(int v,int w)&#123; T temp=pq[v]; pq[v]=pq[w]; pq[w]=temp; &#125;&#125; 索引优先队列优先队列的一个缺点是无法直接访问队列中的元素(除了直接找到最大或最小的元素)，对其更新修改。用过建立索引优先队列来实现快速索引。创建两个数组：elements[]用来存储队列中的对象(不需要按连续存储)，pq[]用来存储队列中每个对象在elements[]中的索引。 通过这两个数组建立的映射关系，在构建优先队列的时候，不需要变动elements[]，只需要维护改变pq中的元素即可。当向队列中插入一个新的对象时，在elements中存储该对象，将其索引存储在pq中，并对这个索引值进行上浮操作维护优先队列在操作队列时，如果想更改队列中某个对象，比如像将索引为3的位置改为”b”，那么直接操作elements[3]=”b”，这时需要重新调整维护优先队列，在pq数组中队值为3的元素操作，但是并不知道pq中那个位置的值是3，只能通过顺序遍历查找。为了方便查找pq中的元素，创建一个qp数组，将pq中元素作为索引在qp中存储该元素在pq中的索引。在队列的操作中经常要交换两个元素，交换pq中的两个元素的同事也要交换qp中相应位置的元素。索引最小优先队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class IndexMinPQ&lt;Key extends Comparable&lt;Key&gt;&gt; &#123; private int pq[]; private int qp[]; private Key keys[]; private int maxN; private int N; public IndexMinPQ(int maxN)&#123; this.maxN=maxN; N=0; pq=new int[maxN+1];//这些数组中0索引处不存储值 qp=new int[maxN+1]; keys=(Key[])new Comparable[maxN]; for(int i=0;i&lt;=maxN;i++)&#123; qp[i]=-1; &#125; &#125; public boolean isEmpty()&#123; return N==0; &#125; public int size()&#123; return N; &#125; public boolean contains(int i)&#123; //这里的i检查的是keys在索引i处是否有值 if(i&lt;0 || i&gt;maxN)&#123; throw new IllegalArgumentException(); &#125; return qp[i]!=-1; &#125; public void insert(int k,Key key)&#123; if ( k&lt; 0 || k&gt; maxN) throw new IllegalArgumentException(); if (contains(k)) throw new IllegalArgumentException("index is already in the priority queue"); keys[k]=key; pq[++N]=k; qp[k]=N; swim(N); &#125; //返回队列中的最小值 public Key minKey()&#123; return keys[pq[1]]; &#125; //删除并返回队列中的最小值 public Key deleteMin()&#123; if (N == 0) throw new NoSuchElementException("Priority queue underflow"); Key min=keys[pq[1]]; pq[1]=pq[N--]; sink(1); return min; &#125; //删除并返回队列中的某个值 public void delete(int k)&#123; if (k &lt; 0 || k &gt; maxN) throw new IllegalArgumentException(); if (!contains(k)) throw new NoSuchElementException("index is not in the priority queue"); int index=qp[k]; pq[index]=pq[N--]; swim(index); sink(index); keys[k]=null; qp[k]=-1; &#125; //改变队列中某个对象的值 public void changeKey(int k,Key key)&#123; if (k &lt; 0 || k &gt; maxN) throw new IllegalArgumentException(); if (!contains(k)) throw new NoSuchElementException("index is not in the priority queue"); keys[k]=key; swim(qp[k]); sink(qp[k]); &#125; //上浮调整 private void swim(int k)&#123; while(k&gt;1)&#123; if(less(k,k/2))&#123; exch(k,k/2); &#125; k=k/2; &#125; &#125; //下沉调整 private void sink(int k)&#123; while(2*k&lt;=N)&#123; int t=2*k; if(t&lt;N &amp;&amp; less(t+1,t))&#123; t=t+1; &#125; if(less(k,t))&#123; exch(k,t); &#125;else&#123; break; &#125; k=t; &#125; &#125; private boolean less(int k,int v)&#123; return keys[pq[k]].compareTo(keys[pq[v]])&lt;0; &#125; private void exch(int k,int v)&#123; int temp=pq[k]; pq[k]=pq[v]; pq[v]=temp; qp[pq[k]]=k; qp[pq[v]]=v; &#125;&#125; 堆排序堆排序分为两个阶段，给定一个无序的数组，首先要做的事构造堆。a.将无需序列构建成一个堆，根据升序降序需求选择最大堆或最小堆;b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端，N–将最大的元素固定,再次调整不在去管它;c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。对于给定的无序构造堆的一个高效方法就是从右向左进行sink下沉操作，不需要管叶子结点（叶子结点已经算作一个有堆，无法进行下沉操作），所以只需要扫描一半的数组元素。示意图：堆排序算法实现：123456789101112131415161718192021222324252627282930313233343536373839 public class HeapSort&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; @Override public void sort(T[] a)&#123; //数组a[0]不存储哨兵，a[0]的值一般用作，从a[1]开始 int N=a.length-1; //构建堆 for(int k=N/2;k&gt;=1;k--)&#123; sink(a,k,N); &#125; //堆排序 while(N&gt;1)&#123; exch(a,1,N--); sink(a,1,N); &#125; &#125; private void sink(T[] a,int k,int N)&#123; while(2*k&lt;=N)&#123; int j=2*k; if(j&lt;N &amp;&amp; less(a[j],a[j+1]))&#123; j++; &#125; if(less(a[k],a[j]))&#123; exch(a,k,j); &#125;else&#123; break; &#125; k=j; &#125; &#125; public static void main(String[] args)&#123; HeapSort&lt;String&gt; b=new HeapSort&lt;String&gt;(); String[] str=&#123;"q","sss","aaa","ccc","qqq","bbb"&#125;; b.sort(str); for(int i=1;i&lt;=str.length-1;i++)&#123; System.out.println(str[i]); &#125; &#125;&#125; 算法分析： 用下沉法构建堆（N个元素）只需少于2N次比较和少于N次的交换； 对N个元素的堆排序，需要少于（2NlgN+2N)次比较，一半次数的交换； 多种算法比较快速排序是最快的通用排序方法因为快速排序内循环指令少，他还能利用缓存（因为总是顺序访问数组），时间复杂度都是~cNlgN,使用三向切分后可能将某些时间复杂度变为线性级的。 Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql]]></title>
    <url>%2F2018%2F09%2F04%2FMysql%2F</url>
    <content type="text"><![CDATA[Mysql基本操作登陆数据库： mysql -u root -p 退出数据库： exit; 数据库操作创建数据库 create database 数据库名; create database 数据库名 character set 字符集（utf8) collate 校对规则; 删除数据库 drop database 数据库名; 查看数据库 show databases -查看所有数据库 show create database 数据库名 -查看创建的数据库的信息 修改数据库 alter database 数据库名 选中使用数据库 use 数据库名 表的操作创建表 create table 表名{ 列名1 数据类型（长度）约束； 列名2 数据类型（长度） 约束； ...... } 数据类型：https://www.cnblogs.com/Caveolae/p/7058890.htmlhttps://www.cnblogs.com/-xlp/p/8617760.html 约束：主键：primary key （唯一，一个表只有一个主键） 第一种–单一主键：id int primary key（列级）第二种–复合主键：primary key（id，name）设置多个主键（表级）在主键中设置自增：id int primary key auto_increment 外键：foreign key （一个表可以有多个外键） foreign key(外键） references 另一个表名（要关联的键）给外键起名：constraint dpt_fk foreign key(外键名） conferences 表名（关联的键） 默认值：default 非空：not null age int not null; 唯一约束：unique 第一种：email varchar(32) unique （列级）第二种：unique（id，email） —组合约束 （表级）第三种：constraint 约束名 unique（email） —约束起名字（表级） 操作表表重命名： rename table old to new； 删除表： drop table 表名； 增加列： alter table 表名 add 列名 数据类型 约束 after 列名; 可以指定新增列的位置 删除列： alter table 表名 drop 列名; 修改列： alter table 表名 modify 列名 数据类型 约束 改变表中数据 插入数据 insert into 表名(列1，列2，...) values(值1，值2...) or insert into 表名(列1，2...) values(值1，值2...),(v1,v2..),(v1,v2...)... 修改数据： update 表名 set 列1=值1，列2=值2 where 条件 删除数据： delete from 表名 where 条件 查询select语句 select * from 表名; select 列1，列2，... from 表名; select c1,c2,... from 表名 as 另一名; select c1 as p1,c2 as p2,... from 表名; select distinct c from 表名; ---去掉重复值 运算查询： select *,列的运算 as 名 from 表名; 条件查询： where 条件 select 查询内容 from 表名 where 条件 关系运算符 逻辑运算符 模糊查询 like where c like &apos;条件&apos; -：代表单个字符 %：代表多个字符 范围查询 in where c in (a1,a2,a3...) 排序查询： order by c asc/desc asc:ascend 升序 desc:descend 降序 聚合函数： select sum(number) from 表名; sum() avg() count() max() min() 分组： group by having:在group后，可以接聚合函数 where:在group之前，不可以接聚合函数 select ... from ... where ... group by ... having ... order by ...]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-排序（简单排序）]]></title>
    <url>%2F2018%2F08%2F20%2FJava%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%EF%BC%88%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[算法模板Comparable接口 Interface Comparable&lt;T&gt; 该接口对实现它的每个类的对象强加一个整体排序，这个排序被称为类的自然排序，类的compareTo方法被称为其自然比较方法 **int compareTo(T o)** 将此对象与指定的对象进行比较以进行排序 返回一个负整数，零或正整数，因为该对象小于，等于或大于指定对象 compareTo() 必须实现一个完整的比较序列，即： 自反性，对于所有的 v ， v=v ； 反对称性，对于所有的 v&lt;w 都有 v&gt;w ，且 v=w 时 w=v ； 传递性，对于所有的 v 、 w 和 x ，如果 v&lt;=w 且 w&lt;=x ，则 v&lt;=x 。 算法模板： 1234567891011121314151617181920212223242526272829public abstract class Sort&lt;T extends Comparable&lt;T&gt;&gt;&#123; public static void sort(T[] a)&#123; &#125; //比较数据大小 protected static boolean less (Tv,T w)&#123; return v.compareTo(w)&lt;0; &#125; //交换数据 protected static void exch(T[] a,int i,int j)&#123; T temp=a[i]; a[i]=a[j]; a[j]=temp; &#125; //输出显示排序好的数据 protected static void show(T[] a)&#123; for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]+" "); &#125; System.out.println(); &#125; //判断是否排序 public static boolean isSorted(T[] a)&#123; for(int i=1;i&lt;a.length;i++)&#123; if(less(a[i],a[i-1])) return false; &#125; return true; &#125;&#125; 注意：只要是实现了Comparable（自己定义的数据类型要重写compareTo方法）的数据类型都可以用次模板排序 选择排序12345678910111213public class Selection&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; @Override public static void sort(T[] a)&#123; int N=a.length; for(int i=0;i&lt;N;i++)&#123; int min=i; for(int j=i+1;j&lt;N;j++)&#123; if(less(a[j],a[min])) min=j; &#125; exch(a,i,min); &#125; &#125;&#125; 选择排序： 首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。 算法分析： 选择排序的效率取决于交换的次数：对于长度为 N 的数组，选择排序需要大约 N 2 /2 次比较和 N 次交换时间复杂度 T(N)=O(N*N); 运行时间和输入无关:已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间一样长 数据移动是最少的:选择排序用了 N 次交换,交换次数和数组的大小是线性关系 冒泡排序冒泡排序：从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。在一轮循环中，如果没有发生交换，就说明数组已经是有序的，此时可以直接退出。 12345678910111213141516public class Bubble&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; @Override public static void sort(T[] a)&#123; int N=a.length; boolean flag=false; for(int i=N-1;i&gt;0 &amp;&amp; !flag;i--)&#123; flag=true; for(int j=0;j&lt;i;j++)&#123; if(less(a[j+1],a[j]))&#123; exch(a,j,j+1); flag=false; &#125; &#125; &#125; &#125;&#125;``` 插入排序12345678910public class Insertion&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; public static &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] a)&#123; int N=a.length; for(int i=1;i&lt;N;i++)&#123; for(int j=i;j&gt;0 &amp;&amp; less(a[j],a[j-1]);j--)&#123; exch(a,j,j-1); &#125; &#125; &#125;&#125; 算法分析： 对于随机排列的长度为 N 且主键不重复的数组，平均情况下插入排序需要～ N 2 /4 次比较以及～ N 2 /4 次交换。最坏情况下需要～ N 2 /2 次比较和～ N 2 /2 次交换，最好情况下需要 N-1次比较和 0 次交换时间复杂度 T(N)=O(N*N) 插入排序所需的时间取决于输入中元素的初始顺序 插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一 插入排序对于实际应用中常见的某些类型的非随机数组很有效插入排序对于部分有序的数组十分高效，也很适合小规模数组 比较：对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数 希尔排序希尔排序：对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。 1234567891011121314151617public class Shell&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;&#123; public static &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] a)&#123; int N=a.length; int h=1; while(h&lt;N/3)&#123; h=h*3+1; &#125; while(h&gt;=1)&#123; for(int i=h;i&lt;N;i++)&#123; for(int j=i;j&gt;0 &amp;&amp; less(a[j],a[j-h]);j-=h)&#123; exch(a,j,j-h); &#125; &#125; h=h/3; &#125; &#125;&#125; 算法的性能不仅取决于 h，还取决于 h 之间的数学性质 目前最重要的结论是希尔排序的运行时间达不到平方级别 希尔排序比插入排序和选择排序要快得多，并且数组越大，优势越大 MergeSort(归并排序)In-place merge(原地归并)1234567891011121314151617181920public class Merge&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; protected T[] aux; protected void merge(T[] a,int lo,int mid,int hi)&#123; int i=lo; //左边数组的起始位置 int j=mid+1; ////右边数组的起始位置 for(int k=lo;k&lt;=hi;k++)&#123; aux[k] =a[k]; &#125; for(int k=lo;k&lt;=hi;k++)&#123; if(i&gt;mid)&#123; a[k]=aux[j++]; //左边的子数组用尽 &#125;else if(j&gt;hi)&#123; a[k]=aux[i++]; //右边的子数组用尽 &#125;else if(less(aux[j],aux[i]))&#123; a[k]=aux[j++]; &#125;else&#123; a[k]=aux[i++]; &#125; &#125; &#125; This method merges by first copying into the auxiliary array aux[] then merging back to a[]. In the merge (the second for loop), there are four conditions: left half exhausted (take from the right), right half exhausted (take from the left), current key on right less than current key on left (take from the right), current key on right greater than or equal to current key on left (take from the left). Top-down mergesort(自顶向下的归并排序)123456789101112131415public class UptoDpwnMergeSort&lt;T extends Comparable&lt;T&gt;&gt; extends Merge&#123; public void sort(T[] a)&#123; aux=(T[]) new Comparable[a.length]; sort(a,0,a.length-1); &#125; private void sort(T[] a,int lo,int hi)&#123; if(hi&lt;=lo)&#123; return; &#125; int mid=lo+(hi-lo)/2; sort(a,0,mid); sort(a,mid+1,hi); merge(a,lo,mid,hi); &#125;&#125; A: The code is a recursive(递归) mergesort implementation based on this abstract inplace merge. B: It is one of the best-known examples of the utility of the divide-and-conquer(分而治之) paradigm for efficient algorithm design C: the sort code simply provides an organized way to sequence the calls to the merge() method 算法分析： A: Top-down mergesort uses between ½ N lg N and N lg N compares to sort any array of length N时间复杂度：T(N)=O(N lg N) B: Top-down mergesort uses at most 6N lg N array accesses to sort an array of length N Bottom-up mergesort(自底向上的排序)1234567891011public class BottomtoUpMergeSort&lt;T extends Comparable&lt;T&gt;&gt; extends Merge&lt;T&gt; &#123; public void sort(T[] a)&#123; int N=a.length; aux = (T[]) new Comparable[a.length]; for(int sz=1;sz&lt;N;sz=sz+sz)&#123; for(int lo=0;lo&lt;N-sz;lo+=sz+sz)&#123; merge(a,lo,lo+sz-1,Math.min(lo+sz+sz-1, N-1)); &#125; &#125; &#125;&#125; 算法分析：Bottom-up mergesort uses between ½ N lg N and N lg N compares and at most 6N lg N array accesses to sort an array of length N. both the number of compares usedby mergesort in the worst case and the minimum number of compares that any compare-basedsorting algorithm can guarantee are ~N lg N 归并排序在最坏的情况下的比较次数和任意基于比较的排序算法所需的最少比较次数都是~ NlgN]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-排序（快速排序）]]></title>
    <url>%2F2018%2F08%2F18%2FJava%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%EF%BC%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[QuickSort（快速排序）The basic algorithm（基本算法）归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Quick&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; public void sort(T[] a)&#123; shuffe(a); //消除对输入的依赖 sort(a,0,a.length-1); &#125; private void sort(T[] a, int lo, int hi) &#123; if(hi&lt;=lo)&#123; return; &#125; int j=partition(a,lo,hi); //切分 sort(a,lo,j-1); //将左半边排序 sort(a,j+1,hi); //将右半边排序 &#125; //切分方法 private int partition(T[] a, int lo, int hi) &#123; int i=lo; int j=hi+1; T v=a[lo]; //选取lo处的元素作为分界元素 while(true)&#123; //从左向右扫描找到比v大的元素 while(less(a[++i],v))&#123; if(i==hi)&#123; break; &#125; &#125; //从右向左扫描找到比v小的元素 while(less(v,a[--j]))&#123; if(j==lo)&#123; break; &#125; &#125; if(i&gt;=j)&#123; break; &#125; exch(a,i,j);y &#125; exch(a,lo,j); return j; &#125; //打乱数组 private void shuffe(T[] a)&#123; List&lt;T&gt; list=Arrays.asList(a); Collections.shuffle(list); list.toArray(a); &#125;&#125; Performance characteristics（性能分析）A: advantagea: it is in-place (uses only a small auxiliary stack) (原地排序)b: it requires time proportional to N log N on the average to sort an array of length N (时间复杂度T(N)=O(NlgN))c: the inner loop of quicksort (in the partitioning method) increments an index and compares an array entry against a fixed value.(内循环短小) B: The best case for quicksort is when each partitioning stage divides the array exactlyin half. This circumstance would make the number of compares used by quicksort satisfy the divide-and-conquer recurrence CN = 2CN/2 + N，this recurrence has the solution CN ~ N lg N C: Quicksort uses ~ 2N ln N compares (and one-sixth that many exchanges)on the average to sort an array of length N with distinct keys. D: Quicksort uses ~ N * N/2 compares in the worst case, but random shuffling protects against this case.(最坏情况) Algorithmic improvements(算法改进)Cutoff to insertion sort (切换到插入排序)对小数组排序时插入排序的效率比快速排序的效率高，以为快速排序递归在小数组中调用自己耗费时间改进方法：将 if(hi&lt;=lo) return; 改为 if(hi&lt;=lo+M){ Insertion(a,lo,hi); return; } The optimum value of the cutoff M is system-dependent, but any value between 5 and 15 is likely to work well in most situations 这种方法主要用于提高对小型数组排序的速度问题 Median-of-three partitioning（三取样切分）Entropy-optimal sorting（三向切分的快速排序）这种算法是为了提高有大量重复元素的数组的排序效率，通过选定特定的切分元素v将数组切分为三个部分，小于v的元素、大于v的元素和小于v的元素123456789101112131415161718192021222324252627282930313233public class Quick3way&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; @Override public void sort(T[] a)&#123; shuffe(a); sort(a,0,a.length-1); &#125; private void sort(T[]a,int lo,int hi)&#123; if(hi&lt;=lo)&#123; return; &#125; int lt=lo; int i=lo+1; int gt=hi; T v=a[lo]; while(i&lt;=gt)&#123; int tep=a[i].compareTo(v); if(tep&lt;0)&#123; exch(a,i++,lt++); &#125;else if(tep&gt;0)&#123; exch(a,i,gt--); &#125;else&#123; i++; &#125; &#125; sort(a,lo,lt-1); sort(a,gt+1,hi); &#125; private void shuffe(T[] a)&#123; List&lt;T&gt; list=Arrays.asList(a); Collections.shuffle(list); list.toArray(a); &#125;&#125; 算法分析： 对于包含大量重复元素的数组，三向切分的快速算法比标准的快速算法效率高的多，排序时间从线性对数级降低到了线性级别。对于一个数组，它的所有主键的香农信息量 H=-(p1lgp1+p2lgp2 +…+pnlgpn) 大小为N的数组，三向切分需要~（2ln2)NH次比较 三向切分最坏的情况是当所有的主键不重复时，H=lgN，时间复杂度为NlgN，是线性对数级别的；一般情况下，三向切分的运行时间和输入的信息量的N倍成正比，是线性级别的。]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-基本数据结构]]></title>
    <url>%2F2018%2F08%2F18%2FJava%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基本数据结构数组链表链表的节点表示1234public class Node&lt;Item&gt;&#123; Item item; Node next; &#125; 栈用链表实现栈 public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt;{ //栈顶指针 private Node first; //栈中元素数量 private int N; //定义节点 private class Node{ Item item; Node next; } //判断栈是否为空 public boolean isEmpty(){ return first==null; } //返回栈中元素数量 public int size(){ return N; } //压栈 public void push(Item item){ Node oldfirst=first; first=new Node(); first.item=item; first.next=oldfirst; N++; } //出栈 public Item pop(){ if(isEmpty()){ try { throw new Exception("stack is empty"); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } } Item item=first.item; first=first.next; N--; return item; } public Iterator&lt;Item&gt; iterator(){ return new Iterator&lt;Item&gt;(){ private Node current=first; @Override public boolean hasNext(){ return current!=null; } @Override public Item next(){ Item item=current.item; current=current.next; return item; } public void remove(){} }; } } 队列用链表实现队列 public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt; { private Node first; private Node last; private int N; private class Node{ Item item; Node next; } //判断队列是否为空 public boolean isEmpty(){ return N==0; } //返回队列中元素个数 public int size(){ return N; } //入队 public void enqueue(Item item){ Node oldlast=last; last=new Node(); last.item=item; last.next=null; if(isEmpty()){ first=last; }else{ oldlast.next=last; } N++; } //出队 public Item dequeue(){ if(isEmpty()){ try { throw new Exception("queue is empty"); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } } Item item=first.item; first=first.next; N--; if(isEmpty()){ last=null; } return item; } public Iterator&lt;Item&gt; iterator(){ return new Iterator&lt;Item&gt;(){ private Node current=first; @Override public boolean hasNext(){ return current!=null; } @Override public Item next(){ Item item=current.item; current=current.next; return item; } public void remove(){} }; } }]]></content>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-集合（容器）]]></title>
    <url>%2F2018%2F08%2F17%2FJava-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Collection网上博客教程：https://blog.csdn.net/feiyanaffection/article/details/81394745 public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; Collection接口的常用方法 添加功能 boolean add(E e) boolean addAll(Collection&lt;? extends E&gt; c) 添加一个集合的元素 删除功能 void clear() 从此集合中删除所有元素 boolean remove(Object o) boolean removeAll(Collection&lt;?&gt; c) 删除指定集合中包含的所有此集合的元素 判断功能 boolean contains(Object o) 如果此集合包含指定的元素，则返回true boolean containsAll(Collection&lt;?&gt; c) 如果此集合包含指定 集合中的所有元素，则返回true boolean isEmpty() 如果此集合不包含元素，则返回 true 长度功能 int size() 返回此集合中的元素数 交集功能 boolean retainAll(Collection&lt;?&gt; c) 两个集合都有的元素 a.retainAll(b) a和b做交集，结果保存在a中，b不变，返回的boolean值表示a是否发生变化 一、List public interface List&lt;E&gt; extends Collection&lt;E&gt; List-有序集合（存储和取出的元素一致）（也称为序列 ），可以精确控制列表中每个元素的插入位置，通过整数索引（列表中的位置）访问元素，并搜索列表中的元素，列表通常允许重复的元素 List的特有方法 void add(int index,E element) 将指定的元素插入此列表中的指定位置 E get(int index) 返回此列表中指定位置的元素 ListIterator&lt;E&gt; listIterator() 返回列表中的列表迭代器（按适当的顺序） E remove(int index) 删除该列表中指定位置的元素 E set(int index, E element) 用指定的元素替换此列表中指定位置的元素 List的类型分类各类型特点对比： ArrarList：底层数据结构是数组，查询快，增删慢 线程不安全，效率高 Vector： 底层数据结构是数组，查询快，增删慢 线程安全，效率低 LinkedList：低层数据结构是链表，查询慢（只能顺序访问），增删快 线程不安全，效率高 LinkedList还可以用作栈、队列、双向队列 LinkedListLinkedList的基本方法： public void addFirst(E e) 在列表的头部插入元素 public void addLast(E e) 在列表尾部插入元素 public E getFirst() 返回此列表中的第一个元素。 public E getLast() 返回此列表中的最后一个元素 public E removeFirst() 从此列表中删除并返回第一个元素 public E removeLast() 从此列表中删除并返回最后一个元素 二、迭代器 迭代器是一种对象，它的功能是遍历并选择序列中的对象。 Iterator迭代器Collection 实现了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。 Collection获取迭代器的方法： Iterator&lt;E&gt; iterator() 返回此集合中的元素的迭代器 Iterator接口的常用方法： boolean hasNext() 判断集合里是否有元素 E next() 获取元素并移动到下一个元素 集合的使用步骤： A:创建集合对象 Collection c = new ArrayList(); B:创建元素对象 Object obj=..... C：元素添加到集合 c.add(obj) D：遍历集合元素 a:用过集合获取迭代器对象 Iterator it = c.iterator() b:通过迭代器对象的hasNext()方法判断是否有元素 boolean flag = it.hasNext() c:通过迭代器next()方法获取元素 Object obje = it.next() 集合的遍历（以List类型为例，Set同理）第一种：迭代器遍历 //部分伪代码，E代表某种类型 List&lt;E&gt; list=new List&lt;E&gt;(); list.add(E a); list.add(E b); //假设list里已经添加多个E类型的对象，可以遍历 Iterator it=list.iterator(); while(it.hasNext()){ E e=it.next(); print(e); } 第二种：foreach方法（增强for循环） List&lt;E&gt; list=new List&lt;E&gt;(); list.add(E a); list.add(E b); ....... for(E e:list){ print(e); } ------------------- List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); for (String item : list) { System.out.println(item); } ListIteratorListIterator是Iterator的子类，只用于List类集合，Iterator只能单向移动，而ListIterator可以双向移动主要方法： 继承了Iterator的功能（hasNext(),next()) boolean hasPrevious() 返回true如果遍历反向列表，列表迭代器有多个元素 E previous() 返回列表中的上一个元素，并向后移动光标位置 int nextIndex() 返回由后续调用返回的元素的索引next() int previousIndex() 返回由后续调用previous()返回的元素的索引 三、Set与List集合不同的是，Set集合不保存重复的元素 TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素&gt;的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1),TreeSet 则为 O(logN) HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的 LinkedHashSet：具有 HashSet的查找效率，且内部使用双向链表维护元素的插入顺序 HashSet提供最快的查询速度，TreeSet保持元素处于排序状态，LinkedHashSet以插入顺序保存元素 HashSet保证集合元素唯一性的原理： 主要取决于HashSet的add()方法， add()方法中主要依赖于String.hashCode()和String.equals()方法, 定义类时应该重写这两个方法 TreeSet（排序，唯一不重复）: 基于TreeMap实现，使用元素的自然顺序对元素进行排序，或者使用set提供的comparator方法排序， 具体使用时取决于使用的构造方法 A:自然排序：真正依赖于compareTo()方法， 这个方法定义在Comparable中，所以想重写该方法，就要实现Comparable接口，这个接口表示自然排序 例如：定义学生类时实现Comparable接口 public class Student implements Comparable&lt;T&gt;{ @override public int compareTo(T t){ .......... 主要条件 次要条件 } } B:比较器排序:comparator方法, TreeSet的add()方法，是基于TreeMap方法的put()方法 public TreeSet(Comparator&lt;? super E&gt; comparator ) 构造一个新的，空的树集，根据指定的比较器进行排序 TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;(){ public int compare(Student s1,Student s2){ ........... } };) Mappublic interface Map&lt;K,V&gt; Map将键映射到值的对象。 地图不能包含重复的键; 每个键可以映射到最多一个值 Map的基本类型 TreeMap：基于红黑树实现，保证唯一性和排序 HashMap：基于哈希表实现 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。ConcurrentHashMap：现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序HashMap用来快速访问，TreeMap保持键排序，LinkedHashMap保持元素插入的顺序，也通过散列提供快速访问能力 Map基本方法功能 添加 V put(K key,V value) 将指定的值与该映射中的指定键相关联 如果键是第一次存储，直接存储元素，返回null； 如果不是第一次添加键值，就用新的值替换旧的值，并返回旧的值。 删除 void clear() 从该地图中删除所有的映射 V remove(Object key) 删除并返回 删除集合里存在的键，返回建的值，如果不存在返回null 判断 boolean containsKey(Object key) 如果此映射包含指定键的映射，则返回true boolean containsValue(Object value) 如果此映射将一个或多个键映射到指定的值，则返回true boolean isEmpty() 判断集合是否为空 获取 V get(Object key) 返回到指定键所映射的值 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此地图中包含的映射的Set视图 Set&lt;K&gt; keySet() 返回此地图中包含的键的Set视图 Collection&lt;V&gt; values() 返回此地图中包含的值的Collection视图 长度 int size() 返回此地图中键值映射的数量 Map集合的遍历 //创建集合 Map&lt;String,String&gt; map=new Map&lt;String,String&gt;(); //添加数据 map.put(&quot;德国&quot;,&quot;克罗斯&quot;); map.put(&quot;法国&quot;,&quot;格列兹曼&quot;); map.put(&quot;比利时&quot;,&quot;德布劳内&quot;); 方式一： //获取键值集合 Set&lt;String&gt; set=map.keySet(); for(String s:set){ v=map.get(s); System.out.println(s+&quot;---&gt;&quot;+v); } 方式二： //获取映射Set集合 Set&lt;Map.Entry&lt;String,String&gt; set=map.entrySet(); for(Map.Entry&lt;String,String&gt; m:set){ key=m.getKey(); value=m.getValue(); System.out.println(key+&quot;---&gt;&quot;+value); }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想-面向对象（基础）]]></title>
    <url>%2F2018%2F08%2F16%2FJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、关键字this关键字this关键字在方法内部使用，表示对“调用方法的那个对象”的引用，如果在方法内调用同一个类的另一个方法可以不使用this super关键字 this &amp;&amp; super A:this本类的引用，super代表父类存储空间的标识（看成对父类的引用） B:this.变量 ，super.变量 -----引用变量 this(.....) ，uper(.....) -----调用构造方法 this.成员方法 ，super.成员方法 -----调用成员方法 static关键字static的特点：1.类中static关键字修饰的变量（静态变量）被类的所有对象共享 class Static{ static int i=47; } 即使创建多个对象也共享同一个变量i： Static st1=new Static(); Static st2=new Static(); st1.i和st2.i指向同一个存储空间地址，有相同的值，也可以通过Static.i引用变量 2.类中static修饰的方法可以在不创建方法的前提下直接调用static修饰的方法不与包含它的类的任何对象关联在一起，不用创建对象通过类本身调用，这是static方法的主要用途 class Static{ public static void increment(){ Static.i++; } } 定义了一个静态方法，通过类直接调用：Static.increment() 3.静态是随着类的加载而加载,与对象无关 4.static方法没有this关键字 5.static方法不能调用非静态方法，反过来可以 6.所有构造方法都默认被static修饰 final关键字1.修饰数据声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量 final修饰基本类型（整型，浮点，字符等），表示一个常量，赋值后不可以改变 final修饰引用类型（类，接口，数组），final使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的 2.修饰方法 final修饰的方法不能被重写（private方法也不可重写） private方法隐式地被指定为final，如果在子类中定义的方法和基类中的一个private方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法 3.修饰类 final修饰的类不可以被继承 成员变量和局部变量 局部变量：在方法外---在栈内存 （变量没有默认初始值）---随之对象的创建产生，随着对象的消失 成员变量： 在方法内---在堆内存 （变量有默认初始值）--随着方法的调用产生 二、继承 java中继承的特点： A: 只支持单继承，不支持多继承 B: 支持多层继承 class A{} class B extends A{} class C extends B{} 注意事项 A:子类只能继承父类中非私有的成员（成员变量和成员方法） B:子类不能继承父类的构造方法，但可以通过super关键字去访问父类构造方法 1.访问权限包访问权限（friendly） ：默认的访问权限通常是包访问权限，当前包中所有其他类可以访问那个成员，对于这个包之外的所有类是privatepublic：公共的，谁都可以访问protected：继承访问权限private：私有的，除了包含该成员的类之外其他类无法访问！注意：a.类不可以用private，protected修饰，只可以是包访问权限和publicb.如果类的构造方法由private修饰，则无法创建该类的对象，从而禁止拥有该类的访问权限，但是任然可以调用访问该类中static修饰的成员 2.类间的关系组合 class Actor{ public void act() {} } class HappyActor{ public void act(){ print(&quot;HappyActor&quot;); } class SadActor{ public void act(){ print(&quot;SadActor&quot;); } } class Stage{ privat Actor actor=new HappyActor(); public void change(){ actor=new SadActor(); } public void perform(){ actor.act(); } } 继承代理 3.重写和重载 重写（Override） 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。 为了满足里式替换原则，重写有有以下两个限制： 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型。 使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。 重载（Overload） 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。 应该注意的是，返回值不同，其它都相同不算是重载。 三、多态1.多态的前提要有继承关系，要有方法重写，要有父类引用指向子类对象（父类 F = new 子类()) class fu{ public fu(){ } public void show(){ System.out.println(&quot;fu&quot;); } } class zi extends fu{ public void show(){ System.out.println(&quot;show zi&quot;); } public void method(){ Sysltem.out.println(&quot;method zi&quot;); } } class DuotaiDemo{ public static void main(String[] args){ fu f = new zi(); f.show(); } } 2.多态中成员访问特点 A:成员变量—编译看左边，运行看左边 B:构造方法—创建子类对象时，访问父类的构造方法，对父类的数据进行初始化 C:成员方法—编译看左边，运行看右边（因为有成员方法重写，所以调用子类） D:静态方法—编译看左边，运行看左边（静态只和类有关） 多态好处 ：提高了代码的维护性（继承）、扩展性（多态）弊端 ：不能使用子类的特有功能 对象间的转型:向下转型 父-&gt;子 zi z = (zi)f向上转型 子-&gt;父 fu f = new zi() 四、接口1.抽象类和抽象方法抽象类和抽象方法必须用abstract修饰 格式： abstract class 类名 {} public abstract void 方法名(); 特点： 抽样类中不一定有抽样方法，但是有抽样方法的类一定要定义成抽类 抽样类不能实例化，抽象类有构造方法，但不可以实例化，构造方法是给子类调用的 抽象类的子类：如果不想重写抽样方法，子类是一个抽样类，如果想重写抽样方法，子类是一个具体的类 成员特点： 成员变量：既可以是常量，也可以是变量 构造方法：有，用于子类访问父类数据初始化 成员方法：既可以是抽象的，也可以是非抽象的，成员方法是抽象的，子类必须得重写，成员方法是非抽象的，子类继承 2.接口interface产生一个完全抽象的类，此类没有提供任何相应的具体实现，它允许确定方法名、参数列表、和返回类型，但是没有任何方法体。 接口只提供了形式，而未提供任何具体实现 接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected 接口的字段默认都是 static 和 final 的 A.接口成员特点：成员变量：只能是常量，是静态的，默认修饰符 public static final构造方法：没有（所有类都默认继承object类）成员方法：只能是抽象方法，默认修饰符public B.比较 从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 C.使用选择 使用接口：a.需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；b.需要使用多重继承；c.创建不带任何方法定义和成员变量的基类； 使用抽象类：a.需要在几个相关的类中共享代码；b.需要能控制继承来的成员的访问权限，而不是都为 public；c.需要继承非静态和非常量字段； 在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低 D.关系类和类：继承关系，只能单继承，多层继承类和接口：实现关系，可以单实现也可以多实现，可以在继承一个类的同时实现多个接口接口和接口：继承关系，可以单继承，也可多继承 五、内部类匿名内部类内部类的简写前提：存在一个类和接口类名或接口 格式： new名 () { 方法重写; };本质是一个继承了该类或实现了接口的子类匿名对象 六、字符串String主要方法构造方法 public String() 空构造 public String(byte[] bytes) 把字节数组转换成字符串 public String(byte[] bytes,int offset,int length) 把字节数组一部分转换成字符串 public String(char[] value) 把字符数组转换成字符串 public String(char[] value,int offset,int count) 把字符数组一部分转换成字符串 public String(String original) eg. String s = new String(参数) 成员方法 **判断功能** public boolean equals(Object anObject) 比较字符串的内容是否相同 public boolean equalsIgnoreCase(String str) 比较字符串的内容是否相同，忽略大小写 public boolean contens(String str) 大的字符串是否包含小串 public boolean startsWith(String str) 判断字符串是否以某个特定的字符串开头 public boolean endsWith(String str) 判断字符串是否以某个特定的字符串结尾 public boolean isEmpty() 判断字符串是否为空 **获取功能** public int length() 获取字符串长度 public char charAt(int index) 返回索引处的字符 public int indexOf(int ch) 返回指定字符第一次出现的字符串内的索引 public int indexOf(String str) 返回指定子字符串第一次出现的字符串内的索引。 public int indexOf(int ch,int fromIndex) 返回指定字符第一次出现的字符串内的索引，以指定的索引开始搜索 public int indexOf(String str,int fromIndex) 返回指定子串的第一次出现的字符串中的索引，从指定的索引开始 public String substring(int beginIndex) 返回一个字符串，该字符串是此字符串的子字符串。 子字符串以指定索引处的字符开头，并扩展到该字符串的末尾 public String substring(int beginIndex,int endIndex) 返回一个字符串，该字符串是此字符串的子字符串，子串开始于指定beginIndex并延伸到字符索引endIndex - 1 **转换功能** public byte[] getBytes() 把字符串换换为字节数组 public toCharArray() 把字符串转换为字符数组 public static String valueof(char[] chs) 字符数组转化成字符串 public static String valueof(int i) 把int转化成字符串 public String toLowerCase() 字符串变小写 public String toUpperCase() 字符串变小写 public String concat(String str) 字符串拼接 **替换功能** public String replace(char old,char new); public String replace(String old,String new); **去除字符串开头结尾两个空格** public String trim(); **按字典顺序比较两个字符串** public int compareTo(String str); public int compareToIgnorceCase(String str); String, StringBuffer and StringBuilder 可变性String 不可变StringBuffer 和 StringBuilder 可变 线程安全String 不可变，因此是线程安全的StringBuilder 不是线程安全的StringBuffer 是线程安全的，内部使用 synchronized 进行同步 类型转换String和StringBuffer相互转换 String s = new String() A:StringBuffer sb = new StringBuffer(s) B:StringBuffer sd2 = new StringBuffer() sb2.append(s) StringBuffer sb = new Stringbuffer(&quot;java&quot;) A:String str = new String(sb) B:String str2 = sb.toString() String和int int a=100; String s2=String.valueOf(a); System.out.println(s2); String s =&quot;100&quot;; int y=Integer.parseInt(s); System.out.println(y);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-网络编程]]></title>
    <url>%2F2018%2F08%2F11%2FJava-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[网络编程的三要素IP地址 概念：IP地址是网络中计算机的唯一标识 IP的组成：网络号+主机号 java提供了InetAddress类来对IP地址解析和操作 确定主机名称的IP地址public static InetAddress getByName(String host)获取此IP地址的主机名 public String getHostName() 端口 端口是正在运行程序的标识 协议 UDP 将数据源和目的地封装在数据包中，无连接，是不可靠协议，不需要建立连接，速度快 TCP 建立连接，形成传输数据的通道，在连接中进行大数据量的传输，通过三次握手完成连接，是可靠地，效率会低 Socket网络编程Socket包含了IP地址和端口号Socket原理机制：通信的两端都有Socket，网络通信其实是Socket间的通信，数据在两个Socket间通过IO传输 UDP UDP使用DatagramSocket类用于发送和接收数据报数据包 构造方法：public DatagramSocket()—发送数据使用的构造方法public DatagramSocket(int port)—接收数据使用的构造方法主要成员方法：public void close()关闭此数据报套接字public void send(DatagramPacket p)从此套接字发送数据报包public void receive(DatagramPacket p)从此套接字接收数据报包 发送和接收的数据是DatagramPacket类的，该类表示数据报包，send方法中需要传递DatagramPacket对象 构造方法：public DatagramPacket(byte[] buf,int length,InetAddress address,int port)–发送数据使用的构造方法public DatagramPacket(byte[] buf,int length) –接收数据使用的构造方法buf - 分组数据length - 包长度address - 目的地址port - 目的端口号主要成员方法：public byte[] getData()返回数据缓冲区public int getLength()返回要发送的数据的长度或接收到的数据的长度public InetAddress getAddress()返回该数据报发送或接收数据报的计算机的IP地址 UDP协议发送数据 1.创建发送端Socket对象 2.创建数据并打包 3.调用Socket对象的发送方法发送数据 4.释放资源 下面为实现UDP协议发送数据 public class send{ public static void main(String[] args){ //创建发送端Socket DatagramSocket ds=new DatagramSocket(); //创建数据并打包 byte[] bys=&quot;UDP协议发送的数据&quot;.getBytes(); int length=bys.length; //发送数据的目的IP地址 InetAddress address=InetAddress.getByName(&quot;主机名&quot;)； //发送端计算机的端口 int port=10086; DatagramPacket dp=new DatagramPacket(bys,length,address,port); //发送数据 ds.send(dp); //释放资源 ds.close(); } } UDP协议接收数据1.创建接收端Socket2.创建数据包接收数据（接受容器）3.用Socket接受方法接收数据4.解析数据输出5.释放资源 下面为实现UDP协议接收数据 public class Receive { public static void main(String[] args) throws IOException { // TODO Auto-generated method stub //创建接收端Socket DatagramSocket ds=new DatagramSocket(10086); //创建数据包接收 byte[] bys=new byte[1024]; int length=bys.length; DatagramPacket dp=new DatagramPacket(bys,length); //接收数据 ds.receive(dp); //解析数据 InetAddress address=dp.getAddress(); String ip=address.getHostAddress(); byte[] bys2=dp.getData(); int len=dp.getLength(); String s=new String(bys2,0,len); System.out.println(ip+&quot;:&quot;+s); //释放资源 ds.close(); } } TCPTCP协议发送数据 （客户端）1.创建发送端Socket2.获取输出流写数据3.释放资源 TCP发送客户端使用的是Socket类 构造方法：public Socket(InetAddress address,int port)public Socket(String host,int port)主要成员方法：public void close()关闭public OutputStream getOutputStream()返回此套接字的输出流 public class TSend { public static void main(String[] args) throws IOException { //创建Socket Socket s=new Socket(&quot;daw-PC&quot;,10086); //获取输出流写数据 OutputStream os=s.getOutputStream(); os.write(&quot;TCP发送数据&quot;.getBytes()); //释放资源 s.close(); } } TCP协议接收数据（服务器）1.创建接收端Socket2.监听客户端连接，返回对应的Socket对象3.获取输入流读数据4.释放资源 TCP接收客户端使用的是ServeSocket类 构造方法：public ServerSocket(int port)成员方法：public Socket accept()监听 ，返回的是Scoket类，所以需要Socket类的方法Socket类的—public InputStream getInputStream()返回此套接字的输入流 public class TReceive { public static void main(String[] args) throws IOException { //创建接收端Socket ServerSocket ss=new ServerSocket(10086); //监听客户端 Socket s=ss.accept(); //获取输入流写数据 InputStream is=s.getInputStream(); byte[] bys=new byte[1024]; int len=is.read(bys); String str=new String(bys,0,len); System.out.println(str); //释放资源，注意不关闭服务器 s.close(); } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
