<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="一、Mybatis1. 什么是Mybatis？ Mybatis 是一个基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。   Mybatis是一个半ORM（对象关系映射）框架, 采用ORM思想解决了实体对象和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们">
<meta name="keywords" content="Java Internet of things Data Structure and Algorithms">
<meta property="og:type" content="article">
<meta property="og:title" content="SSM框架知识点总结">
<meta property="og:url" content="http://yoursite.com/2020/07/18/SSM框架知识点总结/index.html">
<meta property="og:site_name" content="Welcome Hexo">
<meta property="og:description" content="一、Mybatis1. 什么是Mybatis？ Mybatis 是一个基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。   Mybatis是一个半ORM（对象关系映射）框架, 采用ORM思想解决了实体对象和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.loli.net/2020/07/28/g4Je6wdhv18iVZk.jpg">
<meta property="og:image" content="https://i.loli.net/2020/07/28/godWnHZLwNOpXJ6.jpg">
<meta property="og:image" content="https://i.loli.net/2020/07/28/AL1J9dtmPyv7O8Y.jpg">
<meta property="og:image" content="https://i.loli.net/2020/07/28/HMqn1gma4lJzO5Y.jpg">
<meta property="og:image" content="https://i.loli.net/2020/07/28/wRE861QmJZsN3hB.jpg">
<meta property="og:image" content="https://i.loli.net/2020/07/28/NeEs1SigWPDGu87.jpg">
<meta property="og:image" content="https://i.loli.net/2020/07/28/PaVvNlMQxUJZWDY.jpg">
<meta property="og:image" content="https://i.loli.net/2020/09/20/fw89GrXFxNIsVjZ.png">
<meta property="og:updated_time" content="2020-09-21T12:09:39.433Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SSM框架知识点总结">
<meta name="twitter:description" content="一、Mybatis1. 什么是Mybatis？ Mybatis 是一个基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。   Mybatis是一个半ORM（对象关系映射）框架, 采用ORM思想解决了实体对象和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们">
<meta name="twitter:image" content="https://i.loli.net/2020/07/28/g4Je6wdhv18iVZk.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/07/18/SSM框架知识点总结/"/>





  <title>SSM框架知识点总结 | Welcome Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	
	<a href="https://github.com/guolipa" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    
	<header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Welcome Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Adventure Of Lifetime</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/18/SSM框架知识点总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="guoLipa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">SSM框架知识点总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-18T15:00:13+08:00">
                2020-07-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaWeb/" itemprop="url" rel="index">
                    <span itemprop="name">JavaWeb</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="一、Mybatis"><a href="#一、Mybatis" class="headerlink" title="一、Mybatis"></a>一、Mybatis</h1><h2 id="1-什么是Mybatis？"><a href="#1-什么是Mybatis？" class="headerlink" title="1. 什么是Mybatis？"></a>1. 什么是Mybatis？</h2><ul>
<li><p>Mybatis 是一个<strong><font color="red">基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身</font></strong>，而不需要花费精力去处理<strong><font color="red">加载驱动、创建连接、创建statement等</font></strong>繁杂的过程。 </p>
</li>
<li><p>Mybatis是一个半ORM（对象关系映射）框架, <font color="red"><strong>采用ORM思想解决了实体对象和数据库映射的问题</strong>，<strong>对jdbc进行了封装，屏蔽了jdbc api底层访问细节</strong></font>，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作</p>
</li>
<li><p>Mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。<font color="red">（从执行sql到返回result的过程）</font></p>
</li>
</ul>
<p><strong>JDBC:</strong><br>JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</p>
<p>JDBC是接口，而JDBC驱动才是接口的实现，没有驱动无法完成数据库连接！每个数据库厂商都有自己的驱动，用来连接自己公司的数据库。</p>
<p><strong>ORM简介:</strong>  </p>
<p><font color="red"><strong>对象关系映射（Object Relational Mapping，简称ORM）模式</strong>是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术</font>。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。</p>
<h2 id="2-Mybatis-的优缺点"><a href="#2-Mybatis-的优缺点" class="headerlink" title="2. Mybatis 的优缺点"></a>2. Mybatis 的优缺点</h2><h3 id="Mybaits的优点："><a href="#Mybaits的优点：" class="headerlink" title="Mybaits的优点："></a>Mybaits的优点：</h3><p>（1）基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。</p>
<p>（2）与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</p>
<p>（3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。</p>
<p>（4）能够与Spring很好的集成；</p>
<p>（5）提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</p>
<h3 id="MyBatis框架的缺点："><a href="#MyBatis框架的缺点：" class="headerlink" title="MyBatis框架的缺点："></a>MyBatis框架的缺点：</h3><p>（1）SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p>
<p>（2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p>
<p>MyBatis框架适用场合：</p>
<p>（1）MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。</p>
<p>（2）对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。</p>
<h2 id="3-MyBatis与Hibernate有哪些不同？"><a href="#3-MyBatis与Hibernate有哪些不同？" class="headerlink" title="3. MyBatis与Hibernate有哪些不同？"></a>3. MyBatis与Hibernate有哪些不同？</h2><p>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。</p>
<h3 id="1-两者最大的区别："><a href="#1-两者最大的区别：" class="headerlink" title="1). 两者最大的区别："></a>1). 两者最大的区别：</h3><ul>
<li>针对简单逻辑，Hibernate和MyBatis都有相应的代码生成工具，可以生成简单基本的DAO层方法。</li>
<li>针对高级查询，<strong>Hibernate是一个完全的ORM框架，而Mybatis是半自动ORM映射工具</strong>。 <font color="red">Mybatis需要手动编写SQL语句，以及ResultMap。而Hibernate有良好的映射机制，开发者无需关心SQL的生成与结果映射，可以更专注于业务流程</font>。</li>
</ul>
<h3 id="2-开发难度对比"><a href="#2-开发难度对比" class="headerlink" title="2). 开发难度对比"></a>2). 开发难度对比</h3><ul>
<li>Hibernate的开发难度要大于Mybatis。主要由于Hibernate比较复杂、庞大，学习周期较长。</li>
<li>而Mybatis则相对简单一些，并且Mybatis主要依赖于sql的书写，让开发者感觉更熟悉。</li>
</ul>
<h3 id="3-数据库扩展性比较"><a href="#3-数据库扩展性比较" class="headerlink" title="3).数据库扩展性比较"></a>3).数据库扩展性比较</h3><ul>
<li>Mybatis由于所有SQL都是依赖数据库书写的，<font color="red">不同的数据库需要写不同SQ，所以扩展性，迁移性比较差</font>。</li>
<li>Hibernate与数据库具体的关联都在XML中，所以<font color="red">它对具体是用什么数据库并不是很关心</font>。</li>
</ul>
<h3 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h3><ul>
<li><p>Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，<font color="red">非常适合对关系数据模型要求不高的软件开发</font>，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。 </p>
</li>
<li><p>Hibernate对象/关系映射能力强，数据库无关性好，<font color="red">适用于对于关系模型要求高的软件</font>，如果用hibernate开发可以节省很多代码，提高效率。 </p>
</li>
</ul>
<h2 id="4-为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#4-为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="4. 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>4. 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h2><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p>
<h2 id="5-和-的区别是什么？"><a href="#5-和-的区别是什么？" class="headerlink" title="5. #{}和${}的区别是什么？"></a>5. #{}和${}的区别是什么？</h2><p><strong>#{}是预编译处理，${}是字符串替换</strong>。</p>
<ul>
<li><p>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</p>
</li>
<li><p>Mybatis在处理${}时，就是把${}替换成变量的值。</p>
</li>
</ul>
<p>使用#{}可以有效的防止SQL注入，提高系统安全性。</p>
<h2 id="6-当实体类中的属性名和表中的字段名不一样-，怎么办-？"><a href="#6-当实体类中的属性名和表中的字段名不一样-，怎么办-？" class="headerlink" title="6. 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？"></a>6. 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</h2><h3 id="第1种：-通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。"><a href="#第1种：-通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。" class="headerlink" title="第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。"></a>第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</h3><pre><code>&lt;select id=”selectorder” parametertype=”int” resultetype=”me.gacl.domain.order”&gt;
   select order_id id, order_no orderno ,order_price price form orders where order_id=#{id};
&lt;/select&gt;
</code></pre><p>###第2种： 通过&lt;resultMap>来映射字段名和实体类属性名的一一对应的关系。</p>
<pre><code>&lt;select id=&quot;getOrder&quot; parameterType=&quot;int&quot; resultMap=&quot;orderresultmap&quot;&gt;
    select * from orders where order_id=#{id}
&lt;/select&gt;

&lt;resultMap type=”me.gacl.domain.order” id=”orderresultmap”&gt;
    &lt;!–用id属性来映射主键字段–&gt;
    &lt;id property=”id” column=”order_id”&gt;

    &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt;
    &lt;result property = “orderno” column =”order_no”/&gt;
    &lt;result property=”price” column=”order_price” /&gt;
&lt;/reslutMap&gt;
</code></pre><h2 id="7-模糊查询like语句该怎么写"><a href="#7-模糊查询like语句该怎么写" class="headerlink" title="7. 模糊查询like语句该怎么写?"></a>7. 模糊查询like语句该怎么写?</h2><h3 id="第1种：在Java代码中添加sql通配符。"><a href="#第1种：在Java代码中添加sql通配符。" class="headerlink" title="第1种：在Java代码中添加sql通配符。"></a>第1种：在Java代码中添加sql通配符。</h3><pre><code>string wildcardname = “%smi%”;
list&lt;name&gt; names = mapper.selectlike(wildcardname);

&lt;select id=”selectlike”&gt;
 select * from foo where bar like #{value}
&lt;/select&gt;
</code></pre><h3 id="第2种：在sql语句中拼接通配符，会引起sql注入"><a href="#第2种：在sql语句中拼接通配符，会引起sql注入" class="headerlink" title="第2种：在sql语句中拼接通配符，会引起sql注入"></a>第2种：在sql语句中拼接通配符，会引起sql注入</h3><pre><code>string wildcardname = “smi”;
list&lt;name&gt; names = mapper.selectlike(wildcardname);

&lt;select id=”selectlike”&gt;
     select * from foo where bar like &quot;%&quot;${value}&quot;%&quot;
&lt;/select&gt;
</code></pre><p>Mybatis的核心组件有:SqlSessionFactory、SqlSession、Mapper、TypeHandler。</p>
<h2 id="8-MyBatis常用对象SqlSessionFactory和SqlSession介绍和运用"><a href="#8-MyBatis常用对象SqlSessionFactory和SqlSession介绍和运用" class="headerlink" title="8. MyBatis常用对象SqlSessionFactory和SqlSession介绍和运用"></a>8. MyBatis常用对象SqlSessionFactory和SqlSession介绍和运用</h2><p>SqlSessionFactory是通过SqlSessionFactoryBuilder的build方法创建的</p>
<p>而build方法创建的是一个SqlSessionFactory的实现类,叫DefaultSqlSessionFactory</p>
<p>然后这个实现类主要用的设计模式是建造者(build)模式,而里面最终要达到的一个目的是为了创建出DefaultSqlSession,这个是SqlSession的实现类。</p>
<p>前面说了SqlSession也是同一个接口,那么SqlSession=SqlSessionFactory.openSession()就相当于SqlSession=DefaultSqlSession这个实现类。</p>
<p>这个实现类可以进行增删查改以及事务操作等， DefaultSqlSession是通过调用Executor执行器进行这些操作的。</p>
<p>Executor执行器其实也是一个接口,而在解析配置文件的时候已经解析出来SQL,那么根据一路传过来的SQL以及参数等信息, Executor再调度StatementHandler等对象对数据库进行增删查改操作。</p>
<h3 id="从-XML-中构建-SqlSessionFactory"><a href="#从-XML-中构建-SqlSessionFactory" class="headerlink" title="从 XML 中构建 SqlSessionFactory"></a>从 XML 中构建 SqlSessionFactory</h3><pre><code>//1. 读取配置文件
in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
//2. 获取SqlFactorySession
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
</code></pre><p>XML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;!-- mybatis的主配置文件 --&gt;
&lt;configuration&gt;
    &lt;!-- 配置环境 --&gt;
    &lt;environments default=&quot;mysql&quot;&gt;
        &lt;!-- 配置mysql的环境--&gt;
        &lt;environment id=&quot;mysql&quot;&gt;
            &lt;!-- 配置事务的类型--&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
            &lt;!-- 配置数据源（连接池） --&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;!-- 配置连接数据库的4个基本信息 --&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db_mybatis?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;123&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;bjtu/dao/UserDao.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre><p>XML 头部的声明，它用来验证 XML 文档的正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则包含了一组映射器（mapper），这些映射器的 XML 映射文件包含了 SQL 代码和映射定义信息。</p>
<h3 id="从-SqlSessionFactory-中获取-SqlSession"><a href="#从-SqlSessionFactory-中获取-SqlSession" class="headerlink" title="从 SqlSessionFactory 中获取 SqlSession"></a>从 SqlSessionFactory 中获取 SqlSession</h3><p>从SqlSessionFactory获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。</p>
<pre><code>//1. 读取配置文件
in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
//2. 获取SqlFactorySession
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
//3. 获取SqlSession对象
sqlSession = factory.openSession();
//4. 获取dao的代理对象
userDao = sqlSession.getMapper(UserDao.class);
</code></pre><h2 id="9-映射配置文件"><a href="#9-映射配置文件" class="headerlink" title="9. 映射配置文件"></a>9. 映射配置文件</h2><p>在mapper映射文件中，主要包含如下配置元素：</p>
<ul>
<li><strong>mapper元素</strong>: 该元素是最顶层的配置元素，其属性namespace指向IDao类的全限定类名，即：包路径+类名。 在mapper元素下面，包含如下子元素：resultMap元素，select元素，insert元素，update元素，delete元素。</li>
<li><strong>resultMap元素</strong>： 建立数据库表的字段名与pojo类的数据字段之间的映射关系。 当pojo类的数据字段与数据库表不一致的时候，或者承载复杂查询结果的时候，使用resultMap配置； ResultMap是Mybatis中最重要最强大的元素,使用ResultMap可以解决两大问题：  <ul>
<li><strong>POJO属性名和表结构字段名不一致的问题</strong>（有些情况下也不是标准的驼峰格式）</li>
<li><strong>完成高级查询</strong>，比如说，一对一、一对多、多对多。</li>
</ul>
</li>
<li><strong>select元素</strong>： 用来映射select语句。</li>
<li><strong>insert元素</strong>：用来映射insert语句。</li>
<li><strong>update元素</strong>： 用来映射update语句。</li>
<li><p><strong>delete元素</strong>： 用来映射delete语句。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;bjtu.dao.UserDao&quot;&gt;
    &lt;!--配置查询结果的列名与实体类的属性名的对应关系--&gt;
    &lt;resultMap id=&quot;userMap&quot; type=&quot;bjtu.domain.user&quot;&gt;
        &lt;!-- 主键字段的对应--&gt;
        &lt;id property=&quot;userId&quot; column=&quot;id&quot;&gt;&lt;/id&gt;
        &lt;!-- 非主键字段的对应--&gt;
        &lt;result property=&quot;userName&quot; column=&quot;username&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;userBirthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;userSex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;userAddress&quot; column=&quot;address&quot;&gt;&lt;/result&gt;
    &lt;/resultMap&gt;

    &lt;!--配置查询所有--&gt;
    &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;
        select * from user
    &lt;/select&gt;
    &lt;!--插入保存用户--&gt;
    &lt;insert id=&quot;saveUser&quot; parameterType=&quot;bjtu.domain.user&quot;&gt;
        &lt;!--配置插入数据后，获取新增数据的id--&gt;
        &lt;selectKey keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt;
            select last_insert_id()
        &lt;/selectKey&gt;
        insert into user(username,address,sex,birthday) values(#{username},#{address},#{sex},#{birthday})
    &lt;/insert&gt;
    &lt;!--更新用户信息--&gt;
    &lt;update id=&quot;updateUser&quot; parameterType=&quot;bjtu.domain.user&quot;&gt;
        update user set username=#{username},address=#{address},sex=#{sex},birthday=#{birthday} where id=#{id}
    &lt;/update&gt;
    &lt;!--删除用户--&gt;
    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;
        delete from user where id=#{uid}
    &lt;/delete&gt;
    &lt;!--按ID查询一个用户的信息--&gt;
    &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultMap=&quot;userMap&quot;&gt;
        select * from user where id=#{uid}
    &lt;/select&gt;
    &lt;!--按名称模糊查询用户信息--&gt;
    &lt;select id=&quot;findByName&quot; parameterType=&quot;string&quot; resultMap=&quot;userMap&quot;&gt;
        select * from user where username like #{name}
    &lt;/select&gt;
    &lt;!--利用聚合函数查询总记录条数--&gt;
    &lt;select id=&quot;findTotal&quot; resultType=&quot;int&quot;&gt;
        select count(id) from user
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre></li>
</ul>
<p><strong>resultMap内的元素：</strong></p>
<ul>
<li>constructor - 用于在实例化类时，注入结果到构造方法中<ul>
<li>idArg - ID 参数;标记出作为 ID 的结果可以帮助提高整体性能</li>
<li>arg - 将被注入到构造方法的一个普通结果</li>
</ul>
</li>
<li>id – 一个 ID 结果;标记出作为 ID 的结果可以帮助提高整体性能</li>
<li>result – 注入到字段或 JavaBean 属性的普通结果</li>
<li>association – 一个复杂类型的关联;许多结果将包装成这种类型<br>嵌套结果映射 – 关联可以指定为一个 resultMap 元素，或者引用一个</li>
<li>collection – 一个复杂类型的集合嵌套结果映射 – 集合可以指定为一个 resultMap 元素，或者引用一个</li>
<li>discriminator – 使用结果值来决定使用哪个 resultMap.</li>
</ul>
<h2 id="10-Mybatis的缓存"><a href="#10-Mybatis的缓存" class="headerlink" title="10. Mybatis的缓存"></a>10. Mybatis的缓存</h2><h3 id="Mybatis中的延迟加载"><a href="#Mybatis中的延迟加载" class="headerlink" title="Mybatis中的延迟加载"></a>Mybatis中的延迟加载</h3><pre><code>问题：在一对多中，当我们有一个用户，它有100个账户。
      在查询用户的时候，要不要把关联的账户查出来？
      在查询账户的时候，要不要把关联的用户查出来？

      在查询用户时，用户下的账户信息应该是，什么时候使用，什么时候查询的。
      在查询账户时，账户的所属用户信息应该是随着账户查询时一起查询出来。
</code></pre><ul>
<li><p><strong>什么是延迟加载?</strong></p>
<blockquote>
<p><strong>在真正使用数据时才发起查询，不用的时候不查询。按需加载（懒加载）</strong></p>
</blockquote>
</li>
<li><p><strong>什么是立即加载?</strong></p>
<blockquote>
<p><strong>不管用不用，只要一调用方法，马上发起查询</strong>。</p>
</blockquote>
<p>  在对应的四种表关系中：一对多，多对一，一对一，多对多。 一对多，多对多：通常情况下我们都是采用延迟加载； 多对一，一对一：通常情况下我们都是采用立即加载。</p>
</li>
</ul>
<h3 id="Mybatis中的缓存"><a href="#Mybatis中的缓存" class="headerlink" title="Mybatis中的缓存"></a>Mybatis中的缓存</h3><ul>
<li><p><strong>什么是缓存</strong></p>
<blockquote>
<p>存在于内存中的临时数据。</p>
</blockquote>
</li>
<li><p><strong>为什么使用缓存</strong></p>
<blockquote>
<p>减少和数据库的交互次数，提高执行效率。</p>
</blockquote>
</li>
<li><p><strong>什么样的数据能使用缓存，什么样的数据不能使用</strong></p>
<pre><code>* 适用于缓存：  
    - 经常查询并且不经常改变的。
    - 数据的正确与否对最终结果影响不大的。
* 不适用于缓存：
    - 经常改变的数据
    - 数据的正确与否对最终结果影响很大的。
    - 例如：商品的库存，银行的汇率，股市的牌价。
</code></pre></li>
<li><p><strong>Mybatis中的一级缓存和二级缓存</strong></p>
<ul>
<li><p><strong>一级缓存</strong>：</p>
<ul>
<li>它指的是<strong>Mybatis中SqlSession对象的缓存</strong>。</li>
</ul>
<ul>
<li>当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供一块区域中。该区域的结构是一个Map。当我们再次查询同样的数据，mybatis会先去sqlsession中查询是否有，有的话直接拿出来用。</li>
<li>当SqlSession对象消失时，mybatis的一级缓存也就消失了。</li>
<li>如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。</li>
</ul>
</li>
<li><p><strong>二级缓存</strong>:</p>
<ul>
<li>它指的是<strong>Mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享其缓存</strong>。</li>
<li>二级缓存的使用步骤：<ul>
<li>第一步：让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置）</li>
<li>第二步：让当前的映射文件支持二级缓存（在IUserDao.xml中配置）</li>
<li>第三步：让当前的操作支持二级缓存（在select标签中配置）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2020/07/28/g4Je6wdhv18iVZk.jpg" alt="cash1.JPG"><br><img src="https://i.loli.net/2020/07/28/godWnHZLwNOpXJ6.jpg" alt="cash2.JPG"><br><img src="https://i.loli.net/2020/07/28/AL1J9dtmPyv7O8Y.jpg" alt="cash3.JPG"></p>
<h2 id="11-Mybatis中的注解开发"><a href="#11-Mybatis中的注解开发" class="headerlink" title="11. Mybatis中的注解开发"></a>11. Mybatis中的注解开发</h2><p>这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper(即UserDap.xml、AccountDao.xml等配置文件)映射文件了。在Mybatis中只能使用映射配置文件和注解配置一种方式，所以使用注解配置时，应将映射配置文件移除。</p>
<h3 id="1-单表的CUDA操作"><a href="#1-单表的CUDA操作" class="headerlink" title="1) . 单表的CUDA操作"></a>1) . 单表的CUDA操作</h3><p>首先针对单表的CUDA操作，只需要在UserDao接口文件的相关方法上添加配置即可。Mybatis中有四种SQL相关的语句配置：</p>
<ul>
<li><strong>@Insert: 实现新增</strong> </li>
<li><strong>@Update: 实现更新</strong> </li>
<li><strong>@Delete: 实现删除</strong> </li>
<li><strong>@Select: 实现查询</strong></li>
</ul>
<p>以User类的接口UserDao为例，程序改写如下：</p>
<pre><code>public interface UserDao {
    /*
    查询所有用户，同时获取用户下所有的账户信息
   */
    @Select(&quot;select * from user&quot;)
    @Results(id = &quot;userMap&quot;, value={
            @Result(id = true, column = &quot;id&quot;, property = &quot;id&quot;),
            @Result(column = &quot;username&quot;, property = &quot;username&quot;),
            @Result(column = &quot;address&quot;, property = &quot;address&quot;),
            @Result(column = &quot;sex&quot;, property = &quot;sex&quot;),
            @Result(column = &quot;birthday&quot;, property = &quot;birthday&quot;),
    })
    List&lt;User&gt; findAll();

    /**
     * 按ID查询用户信息
     * @param userID
     */
    @Select(&quot;select * from user where id = #{uid}&quot;)
    @ResultMap(value = {&quot;userMap&quot;})
    User findById(Integer userID);

    /**
     * 插入保存user
     * @param u
     */
    @Insert(&quot;insert into user(username,address,sex,birthday) values(#{username},#{address},#{sex},#{birthday})&quot;)
    @ResultMap(value = {&quot;userMap&quot;})
    void saveUser(User u);

    /**
     * 更新信息
     * @param u
     */
    @Update(&quot;update user set username=#{username},address=#{address},sex=#{sex},birthday=#{birthday} where id=#{id}&quot;)
    @ResultMap(value = {&quot;userMap&quot;})
    void updateUser(User u);

    /**
     * 删除用户
     * @param userID
     */
    @Delete(&quot;delete from user where id = #{id}&quot;)
    @ResultMap(value = {&quot;userMap&quot;})
    void deleteUser(Integer userID);

    /**
     * 按名称模糊查询用户信息
     */
    @Select(&quot;select * from user where username like #{username}&quot; )
    @ResultMap(value = {&quot;userMap&quot;})
    //@Select(&quot;select * from user where username like &apos;%${value}%&apos;&quot; )
    List&lt;User&gt; findByName(String username);

    /**
     * 聚合函数：查询总记录条数
     */
    @Select(&quot;select count(id) from user&quot;)
    @ResultMap(value = {&quot;userMap&quot;})
    int findTotal();
}
</code></pre><ul>
<li>只需要在方法之上添加 @Select(“SQL语句”)，@Insert(“SQL语句”)，@Update(“SQL语句”)，@Delect(“SQL语句”)。</li>
<li>另外，若User类中的属性与数据库中user表的列名不一致，需要增加 @Results() 注解配置，类似于UserDao.xml中的<resultmap></resultmap>配置。<br><img src="https://i.loli.net/2020/07/28/HMqn1gma4lJzO5Y.jpg" alt="userMap.jpg"></li>
</ul>
<h3 id="2）-多表操作配置"><a href="#2）-多表操作配置" class="headerlink" title="2）. 多表操作配置"></a>2）. 多表操作配置</h3><ul>
<li><p><strong>一对一配置</strong><br><img src="https://i.loli.net/2020/07/28/wRE861QmJZsN3hB.jpg" alt="onetoone.jpg"></p>
</li>
<li><p><strong>一对多配置</strong><br><img src="https://i.loli.net/2020/07/28/NeEs1SigWPDGu87.jpg" alt="many.jpg"></p>
</li>
</ul>
<h2 id="12-通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"><a href="#12-通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="12. 通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"></a>12. 通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h2><p>Dao接口即Mapper接口。接口的全限定类名，就是映射文件中的namespace的值；接口的方法名，就是映射文件中Mapper的Statement的id值；接口方法内的参数，就是传递给sql的参数。</p>
<p>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MapperStatement。在Mybatis中，每一&lt;select>、&lt;insert>、&lt;update>、&lt;delete>标签，都会被解析为一个MapperStatement对象。</p>
<p>举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面 id 为 findStudentById 的 MapperStatement。</p>
<p>Mapper接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻找策略。Mapper 接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象proxy，代理对象会拦截接口方法，转而执行MapperStatement所代表的sql，然后将sql执行结果返回。</p>
<h2 id="13-Mybatis动态sql有什么用？执行原理？有哪些动态sql？"><a href="#13-Mybatis动态sql有什么用？执行原理？有哪些动态sql？" class="headerlink" title="13. Mybatis动态sql有什么用？执行原理？有哪些动态sql？"></a>13. Mybatis动态sql有什么用？执行原理？有哪些动态sql？</h2><p>Mybatis动态sql可以在Xml映射文件内，以标签的形式编写动态sql，执行原理是根据表达式的值完成逻辑判断并动态拼接sql的功能。</p>
<p>Mybatis提供了9种动态sql标签：trim | where | set | foreach | if | choose | when | otherwise | bind。</p>
<h2 id="14-MyBatis实现一对一有几种方式-具体怎么操作的？"><a href="#14-MyBatis实现一对一有几种方式-具体怎么操作的？" class="headerlink" title="14. MyBatis实现一对一有几种方式? 具体怎么操作的？"></a>14. MyBatis实现一对一有几种方式? 具体怎么操作的？</h2><p>有<strong>联合查询</strong>和<strong>嵌套查询</strong>：</p>
<ul>
<li><strong>联合查询</strong>: 是几个表联合查询,只查询一次, 通过在resultMap里面配置association节点配置一对一的类就可以完成；</li>
<li><strong>嵌套查询</strong>: 是先查一个表，根据这个表里面的结果的 外键id，去再另外一个表里面查询数据,也是通过association配置，但另外一个表的查询通过select属性配置。</li>
</ul>
<h2 id="15、MyBatis实现一对多有几种方式-怎么操作的？"><a href="#15、MyBatis实现一对多有几种方式-怎么操作的？" class="headerlink" title="15、MyBatis实现一对多有几种方式,怎么操作的？"></a>15、MyBatis实现一对多有几种方式,怎么操作的？</h2><p>有<strong>联合查询</strong>和<strong>嵌套查询</strong>:</p>
<ul>
<li><strong>联合查询:</strong> 是几个表联合查询,只查询一次,通过在resultMap里面的collection节点配置一对多的类就可以完成；</li>
<li><strong>嵌套查询:</strong> 是先查一个表,根据这个表里面的 结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置。</li>
</ul>
<h1 id="二、-Spring"><a href="#二、-Spring" class="headerlink" title="二、 Spring"></a>二、 Spring</h1><h2 id="1-Spring框架是什么？"><a href="#1-Spring框架是什么？" class="headerlink" title="1. Spring框架是什么？"></a>1. Spring框架是什么？</h2><p>Spring是分层的Java SE/EE应用 <strong>full-stack</strong>轻量级开源框架，以<strong>IoC（Inverse Of Control：反转控制）</strong>和<strong>AOP（Aspect Oriented Programming：面向切面编程）</strong>为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。</p>
<h2 id="2-Spring的优势"><a href="#2-Spring的优势" class="headerlink" title="2. Spring的优势"></a>2. Spring的优势</h2><pre><code>1. **方便解耦，简化开发:** 通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。
2. **AOP编程的支持:** 通过Spring的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。
3. **声明式事务的支持:** 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用， 提高开发效率和质量。
4. **方便程序的测试:** 可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情
5. **方便集成各种优秀框架:** Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的直接支持。
6. **降低JavaEE API的使用难度:** Spring对JavaEE API（如JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。
</code></pre><h2 id="3-Spring模块组成"><a href="#3-Spring模块组成" class="headerlink" title="3. Spring模块组成"></a>3. Spring模块组成</h2><ul>
<li>Spring Core：核心类库，提供IOC服务；</li>
<li>Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；</li>
<li>Spring AOP：AOP服务；</li>
<li>Spring DAO：对JDBC的抽象，简化了数据访问异常的处理；</li>
<li>Spring ORM：对现有的ORM框架的支持；</li>
<li>Spring Web：提供了基本的面向Web的综合特性，例如多方文件上传；</li>
<li>Spring MVC：提供面向Web应用的Model-View-Controller实现。</li>
</ul>
<p>Spring体系结构</p>
<p><img src="https://i.loli.net/2020/07/28/PaVvNlMQxUJZWDY.jpg" alt="spring.JPG"></p>
<h2 id="4、-Spring的IOC"><a href="#4、-Spring的IOC" class="headerlink" title="4、 Spring的IOC"></a>4、 Spring的IOC</h2><ul>
<li><p>IOC就是控制反转，是指<strong>创建对象的控制权的转移</strong>，以前创建对象的主动权和时机是由自己把控的，而现在这种<strong>权力转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合</strong>，也利于功能的复用。DI依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖IoC容器来动态注入对象需要的外部资源。</p>
</li>
<li><p>最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</p>
</li>
</ul>
<h2 id="5-BeanFactory和ApplicationContext有什么区别"><a href="#5-BeanFactory和ApplicationContext有什么区别" class="headerlink" title="5. BeanFactory和ApplicationContext有什么区别"></a>5. BeanFactory和ApplicationContext有什么区别</h2><p>Spring使用工厂模式可以通过 <strong>BeanFactory</strong> 或 <strong>ApplicationContext</strong> 创建 bean 对象。 BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p>
<ul>
<li><p>1）BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。<font color="red">ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能</font>, 所以一般开发人员使用ApplicationContext会更多.</p>
<ul>
<li>①继承MessageSource，因此支持国际化。</li>
<li>②统一的资源文件访问方式。</li>
<li>③提供在监听器中注册bean的事件。</li>
<li>④同时加载多个配置文件。</li>
<li>⑤载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li>
</ul>
</li>
<li><p>2）<strong>Bean’对象实例加载机制</strong></p>
<ul>
<li><p>①<font color="red">*BeanFactroy采用的是延迟加载形式来注入Bean的</font>，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p>
</li>
<li><p>②<font color="red">ApplicationContext是立即加载，它是在容器启动时，一次性创建了所有的Bean</font>。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>
</li>
<li><p>③相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
</li>
</ul>
</li>
</ul>
<p>ApplicationContext的三个实现类：</p>
<ul>
<li><strong>ClassPathXmlApplication：</strong>把上下文文件当成类路径资源。</li>
<li><strong>FileSystemXmlApplication：</strong>从文件系统中的 XML 文件载入上下文定义信息。</li>
<li><strong>XmlWebApplicationContext：</strong>从Web系统中的XML文件载入上下文定义信息。</li>
</ul>
<h2 id="6-Spring中的依赖注入"><a href="#6-Spring中的依赖注入" class="headerlink" title="6. Spring中的依赖注入"></a>6. Spring中的依赖注入</h2><pre><code>* 依赖注入：
    Dependency Injection
* IOC的作用：
    降低程序间的耦合（依赖关系）
* 依赖关系的管理：
    以后都交给spring来维护
    在当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中说明
* 依赖关系的维护：
    就称之为依赖注入。

*依赖注入：
   1. 能注入的数据：有三类
        1) 基本类型和String
        2) 其他bean类型（在配置文件中或者注解配置过的bean）
        3) 复杂类型/集合类型
   2. 注入的方式：有三种
        1) 第一种：使用构造函数提供
        2) 第二种：使用set方法提供
        3) 第三种：使用注解提供
</code></pre><h3 id="1-构造函数注入"><a href="#1-构造函数注入" class="headerlink" title="1) 构造函数注入"></a>1) 构造函数注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="keyword">private</span> Integer age; </span><br><span class="line">    <span class="keyword">private</span> Date birthday; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountServiceImpl</span><span class="params">(String name, Integer age, Date birthday)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name; </span><br><span class="line">        <span class="keyword">this</span>.age = age; </span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday; &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        ystem.out.println(name+<span class="string">","</span>+age+<span class="string">","</span>+birthday); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用的标签:constructor-arg   </li>
<li><p>标签出现的位置：bean标签的内部</p>
<pre><code>标签中的属性
    type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型
    index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始
    name：用于指定给构造函数中指定名称的参数赋值                                        常用的
    =============以上三个用于指定给构造函数中哪个参数赋值===============================
    value：用于提供基本类型和String类型的数据
    ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象

优势：
    在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。
弊端：
    改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。

--&gt;
&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;泰斯特&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;!-- 配置一个日期对象 --&gt;
&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;
</code></pre></li>
</ul>
<h3 id="2-set方法注入"><a href="#2-set方法注入" class="headerlink" title="2) set方法注入"></a>2) set方法注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountServiceImpl</span><span class="params">(String name, Integer age, Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ystem.out.println(name+<span class="string">","</span>+age+<span class="string">","</span>+birthday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<ul>
<li>涉及的标签：property</li>
<li><p>出现的位置：bean标签的内部</p>
<pre><code>标签的属性
    name：用于指定注入时所调用的set方法名称
    value：用于提供基本类型和String类型的数据
    ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象
优势：
    创建对象时没有明确的限制，可以直接使用默认构造函数
弊端：
    如果有某个成员必须有值，则获取对象是有可能set方法没有执行。
--&gt;
&lt;bean id=&quot;accountService2&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl2&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;TEST&quot; &gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre></li>
</ul>
<h3 id="3）注入集合"><a href="#3）注入集合" class="headerlink" title="3）注入集合"></a>3）注入集合</h3><p>顾名思义，就是给类中的集合成员传值，它用的也是set方法注入的方式，只不过变量的数据类型都是集合。我们这里介绍注入数组，List,Set,Map,Properties。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] myStrs;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; myList;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; mySet;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; myMap;</span><br><span class="line">    <span class="keyword">private</span> Properties myProps;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyStrs</span><span class="params">(String[] myStrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myStrs = myStrs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyList</span><span class="params">(List&lt;String&gt; myList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myList = myList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMySet</span><span class="params">(Set&lt;String&gt; mySet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mySet = mySet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyMap</span><span class="params">(Map&lt;String, String&gt; myMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myMap = myMap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyProps</span><span class="params">(Properties myProps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myProps = myProps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(myStrs));</span><br><span class="line">        System.out.println(myList);</span><br><span class="line">        System.out.println(mySet);</span><br><span class="line">        System.out.println(myMap);</span><br><span class="line">        System.out.println(myProps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>复杂类型的注入/集合类型的注入          
    *用于给List结构集合注入的标签：
        list array set
    * 用于个Map结构集合注入的标签:
        map  props
    结构相同，标签可以互换
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">&lt;bean id=<span class="string">"accountService3"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl3"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"myStrs"</span>&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;value&gt;AAA&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;BBB&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;CCC&lt;/value&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property name=<span class="string">"myList"</span>&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;value&gt;AAA&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;BBB&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;CCC&lt;/value&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property name=<span class="string">"mySet"</span>&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;AAA&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;BBB&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;CCC&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property name=<span class="string">"myMap"</span>&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key="testC"&gt;ccc&lt;/prop&gt;</span><br><span class="line">            &lt;prop key="testD"&gt;ddd&lt;/prop&gt;</span><br><span class="line">        &lt;/props&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property name=<span class="string">"myProps"</span>&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key="testA" value="aaa"&gt;&lt;/entry&gt;</span><br><span class="line">            &lt;entry key=<span class="string">"testB"</span>&gt;</span><br><span class="line">                &lt;value&gt;BBB&lt;/value&gt;</span><br><span class="line">            &lt;/entry&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;   </span><br></pre></td></tr></table></figure>
<h2 id="7-Bean生命周期"><a href="#7-Bean生命周期" class="headerlink" title="7. Bean生命周期"></a>7. Bean生命周期</h2><p><strong>单例对象： singleton</strong></p>
<ul>
<li>出生：当容器创建时对象出生</li>
<li>活着：只要容器还在，对象一直或者</li>
<li>死亡：容器销毁，对象消亡  </li>
</ul>
<p>总结：单例对象的生命周期和容器相同</p>
<p><strong>多例对象： prototype</strong></p>
<ul>
<li>出生: 使用对象时spring框架为我们创建</li>
<li>活着：对象只要是在使用过程中就一直活着</li>
<li>死亡：当对象长时间不用且没有其它对象引用时，由java的垃圾回收机制回收</li>
</ul>
<h2 id="8-Bean作用域？默认什么级别？是否线程安全？Spring如何保障线程安全的"><a href="#8-Bean作用域？默认什么级别？是否线程安全？Spring如何保障线程安全的" class="headerlink" title="8. Bean作用域？默认什么级别？是否线程安全？Spring如何保障线程安全的?"></a>8. Bean作用域？默认什么级别？是否线程安全？Spring如何保障线程安全的?</h2><h3 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h3><p>取值： 常用的就是单例的和多例的  </p>
<ul>
<li><strong>singleton：</strong> 单例的（默认值）-一个应用只有一个对象的实例。它的作用范围就是整个引用。</li>
<li><strong>prototype：</strong> 多例的-每次访问对象时，都会重新创建对象实例。</li>
<li><strong>request：</strong> 作用于web应用的请求范围，每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。</li>
<li><strong>session：</strong> 作用于web应用的会话范围，在一次 HTTP session 中，容器将返回同一个实例。</li>
<li><strong>global-session：</strong> 作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session</li>
</ul>
<p>bean标签的scope属性：<br><strong>作用：</strong>用于指定bean的作用范围</p>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;--&gt;
</code></pre><h2 id="9、-Spring的AOP"><a href="#9、-Spring的AOP" class="headerlink" title="9、 Spring的AOP"></a>9、 Spring的AOP</h2><p>OOP面向对象，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>AOP，一般称为面向切面，作为面向对象的一种补充，<font color="red">用于<strong>将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect）</strong>，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性</font>。可用于权限认证、日志、事务处理。</p>
<p><strong>可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术</strong></p>
<ul>
<li><p><strong>AOP的作用：</strong><br>  在程序运行期间，使用动态代理的技术不修改源码对已有方法进行增强。 </p>
</li>
<li><p><strong>AOP的优势</strong>： </p>
<ul>
<li>减少重复代码 </li>
<li>提高开发效率 </li>
<li>维护方便</li>
</ul>
</li>
</ul>
<h2 id="10、动态代理"><a href="#10、动态代理" class="headerlink" title="10、动态代理"></a>10、动态代理</h2><p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p>
<p>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为<strong>编译时增</strong>强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p>
<p>（2）Spring AOP使用的动态代理，所谓的<strong>动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法</strong>。</p>
<p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p>
<ul>
<li><p>①<strong>JDK动态代理只提供接口的代理，不支持类的代</strong>理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例,  生成目标类的代理对象。</p>
</li>
<li><p>②如果代理类没有实现 InvocationHandler 接口，那么<strong>Spring AOP会选择使用CGLIB来动态代理目标类</strong>。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p>
</li>
</ul>
<p>（3）静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p>
<h2 id="11、-AOP相关术语"><a href="#11、-AOP相关术语" class="headerlink" title="11、 AOP相关术语"></a>11、 AOP相关术语</h2><ul>
<li><strong>Joinpoint(连接点):</strong>  <ul>
<li>所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点。</li>
</ul>
</li>
<li><strong>Pointcut(切入点):</strong> <ul>
<li>所谓切入点是指我们要对哪些Joinpoint进行拦截的定义。</li>
</ul>
</li>
<li><strong>Advice(通知/增强):</strong> <ul>
<li>所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。 </li>
<li>通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。</li>
</ul>
</li>
<li><strong>Target(目标对象):</strong> <ul>
<li>代理的目标对象。</li>
</ul>
</li>
<li><strong>Weaving(织入):</strong> <ul>
<li>是指把增强应用到目标对象来创建新的代理对象的过程。 spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。</li>
</ul>
</li>
<li><strong>Proxy（代理）:</strong> <ul>
<li>一个类被AOP织入增强后，就产生一个结果代理类。</li>
</ul>
</li>
<li><strong>Aspect(切面):</strong> <ul>
<li>是切入点和通知（引介）的结合</li>
</ul>
</li>
</ul>
<p>Spring框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p>
<h2 id="12、-Spring中的通知类型"><a href="#12、-Spring中的通知类型" class="headerlink" title="12、 Spring中的通知类型"></a>12、 Spring中的通知类型</h2><h3 id="1）在aop-aspect标签的内部使用对应标签来配置通知的类型"><a href="#1）在aop-aspect标签的内部使用对应标签来配置通知的类型" class="headerlink" title="1）在aop:aspect标签的内部使用对应标签来配置通知的类型"></a>1）在aop:aspect标签的内部使用对应标签来配置通知的类型</h3><pre><code>aop:before：表示配置前置通知
    method属性：用于指定Logger类中哪个方法是前置通知
    pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强
    ponitcut-ref： 用于指定切入点的表达式的引用，该引用使用aop:pointcut配置
通知类型：
    * aop:before
        - 作用： 用于配置前置通知。指定增强的方法在切入点方法之前执行
        - 执行时间：切入点方法执行之前执行
    * aop:after-returning
        - 用于配置后置通知
        - 切入点方法正常执行之后。它和异常通知只能有一个执行
    * aop:after-throwing
        - 用于配置异常通知
        - 执行时间：切入点方法执行产生异常后执行。它和后置通知只能执行一个
    * aop:after
        - 用于配置最终通知
        - 执行时间：无论切入点方法执行时是否有异常，它都会在其后面执行。
</code></pre><h5 id="2）使用aop-pointcut配置切入点表达式"><a href="#2）使用aop-pointcut配置切入点表达式" class="headerlink" title="2）使用aop:pointcut配置切入点表达式"></a>2）使用aop:pointcut配置切入点表达式</h5><pre><code>1） 作用： 用于配置切入点表达式。就是指定对哪些类的哪些方法进行增强。

2） 属性：
    id属性： 用于指定表达式的唯一标识
    expression属性： 用于指定表达式内容

此标签写在aop:aspect标签内部只能当前切面使用。 它还可以写在aop:aspect外面，此时就变成了所有切面可用

3）切入点表达式的写法：
    关键字：execution(表达式)
    表达式：
        访问修饰符  返回值  包名.包名.包名...类名.方法名(参数列表)
    * 标准的表达式写法：
        public void com.itheima.service.impl.AccountServiceImpl.saveAccount()
    * 访问修饰符可以省略
        void com.itheima.service.impl.AccountServiceImpl.saveAccount()
    * 返回值可以使用通配符，表示任意返回值
        * com.itheima.service.impl.AccountServiceImpl.saveAccount()
    * 包名可以使用通配符，表示任意包。但是有几级包，就需要写几个*.
        * *.*.*.*.AccountServiceImpl.saveAccount())
    * 包名可以使用..表示当前包及其子包
        * *..AccountServiceImpl.saveAccount()
    * 类名和方法名都可以使用*来实现通配
        * *..*.*()

    * 参数列表：
        可以直接写数据类型：
            基本类型直接写名称           int
            引用类型写包名.类名的方式   java.lang.String
        可以使用通配符表示任意类型，但是必须有参数
        可以使用..表示有无参数均可，有参数可以是任意类型

    * 全通配写法：
        * *..*.*(..)

    * 实际开发中切入点表达式的通常写法：
        切到业务层实现类下的所有方法
            * com.itheima.service.impl.*.*(..)
</code></pre><p><strong>bean.xml配置文件的配置：</strong></p>
<pre><code>&gt; {% codeblock lang:java %}
	> <?xml version="1.0" encoding="UTF-8"?>
	> <beans xmlns="http://www.springframework.org/schema/beans">    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	>    xmlns:aop="http://www.springframework.org/schema/aop"
	>    xsi:schemaLocation="http://www.springframework.org/schema/beans
	>     http://www.springframework.org/schema/beans/spring-beans.xsd
	>     http://www.springframework.org/schema/aop
	>     http://www.springframework.org/schema/aop/spring-aop.xsd">
	> 
	> <!-- 配置srping的Ioc,把service对象配置进来-->
	> <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"></bean>
	> 
	> <!-- 配置Logger类： 通知类-->
	> <bean id="logger" class="com.itheima.utils.Logger"></bean>
	> 
	> <!--配置AOP-->
	> <aop:config>
	>     <!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容
	>           此标签写在aop:aspect标签内部只能当前切面使用。
	>           它还可以写在aop:aspect外面，此时就变成了所有切面可用
	>       -->
	>     <aop:pointcut id="pt1" expression="execution(* com.itheima.service.impl.*.*(..))"></aop:pointcut>
	> 
	>     <!--配置切面 -->
	>     <aop:aspect id="logAdvice" ref="logger">
	>         <!-- 配置前置通知：在切入点方法执行之前执行
	>         <aop:before method="beforePrintLog" pointcut-ref="pt1" ></aop:before>-->
	> 
	>         <!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个
	>         <aop:after-returning method="afterReturningPrintLog" pointcut-ref="pt1"></aop:after-returning>-->
	> 
	>         <!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个
	>         <aop:after-throwing method="afterThrowingPrintLog" pointcut-ref="pt1"></aop:after-throwing>-->
	> 
	>         <!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行
	>         <aop:after method="afterPrintLog" pointcut-ref="pt1"></aop:after>-->
	> 
	>         <!-- 配置环绕通知 详细的注释请看Logger类中-->
	>         <aop:around method="aroundPringLog" pointcut-ref="pt1"></aop:around>
	>     </aop:aspect>
	> </aop:config>
	> 
	> </beans>
	> {% endcodeblock %}
</code></pre><h2 id="13、-Spring-框架中都用到了哪些设计模式？"><a href="#13、-Spring-框架中都用到了哪些设计模式？" class="headerlink" title="13、 Spring 框架中都用到了哪些设计模式？"></a>13、 Spring 框架中都用到了哪些设计模式？</h2><p>（1）<strong>工厂模式：</strong>BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</p>
<p>（2）<strong>单例模式：</strong>Bean默认为单例模式。</p>
<p>（3）<strong>代理模式：</strong>Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</p>
<p>（4）<strong>模板方法：</strong>用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</p>
<p>（5）<strong>观察者模式：</strong>定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</p>
<h1 id="三、SpringMVC"><a href="#三、SpringMVC" class="headerlink" title="三、SpringMVC"></a>三、SpringMVC</h1><h2 id="1-什么是Spring-MVC-？简单介绍下你对springMVC的理解"><a href="#1-什么是Spring-MVC-？简单介绍下你对springMVC的理解" class="headerlink" title="1. 什么是Spring MVC ？简单介绍下你对springMVC的理解?"></a>1. 什么是Spring MVC ？简单介绍下你对springMVC的理解?</h2><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p>
<h2 id="2、Springmvc的优点"><a href="#2、Springmvc的优点" class="headerlink" title="2、Springmvc的优点:"></a>2、Springmvc的优点:</h2><ul>
<li><p>清晰的角色分配，分工明确：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。</p>
</li>
<li><p>可以支持各种视图技术,而不仅仅局限于JSP；</p>
</li>
<li><p>与Spring框架集成（如IoC容器、AOP等）；</p>
</li>
<li><p>支持各种请求资源的映射策略。</p>
</li>
</ul>
<h2 id="3-SpringMVC和Struts2的联系与区别"><a href="#3-SpringMVC和Struts2的联系与区别" class="headerlink" title="3. SpringMVC和Struts2的联系与区别"></a>3. SpringMVC和Struts2的联系与区别</h2><h3 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h3><p>它们都是表现层框架，都是基于MVC模型编写的。 它们的底层都离不开原始ServletAPI。 它们处理请求的机制都是一个核心控制器。</p>
<h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ul>
<li><p>SpringMVC 的入口是一个 servlet 即前端控制器（DispatchServlet），而 struts2 入口是一个 filter 过虑器（StrutsPrepareAndExecuteFilter）</p>
</li>
<li><p>springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例, Struts2每次执行都会创建一个动作类。所以Spring MVC 会稍微比 Struts2 快些。</p>
</li>
<li><p>Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</p>
</li>
</ul>
<h2 id="4-Spring-MVC的主要组件？"><a href="#4-Spring-MVC的主要组件？" class="headerlink" title="4. Spring MVC的主要组件？"></a>4. Spring MVC的主要组件？</h2><ul>
<li><p><strong>（1）前端控制器 DispatcherServlet</strong>（不需要程序员开发）</p>
<p>  作用：接收请求、响应结果，相当于转发器、中央处理器，有了DispatcherServlet 就减少了其它组件之间的耦合度。</p>
</li>
<li><p><strong>（2）处理器映射器HandlerMapping</strong>（不需要程序员开发）</p>
<p>  作用：根据请求的URL来查找Handler处理器</p>
</li>
<li><p><strong>（3）处理器适配器HandlerAdapter</strong></p>
<p>  注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。</p>
</li>
<li><p><strong>（4）处理器Handler</strong>（需要程序员开发）</p>
<p>  它就是我们开发中要编写的具体业务控制器。由DispatcherServlet把用户请求转发到Handler。由Handler对具体的用户请求进行处理。</p>
</li>
<li><p><strong>（5）视图解析器 ViewResolver</strong>（不需要程序员开发）</p>
<p>  作用：进行视图的解析，负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户</p>
</li>
<li><p><strong>（6）视图View</strong>（需要程序员开发jsp）</p>
<p>  View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）</p>
</li>
</ul>
<h2 id="5-SpringMVC的流程？"><a href="#5-SpringMVC的流程？" class="headerlink" title="5. SpringMVC的流程？"></a>5. SpringMVC的流程？</h2><p><img src="https://i.loli.net/2020/09/20/fw89GrXFxNIsVjZ.png" alt="1.png"></p>
<ul>
<li>1） 用户向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)。  </li>
<li>2） DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）</li>
<li>3）HandlerMapping 处理器映射器根据请求url找到具体的处理器Handler，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；  </li>
<li>4）DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller  </li>
<li>5）HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给DispatcherServlet   </li>
<li>6）DispatcherServlet将ModelAndView交给ViewReslover视图解析器解析，然后返回真正的视图。   </li>
<li>7）DispatcherServlet将模型数据填充到视图中  </li>
<li>8）DispatcherServlet将结果响应给用户  </li>
</ul>
<h2 id="6-RequestMapping注解"><a href="#6-RequestMapping注解" class="headerlink" title="6. RequestMapping注解"></a>6. RequestMapping注解</h2><ol>
<li><strong>RequestMapping注解的作用是建立请求URL和处理方法之间的对应关系</strong></li>
<li><strong>RequestMapping注解可以作用在方法和类上</strong><ul>
<li>作用在类上：第一级的访问目录</li>
<li>作用在方法上：第二级的访问目录</li>
<li>细节：路径可以不编写 / 表示应用的根目录开始</li>
<li>细节：${ pageContext.request.contextPath }也可以省略不写，但是路径上不能写 /</li>
</ul>
</li>
<li><strong>RequestMapping的属性</strong><ul>
<li>path 指定请求路径的url</li>
<li>value value属性和path属性是一样的</li>
<li>mthod 指定该方法的请求方式  Get和Post，method=RequestMethod.GET</li>
<li>params 指定限制请求参数的条件</li>
<li>headers 发送的请求中必须包含的请求头</li>
</ul>
</li>
</ol>
<h2 id="7-SpringMVC常用的注解有哪些？"><a href="#7-SpringMVC常用的注解有哪些？" class="headerlink" title="7. SpringMVC常用的注解有哪些？"></a>7. SpringMVC常用的注解有哪些？</h2><p><strong>@RequestMapping</strong>：用于处理请求 url 映射的注解，可用于类或方法上。 用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p><strong>@RequestBody：</strong> 注解实现接收http请求的json数据，将json转换为java对象。</p>
<p><strong>@ResponseBody：</strong> 注解实现将conreoller方法返回对象转化为json对象响应给客户。</p>
<h2 id="8-请求参数的绑定"><a href="#8-请求参数的绑定" class="headerlink" title="8. 请求参数的绑定"></a>8. 请求参数的绑定</h2><p>表单中请求参数都是基于key=value的。 SpringMVC绑定请求参数的过程是通过把表单提交请求参数，作为控制器中方法参数进行绑定的。</p>
<h3 id="支持的数据类型："><a href="#支持的数据类型：" class="headerlink" title="支持的数据类型："></a>支持的数据类型：</h3><ul>
<li><strong>基本类型参数</strong>： 包括基本类型和String类型 </li>
<li><strong>POJO类型参数</strong>： 包括实体类，以及关联的实体类 </li>
<li><strong>数组和集合类型参数</strong>： 包括List结构和Map结构的集合（包括数组）</li>
</ul>
<h2 id="9-如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#9-如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="9. 如何解决POST请求中文乱码问题，GET的又如何处理呢？"></a>9. 如何解决POST请求中文乱码问题，GET的又如何处理呢？</h2><h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><p>在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><h3 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h3><p>GET请求的编码问题，要改tomcat的server.xml配置文件。</p>
<pre><code>&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt; 

改为： &lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; useBodyEncodingForURI=&quot;true&quot;/&gt; 

如果遇到ajax请求仍然乱码，请把：

useBodyEncodingForURI=&quot;true&quot;改为URIEncoding=&quot;UTF-8&quot; 即可。
</code></pre><h2 id="10、-常用的注解"><a href="#10、-常用的注解" class="headerlink" title="10、 常用的注解"></a>10、 常用的注解</h2><h4 id="RequestParam注解"><a href="#RequestParam注解" class="headerlink" title="RequestParam注解"></a>RequestParam注解</h4><ul>
<li>作用：把请求中的指定名称的参数传递给控制器中的形参赋值</li>
<li><p>属性<br>  value：请求参数中的名称<br>  required：请求参数中是否必须提供此参数，默认值是true，必须提供</p>
<pre><code>/**  
* 接收请求  
* @return  
*/  
@RequestMapping(path=&quot;/hello&quot;)  
public String sayHello(@RequestParam(value=&quot;username&quot;,required=false)String name) {       
    System.out.println(&quot;aaaa&quot;);  
    System.out.println(name);
    return &quot;success&quot;;
}
</code></pre></li>
<li><p><strong>RequestBody注解</strong><br>  作用：用于获取请求体的内容（注意：get方法不可以）</p>
</li>
<li><p><strong>ResponseBody</strong><br>  作用：将controller方法返回对象转换为json响应给客户端</p>
</li>
<li><p><strong>PathVariable注解</strong><br>  作用：拥有绑定url中的占位符的</p>
</li>
</ul>
<h2 id="11、转发与重定向"><a href="#11、转发与重定向" class="headerlink" title="11、转发与重定向"></a>11、转发与重定向</h2><ul>
<li><p><strong>请求次数：</strong>重定向是浏览器向服务器发送一个请求并收到响应后再次向一个新地址发出请求，转发是服务器收到请求后为了完成响应跳转到一个新的地址；重定向至少请求两次，转发请求一次；</p>
</li>
<li><p><strong>地址栏不同：</strong>重定向地址栏会发生变化，转发地址栏不会发生变化；</p>
</li>
<li><p><strong>是否共享数据：</strong>重定向两次请求不共享数据，转发一次请求共享数据（在request级别使用信息共享，使用重定向必然出错）；</p>
</li>
<li><p><strong>跳转限制：</strong>重定向可以跳转到任意URL，转发只能跳转本站点资源；</p>
</li>
<li><p><strong>发生行为不同：</strong>重定向是客户端行为，转发是服务器端行为；</p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/16/Redis知识概述/" rel="next" title="Redis知识概述">
                <i class="fa fa-chevron-left"></i> Redis知识概述
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/07/18/JavaWeb-Mybatis框架-1/" rel="prev" title="JavaWeb-Mybatis框架(1)">
                JavaWeb-Mybatis框架(1) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="guoLipa" />
            
              <p class="site-author-name" itemprop="name">guoLipa</p>
              <p class="site-description motion-element" itemprop="description">Internet of things</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/guolipa" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="2813281589@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/p/1005053994861822/home?from=page_100505&mod=TAB&is_all=1#place" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/sinat_41847989" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-cc"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、Mybatis"><span class="nav-number">1.</span> <span class="nav-text">一、Mybatis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-什么是Mybatis？"><span class="nav-number">1.1.</span> <span class="nav-text">1. 什么是Mybatis？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Mybatis-的优缺点"><span class="nav-number">1.2.</span> <span class="nav-text">2. Mybatis 的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mybaits的优点："><span class="nav-number">1.2.1.</span> <span class="nav-text">Mybaits的优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MyBatis框架的缺点："><span class="nav-number">1.2.2.</span> <span class="nav-text">MyBatis框架的缺点：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-MyBatis与Hibernate有哪些不同？"><span class="nav-number">1.3.</span> <span class="nav-text">3. MyBatis与Hibernate有哪些不同？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-两者最大的区别："><span class="nav-number">1.3.1.</span> <span class="nav-text">1). 两者最大的区别：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-开发难度对比"><span class="nav-number">1.3.2.</span> <span class="nav-text">2). 开发难度对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-数据库扩展性比较"><span class="nav-number">1.3.3.</span> <span class="nav-text">3).数据库扩展性比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#适用场景："><span class="nav-number">1.3.4.</span> <span class="nav-text">适用场景：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><span class="nav-number">1.4.</span> <span class="nav-text">4. 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-和-的区别是什么？"><span class="nav-number">1.5.</span> <span class="nav-text">5. #{}和${}的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-当实体类中的属性名和表中的字段名不一样-，怎么办-？"><span class="nav-number">1.6.</span> <span class="nav-text">6. 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第1种：-通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。"><span class="nav-number">1.6.1.</span> <span class="nav-text">第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-模糊查询like语句该怎么写"><span class="nav-number">1.7.</span> <span class="nav-text">7. 模糊查询like语句该怎么写?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第1种：在Java代码中添加sql通配符。"><span class="nav-number">1.7.1.</span> <span class="nav-text">第1种：在Java代码中添加sql通配符。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第2种：在sql语句中拼接通配符，会引起sql注入"><span class="nav-number">1.7.2.</span> <span class="nav-text">第2种：在sql语句中拼接通配符，会引起sql注入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-MyBatis常用对象SqlSessionFactory和SqlSession介绍和运用"><span class="nav-number">1.8.</span> <span class="nav-text">8. MyBatis常用对象SqlSessionFactory和SqlSession介绍和运用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从-XML-中构建-SqlSessionFactory"><span class="nav-number">1.8.1.</span> <span class="nav-text">从 XML 中构建 SqlSessionFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从-SqlSessionFactory-中获取-SqlSession"><span class="nav-number">1.8.2.</span> <span class="nav-text">从 SqlSessionFactory 中获取 SqlSession</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-映射配置文件"><span class="nav-number">1.9.</span> <span class="nav-text">9. 映射配置文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-Mybatis的缓存"><span class="nav-number">1.10.</span> <span class="nav-text">10. Mybatis的缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mybatis中的延迟加载"><span class="nav-number">1.10.1.</span> <span class="nav-text">Mybatis中的延迟加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mybatis中的缓存"><span class="nav-number">1.10.2.</span> <span class="nav-text">Mybatis中的缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-Mybatis中的注解开发"><span class="nav-number">1.11.</span> <span class="nav-text">11. Mybatis中的注解开发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-单表的CUDA操作"><span class="nav-number">1.11.1.</span> <span class="nav-text">1) . 单表的CUDA操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）-多表操作配置"><span class="nav-number">1.11.2.</span> <span class="nav-text">2）. 多表操作配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"><span class="nav-number">1.12.</span> <span class="nav-text">12. 通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-Mybatis动态sql有什么用？执行原理？有哪些动态sql？"><span class="nav-number">1.13.</span> <span class="nav-text">13. Mybatis动态sql有什么用？执行原理？有哪些动态sql？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-MyBatis实现一对一有几种方式-具体怎么操作的？"><span class="nav-number">1.14.</span> <span class="nav-text">14. MyBatis实现一对一有几种方式? 具体怎么操作的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15、MyBatis实现一对多有几种方式-怎么操作的？"><span class="nav-number">1.15.</span> <span class="nav-text">15、MyBatis实现一对多有几种方式,怎么操作的？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、-Spring"><span class="nav-number">2.</span> <span class="nav-text">二、 Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Spring框架是什么？"><span class="nav-number">2.1.</span> <span class="nav-text">1. Spring框架是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Spring的优势"><span class="nav-number">2.2.</span> <span class="nav-text">2. Spring的优势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Spring模块组成"><span class="nav-number">2.3.</span> <span class="nav-text">3. Spring模块组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、-Spring的IOC"><span class="nav-number">2.4.</span> <span class="nav-text">4、 Spring的IOC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-BeanFactory和ApplicationContext有什么区别"><span class="nav-number">2.5.</span> <span class="nav-text">5. BeanFactory和ApplicationContext有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Spring中的依赖注入"><span class="nav-number">2.6.</span> <span class="nav-text">6. Spring中的依赖注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-构造函数注入"><span class="nav-number">2.6.1.</span> <span class="nav-text">1) 构造函数注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-set方法注入"><span class="nav-number">2.6.2.</span> <span class="nav-text">2) set方法注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3）注入集合"><span class="nav-number">2.6.3.</span> <span class="nav-text">3）注入集合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-Bean生命周期"><span class="nav-number">2.7.</span> <span class="nav-text">7. Bean生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-Bean作用域？默认什么级别？是否线程安全？Spring如何保障线程安全的"><span class="nav-number">2.8.</span> <span class="nav-text">8. Bean作用域？默认什么级别？是否线程安全？Spring如何保障线程安全的?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean作用域"><span class="nav-number">2.8.1.</span> <span class="nav-text">Bean作用域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9、-Spring的AOP"><span class="nav-number">2.9.</span> <span class="nav-text">9、 Spring的AOP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10、动态代理"><span class="nav-number">2.10.</span> <span class="nav-text">10、动态代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11、-AOP相关术语"><span class="nav-number">2.11.</span> <span class="nav-text">11、 AOP相关术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12、-Spring中的通知类型"><span class="nav-number">2.12.</span> <span class="nav-text">12、 Spring中的通知类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1）在aop-aspect标签的内部使用对应标签来配置通知的类型"><span class="nav-number">2.12.1.</span> <span class="nav-text">1）在aop:aspect标签的内部使用对应标签来配置通知的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2）使用aop-pointcut配置切入点表达式"><span class="nav-number">2.12.1.0.1.</span> <span class="nav-text">2）使用aop:pointcut配置切入点表达式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13、-Spring-框架中都用到了哪些设计模式？"><span class="nav-number">2.13.</span> <span class="nav-text">13、 Spring 框架中都用到了哪些设计模式？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、SpringMVC"><span class="nav-number">3.</span> <span class="nav-text">三、SpringMVC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-什么是Spring-MVC-？简单介绍下你对springMVC的理解"><span class="nav-number">3.1.</span> <span class="nav-text">1. 什么是Spring MVC ？简单介绍下你对springMVC的理解?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、Springmvc的优点"><span class="nav-number">3.2.</span> <span class="nav-text">2、Springmvc的优点:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-SpringMVC和Struts2的联系与区别"><span class="nav-number">3.3.</span> <span class="nav-text">3. SpringMVC和Struts2的联系与区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#共同点："><span class="nav-number">3.3.1.</span> <span class="nav-text">共同点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区别："><span class="nav-number">3.3.2.</span> <span class="nav-text">区别：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Spring-MVC的主要组件？"><span class="nav-number">3.4.</span> <span class="nav-text">4. Spring MVC的主要组件？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-SpringMVC的流程？"><span class="nav-number">3.5.</span> <span class="nav-text">5. SpringMVC的流程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-RequestMapping注解"><span class="nav-number">3.6.</span> <span class="nav-text">6. RequestMapping注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-SpringMVC常用的注解有哪些？"><span class="nav-number">3.7.</span> <span class="nav-text">7. SpringMVC常用的注解有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-请求参数的绑定"><span class="nav-number">3.8.</span> <span class="nav-text">8. 请求参数的绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#支持的数据类型："><span class="nav-number">3.8.1.</span> <span class="nav-text">支持的数据类型：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-如何解决POST请求中文乱码问题，GET的又如何处理呢？"><span class="nav-number">3.9.</span> <span class="nav-text">9. 如何解决POST请求中文乱码问题，GET的又如何处理呢？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#POST请求"><span class="nav-number">3.9.1.</span> <span class="nav-text">POST请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Get请求"><span class="nav-number">3.9.2.</span> <span class="nav-text">Get请求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10、-常用的注解"><span class="nav-number">3.10.</span> <span class="nav-text">10、 常用的注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RequestParam注解"><span class="nav-number">3.10.0.1.</span> <span class="nav-text">RequestParam注解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11、转发与重定向"><span class="nav-number">3.11.</span> <span class="nav-text">11、转发与重定向</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">guoLipa</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
